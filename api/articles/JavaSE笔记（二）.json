{"title":"JavaSE笔记（二）","uid":"c02ca665cd1f72f1b198d0583b891337","slug":"JavaSE笔记（二）","date":"2022-03-09T03:41:48.987Z","updated":"2022-03-09T05:26:00.939Z","comments":true,"path":"api/articles/JavaSE笔记（二）.json","keywords":null,"cover":[],"content":"<h1 id=\"Java对象和多态-（面向对象）\"><a href=\"#Java对象和多态-（面向对象）\" class=\"headerlink\" title=\"Java对象和多态 （面向对象）\"></a>Java对象和多态 （面向对象）</h1><h2 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p>\n<p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Scanner sc &#x3D; new Scanner(System.in);\nString str &#x3D; sc.nextLine();\nSystem.out.println(&quot;你输入了：&quot;+str);\nsc.close();</code></pre>\n\n<p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p>\n<p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p>\n<p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p>\n<hr>\n<h2 id=\"类的基本结构\"><a href=\"#类的基本结构\" class=\"headerlink\" title=\"类的基本结构\"></a>类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    int age;\n    String name;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Test test &#x3D; new Test();\n    test.name &#x3D; &quot;奥利给&quot;;\n    System.out.println(test.name);\n&#125;</code></pre>\n\n<p>成员变量默认带有初始值，也可以自己定义初始值。</p>\n<h3 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n  &#x2F;&#x2F;Body\n&#125;</code></pre>\n\n<p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p>\n<h4 id=\"方法的定义和使用\"><a href=\"#方法的定义和使用\" class=\"headerlink\" title=\"方法的定义和使用\"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">[返回值类型] 方法名称([参数])&#123;\n  &#x2F;&#x2F;方法体\n  return 结果;\n&#125;</code></pre>\n\n<ul>\n<li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li>\n<li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li>\n<li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li>\n<li>方法体：方法具体要干的事情</li>\n<li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li>\n</ul>\n<p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int test(int a)&#123;\n  if(a &gt; 0)&#123;\n    &#x2F;&#x2F;缺少retrun语句！\n  &#125;else&#123;\n    return 0;\n  &#125;\n&#125;</code></pre>\n\n<p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void main(String[] args) &#123;\n   for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n       if(i &#x3D;&#x3D; 1) return;   &#x2F;&#x2F;在循环内返回了！和break区别？\n   &#125;\n   System.out.println(&quot;淦&quot;);   &#x2F;&#x2F;还会到这里吗？\n&#125;</code></pre>\n\n<p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    int a &#x3D; 10, b &#x3D; 20;\n  \tnew Test().swap(a, b);\n  \tSystem.out.println(&quot;a&#x3D;&quot;+a+&quot;, b&#x3D;&quot;+b);\n&#125;\n\npublic class Test&#123;\n \tvoid swap(int a, int b)&#123;  &#x2F;&#x2F;传递的仅仅是值而已！\n  \t\tint temp &#x3D; a;\n  \t\ta &#x3D; b;\n \t\t\tb &#x3D; temp;\n\t&#125; \n&#125;</code></pre>\n\n<p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class B&#123;\n \tString name;\n&#125;\n\npublic class A&#123;\n \tvoid test(B b)&#123;  &#x2F;&#x2F;传递的是对象的引用，而不是值\n    System.out.println(b.name);\n  &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    int a &#x3D; 10, b &#x3D; 20;\n  \tB b &#x3D; new B();\n  \tb.name &#x3D; &quot;lbw&quot;;\n  \tnew A().test(b);\n  \tSystem.out.println(&quot;a&#x3D;&quot;+a+&quot;, b&#x3D;&quot;+b);\n&#125;</code></pre>\n\n<p>方法之间可以相互调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void a()&#123;\n  &#x2F;&#x2F;xxxx\n&#125;\n\nvoid b()&#123;\n  a();\n&#125;</code></pre>\n\n<p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int a()&#123;\n  return a();\n&#125;</code></pre>\n\n<p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p>\n<hr>\n<h3 id=\"对象设计练习\"><a href=\"#对象设计练习\" class=\"headerlink\" title=\"对象设计练习\"></a>对象设计练习</h3><ul>\n<li>学生应该具有以下属性：名字、年龄</li>\n<li>学生应该具有以下行为：学习、运动、说话</li>\n</ul>\n<hr>\n<h3 id=\"方法的重载\"><a href=\"#方法的重载\" class=\"headerlink\" title=\"方法的重载\"></a>方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    int a()&#123;   &#x2F;&#x2F;原本的方法\n       return 1;\n    &#125;\n\n    int a(int i)&#123;  &#x2F;&#x2F;ok，形参不同\n        return i;\n    &#125;\n    \n    void a(byte i)&#123;  &#x2F;&#x2F;ok，返回类型和形参都不同\n        \n    &#125;\n    \n    void a()&#123;  &#x2F;&#x2F;错误，仅返回值类型名称不同不能重载\n        \n    &#125;\n&#125;</code></pre>\n\n<p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    int sum(int a, int b)&#123;   &#x2F;&#x2F;只有int支持，不灵活！\n        return a+b;\n    &#125;\n    \n    double sum(double a, double b)&#123;  &#x2F;&#x2F;重写一个double类型的，就支持小数计算了\n        return a+b;\n    &#125;\n&#125;</code></pre>\n\n<p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    void a(int i)&#123;\n        System.out.println(&quot;调用了int&quot;);\n    &#125;\n\n    void a(short i)&#123;\n        System.out.println(&quot;调用了short&quot;);\n    &#125;\n\n    void a(long i)&#123;\n        System.out.println(&quot;调用了long&quot;);\n    &#125;\n\n    void a(char i)&#123;\n        System.out.println(&quot;调用了char&quot;);\n    &#125;\n\n    void a(double i)&#123;\n        System.out.println(&quot;调用了double&quot;);\n    &#125;\n\n    void a(float i)&#123;\n        System.out.println(&quot;调用了float&quot;);\n    &#125;\n  \n  \tpublic static void main(String[] args) &#123;\n        Test test &#x3D; new Test();\n        test.a(1);   &#x2F;&#x2F;直接输入整数\n        test.a(1.0);  &#x2F;&#x2F;直接输入小数\n\n        short s &#x3D; 2;\n        test.a(s);  &#x2F;&#x2F;会对号入座吗？\n        test.a(1.0F);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;反编译结果\npackage com.test;\n\npublic class Test &#123;\n    public Test() &#123;    &#x2F;&#x2F;即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的\n    &#125;\n&#125;</code></pre>\n\n<p>反编译其实就是把我们编译好的class文件变回Java源代码。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Test test &#x3D; new Test();  &#x2F;&#x2F;实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的\n&#x2F;&#x2F; new + 你想要使用的构造方法</code></pre>\n\n<p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p>\n<p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p>\n<p>一般最常用的就是给成员属性赋初始值：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    String name;\n    \n    Student()&#123;\n        name &#x3D; &quot;伞兵一号&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    String name;\n\n    Student(String name)&#123;   &#x2F;&#x2F;形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！\n        this.name &#x3D; name;  &#x2F;&#x2F;通过this指代当前的对象属性，this就代表当前对象\n    &#125;\n&#125;\n\n&#x2F;&#x2F;idea 右键快速生成！</code></pre>\n\n<p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p>\n<p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;反编译后依然只有我们定义的有参构造！</code></pre>\n\n<p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    String name;\n\n    Student()&#123;\n\n    &#125;\n\n    Student(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<p>成员变量的初始化始终在构造方法执行之前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    String a &#x3D; &quot;sadasa&quot;;\n\n    Student()&#123;\n        System.out.println(a);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Student s &#x3D; new Student();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"静态变量和静态方法\"><a href=\"#静态变量和静态方法\" class=\"headerlink\" title=\"静态变量和静态方法\"></a>静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    static int a;\n&#125;\n\npublic static void main(String[] args) &#123;\n\tStudent s1 &#x3D; new Student();\n\ts1.a &#x3D; 10;\n\tStudent s2 &#x3D; new Student();\n\tSystem.out.println(s2.a);\n&#125;</code></pre>\n\n<p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n   Student.a &#x3D; 10;\n   System.out.println(Student.a);\n&#125;</code></pre>\n\n<h4 id=\"简述类加载机制\"><a href=\"#简述类加载机制\" class=\"headerlink\" title=\"简述类加载机制\"></a>简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p>\n<ul>\n<li>访问类的静态变量，或者为静态变量赋值</li>\n<li>new 创建类的实例（隐式加载）</li>\n<li>调用类的静态方法</li>\n<li>子类初始化时</li>\n<li>其他的情况会在讲到反射时介绍</li>\n</ul>\n<p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    static int a &#x3D; test();  &#x2F;&#x2F;直接调用静态方法，只能调用静态方法\n\n    Student()&#123;\n        System.out.println(&quot;构造类对象&quot;);\n    &#125;\n\n    static int test()&#123;   &#x2F;&#x2F;静态方法刚加载时就有了\n        System.out.println(&quot;初始化变量a&quot;);\n        return 1;\n    &#125;\n&#125;</code></pre>\n\n<p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    static int a &#x3D; test();\n\n    static int test()&#123;\n        return a;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        System.out.println(Student.a);\n    &#125;\n&#125;</code></pre>\n\n<p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p>\n<h3 id=\"代码块和静态代码块\"><a href=\"#代码块和静态代码块\" class=\"headerlink\" title=\"代码块和静态代码块\"></a>代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    &#123;\n        System.out.println(&quot;我是代码块&quot;);\n    &#125;\n\n    Student()&#123;\n        System.out.println(&quot;我是构造方法&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    static int a;\n\n    static &#123;\n        a &#x3D; 10;\n    &#125;\n    \n    public static void main(String[] args) &#123;\n        System.out.println(Student.a);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"String和StringBuilder类\"><a href=\"#String和StringBuilder类\" class=\"headerlink\" title=\"String和StringBuilder类\"></a>String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p>\n<p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String a &#x3D; &quot;dasdsa&quot;, b &#x3D; &quot;dasdasdsa&quot;;\nString l &#x3D; a+b;\nSystem.out.println(l);</code></pre>\n\n<p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String result&#x3D;&quot;String&quot;+&quot;and&quot;; &#x2F;&#x2F;会被优化成一句！</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str1&#x3D;&quot;String&quot;;\nString str2&#x3D;&quot;and&quot;;\nString result&#x3D;str1+str2;\n&#x2F;&#x2F;变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str1&#x3D;&quot;String&quot;;\nString str2&#x3D;&quot;and&quot;;\nString result&#x3D;(new StringBuilder(String.valueOf(str1))).append(str2).toString();\n&#x2F;&#x2F;使用StringBuilder，会采用类似于第一种实现，显然会更快！</code></pre>\n\n<p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">StringBuilder builder &#x3D; new StringBuilder();\nbuilder\n       .append(&quot;a&quot;)\n       .append(&quot;bc&quot;)\n       .append(&quot;d&quot;);   &#x2F;&#x2F;链式调用\nString str &#x3D; builder.toString();\nSystem.out.println(str);</code></pre>\n\n<hr>\n<h2 id=\"包和访问控制\"><a href=\"#包和访问控制\" class=\"headerlink\" title=\"包和访问控制\"></a>包和访问控制</h2><h3 id=\"包声明和导入\"><a href=\"#包声明和导入\" class=\"headerlink\" title=\"包声明和导入\"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.test;\n\npublic class Test&#123;\n  \n&#125;</code></pre>\n\n<p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p>\n<p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p>\n<p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C&#x2F;C++中的include）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.test.Student;</code></pre>\n\n<p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.test.*</code></pre>\n\n<p>Java默认为我们导入了以下的包，不需要去声明</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.*</code></pre>\n\n<h3 id=\"静态导入\"><a href=\"#静态导入\" class=\"headerlink\" title=\"静态导入\"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import static com.test.ui.Student.test;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        test();\n    &#125;\n&#125;</code></pre>\n\n<p>静态导入不会进行类的初始化！</p>\n<h3 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p>\n<p>![image-20210819160939950](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210819160939950.png)</p>\n<p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private int a &#x3D; 10;   &#x2F;&#x2F;具有私有访问权限，只能类内部访问\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student s &#x3D; new Student();\n    System.out.println(s.a);  &#x2F;&#x2F;还可以访问吗？\n&#125;</code></pre>\n\n<p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Student.java\npublic class Student &#123;\n    \n&#125;\nclass Test&#123;   &#x2F;&#x2F;不能添加权限修饰符！只能是default\n\t\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605\" alt=\"img\"></p>\n<p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[10];  &#x2F;&#x2F;需要new关键字来创建！\nString[] arr2 &#x3D; new String[10];</code></pre>\n\n<p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[10];\nSystem.out.println(arr.length);   &#x2F;&#x2F;数组有成员变量！\nSystem.out.println(arr.toString());   &#x2F;&#x2F;数组有成员方法！</code></pre>\n\n<h3 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">类型[] 变量名称 &#x3D; new 类型[数组大小];\n类型 变量名称n &#x3D; new 类型[数组大小];  &#x2F;&#x2F;支持C语言样式，但不推荐！\n\n类型[] 变量名称 &#x3D; new 类型[]&#123;...&#125;;  &#x2F;&#x2F;静态初始化（直接指定值和大小）\n类型[] 变量名称 &#x3D; &#123;...&#125;;   &#x2F;&#x2F;同上，但是只能在定义时赋值</code></pre>\n\n<p> 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[10];\narr[0] &#x3D; 626;\nSystem.out.println(arr[0]);\nSystem.out.println(arr[1]);</code></pre>\n\n<p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nSystem.out.println(arr.length);  &#x2F;&#x2F;打印length成员变量的值</code></pre>\n\n<p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String[] arr &#x3D; new String[10];\nSystem.out.println(arr[10]);  &#x2F;&#x2F;出现异常！\n\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11\n&#x2F;&#x2F;\tat com.test.Application.main(Application.java:7)</code></pre>\n\n<p>思考：能不能直接修改length的值来实现动态扩容呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\narr.length &#x3D; 10;</code></pre>\n\n<p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\n    test(arr);\n    System.out.println(arr[0]);\n&#125;\n\nprivate static void test(int[] arr)&#123;\n    arr[0] &#x3D; 2934;\n&#125;</code></pre>\n\n<h3 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p>\n<h4 id=\"传统for循环\"><a href=\"#传统for循环\" class=\"headerlink\" title=\"传统for循环\"></a>传统for循环</h4><p>我们很容易就联想到for循环</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n   System.out.println(arr[i]);\n&#125;</code></pre>\n\n<h4 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nfor (int i : arr) &#123;\n    System.out.println(i);\n&#125;</code></pre>\n\n<p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p>\n<h3 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e\" alt=\"img\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;三行两列\nint[][] arr &#x3D; &#123; &#123;1, 2&#125;,\n                &#123;3, 4&#125;,\n                &#123;5, 6&#125;&#125;;\nSystem.out.println(arr[2][1]);</code></pre>\n\n<p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[][] arr &#x3D; new int[][]&#123; &#123;1, 2&#125;,\n                           &#123;3, 4&#125;,\n                           &#123;5, 6&#125;&#125;;\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\n     for (int j &#x3D; 0; j &lt; 2; j++) &#123;\n          System.out.println(arr[i][j]);\n     &#125;\n&#125;</code></pre>\n\n<h3 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p>\n<h3 id=\"可变长参数\"><a href=\"#可变长参数\" class=\"headerlink\" title=\"可变长参数\"></a>可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n     test(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;);    &#x2F;&#x2F;可变长，最后都会被自动封装成一个数组\n&#125;\n    \nprivate static void test(String... test)&#123;\n     System.out.println(test[0]);    &#x2F;&#x2F;其实参数就是一个数组\n&#125;</code></pre>\n\n<p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p>\n<h3 id=\"实战：三大基本排序算法\"><a href=\"#实战：三大基本排序算法\" class=\"headerlink\" title=\"实战：三大基本排序算法\"></a>实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; &#123;8, 5, 0, 1, 4, 9, 2, 3, 6, 7&#125;;</code></pre>\n\n<p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p>\n<ul>\n<li>冒泡排序</li>\n</ul>\n<p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p>\n<ul>\n<li>插入排序</li>\n</ul>\n<p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94\" alt=\"img\"></p>\n<ul>\n<li>选择排序</li>\n</ul>\n<p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p>\n<hr>\n<h2 id=\"封装、继承和多态\"><a href=\"#封装、继承和多态\" class=\"headerlink\" title=\"封装、继承和多态\"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p>\n<p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private String name;\n    private int age;\n  \n    public Student(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;</code></pre>\n\n<p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void setName(String name) &#123;\n    if(name.contains(&quot;小&quot;)) return;\n    this.name &#x3D; name;\n&#125;</code></pre>\n\n<p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p>\n<p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p>\n<p>封装就是通过访问权限控制来实现的。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p>\n<p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SportsStudent extends Student&#123;   &#x2F;&#x2F;通过extends关键字来继承父类\n\n    public SportsStudent(String name, int age) &#123;\n        super(name, age);   &#x2F;&#x2F;必须先通过super关键字（指代父类），实现父类的构造方法！\n    &#125;\n\n    public void exercise()&#123;\n        System.out.println(&quot;我超勇的！&quot;);\n    &#125;\n&#125;\n\npublic class ArtStudent extends Student&#123;\n\n    public ArtStudent(String name, int age) &#123;\n        super(name, age);\n    &#125;\n\n    public void art()&#123;\n        System.out.println(&quot;随手画个毕加索！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p>\n<p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p>\n<p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\nObject obj &#x3D; new Object;\nSystem.out.println(obj.hashCode());  &#x2F;&#x2F;求对象的hashcode，默认是对象的内存地址\nSystem.out.println(obj.equals(obj));  &#x2F;&#x2F;比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 &#x3D;&#x3D;\nSystem.out.println(obj.toString());  &#x2F;&#x2F;将对象转换为字符串，默认生成对象的类名称+hashcode\n&#125;</code></pre>\n\n<p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p>\n<h4 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;父类中的study\npublic void study()&#123;\n    System.out.println(&quot;学习&quot;);\n&#125;\n\n&#x2F;&#x2F;子类中的study\n@Override  &#x2F;&#x2F;声明这个方法是重写的，但是可以不要，我们现阶段不接触\npublic void study()&#123;\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;</code></pre>\n\n<p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n     SportsStudent student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);\n     student.study();   &#x2F;&#x2F;输出子类定义的内容\n&#125;</code></pre>\n\n<p>思考：静态方法能被重写吗？</p>\n<p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void study()&#123;\n    super.study();\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;</code></pre>\n\n<p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void setTest(int test)&#123;\n    test &#x3D; 1;\n  \tthis.test &#x3D; 1;\n  \tsuper.test &#x3D; 1;\n&#125;</code></pre>\n\n<h4 id=\"再谈类型转换\"><a href=\"#再谈类型转换\" class=\"headerlink\" title=\"再谈类型转换\"></a>再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Student student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);  &#x2F;&#x2F;父类变量引用子类实例\nstudent.study();     &#x2F;&#x2F;得到依然是具体实现的结果，而不是当前类型的结果</code></pre>\n\n<p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Student student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);  &#x2F;&#x2F;是由SportsStudent进行实现的\n&#x2F;&#x2F;... do something...\n\nSportsStudent ps &#x3D; (SportsStudent)student;  &#x2F;&#x2F;让它变成一个具体的子类\nps.sport();  &#x2F;&#x2F;调用具体实现类的方法</code></pre>\n\n<p>这样的类型转换称为向下转型。</p>\n<h4 id=\"instanceof关键字\"><a href=\"#instanceof关键字\" class=\"headerlink\" title=\"instanceof关键字\"></a>instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static void test(Student student)&#123;\n    if (student instanceof SportsStudent)&#123;\n        SportsStudent sportsStudent &#x3D; (SportsStudent) student;\n        sportsStudent.sport();\n    &#125;else if (student instanceof ArtStudent)&#123;\n        ArtStudent artStudent &#x3D; (ArtStudent) student;\n        artStudent.art();\n    &#125;\n&#125;</code></pre>\n\n<p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p>\n<p>思考：<code>student instanceof Student</code>的结果是什么？</p>\n<h4 id=\"再谈final关键字\"><a href=\"#再谈final关键字\" class=\"headerlink\" title=\"再谈final关键字\"></a>再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class Student &#123;   &#x2F;&#x2F;类被声明为终态，那么它还能被继承吗\n  \t\n&#125;</code></pre>\n\n<p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void study()&#123;  &#x2F;&#x2F;还能重写吗\n    System.out.println(&quot;学习&quot;);\n&#125;</code></pre>\n\n<p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final String name;   &#x2F;&#x2F;引用类型不允许再指向其他对象\nprivate final int age;    &#x2F;&#x2F;基本类型值不允许发生改变\n\npublic Student(String name, int age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n&#125;</code></pre>\n\n<p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Student &#123;    &#x2F;&#x2F;抽象类\n\t\tpublic abstract void test();  &#x2F;&#x2F;抽象方法\n&#125;</code></pre>\n\n<p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p>\n<p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Student s &#x3D; new Student()&#123;    &#x2F;&#x2F;只能直接创建带实现的匿名内部类！\n  public void test()&#123;\n    \n  &#125;\n&#125;</code></pre>\n\n<p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void study()&#123;   &#x2F;&#x2F;现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;</code></pre>\n\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Eat &#123;\n\tvoid eat(); \n&#125;</code></pre>\n\n<p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Eat &#123;\n    default void eat()&#123;\n        &#x2F;&#x2F;do something...\n    &#125;\n&#125;</code></pre>\n\n<p>接口中定义的变量，默认为public static final</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Eat &#123;\n    int a &#x3D; 1;\n    void eat();\n&#125;</code></pre>\n\n<p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SportsStudent extends Student implements Eat, ...&#123;\n\t\t@Override\n    public void eat() &#123;\n        \n    &#125;\n&#125;</code></pre>\n\n<p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p>\n<p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p>\n<h3 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    class Inner&#123;   &#x2F;&#x2F;类中定义的一个内部类\n        \n    &#125;\n&#125;</code></pre>\n\n<p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Test test &#x3D; new Test();\n    Test.Inner inner &#x3D; test.new Inner();   &#x2F;&#x2F;写法有那么一丝怪异，但是没毛病！\n&#125;</code></pre>\n\n<h3 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    static class Inner&#123;\n\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Test.Inner inner &#x3D; new Test.Inner();   &#x2F;&#x2F;不用再创建外部类对象了！\n&#125;</code></pre>\n\n<h3 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n    public void test()&#123;\n        class Inner&#123;\n\n        &#125;\n        \n        Inner inner &#x3D; new Inner();\n    &#125;\n&#125;</code></pre>\n\n<p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p>\n<h3 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        Eat eat &#x3D; new Eat() &#123;\n            @Override\n            public void eat() &#123;\n                &#x2F;&#x2F;DO something...\n            &#125;\n        &#125;;\n    &#125;</code></pre>\n\n<p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p>\n<h4 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        Eat eat &#x3D; new Eat() &#123;\n            @Override\n            public void eat() &#123;\n                &#x2F;&#x2F;DO something...\n            &#125;\n        &#125;;\n    &#125;\n\npublic static void main(String[] args) &#123;\n        Eat eat &#x3D; () -&gt; &#123;&#125;;   &#x2F;&#x2F;等价于上述内容\n    &#125;</code></pre>\n\n<p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p>\n<p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p>\n<h2 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private final String name;\n    private final int age;\n    private String status;\n  \n  \t&#x2F;&#x2F;...\n  \n  \tpublic void setStatus(String status) &#123;\n        this.status &#x3D; status;\n    &#125;\n\n    public String getStatus() &#123;\n        return status;\n    &#125;\n&#125;</code></pre>\n\n<p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p>\n<p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum Status &#123;\n    RUNNING, STUDY, SLEEP    &#x2F;&#x2F;直接写每个状态的名字即可，分号可以不打，但是推荐打上\n&#125;</code></pre>\n\n<p>使用枚举类也非常方便，我们只需要直接访问即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    private final String name;\n    private final int age;\n    private Status status;\n  \n \t\t&#x2F;&#x2F;...\n  \n  \tpublic void setStatus(Status status) &#123;   &#x2F;&#x2F;不再是String，而是我们指定的枚举类型\n        this.status &#x3D; status;\n    &#125;\n\n    public Status getStatus() &#123;\n        return status;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student student &#x3D; new Student(&quot;小明&quot;, 18);\n    student.setStatus(Status.RUNNING);\n    System.out.println(student.getStatus());\n&#125;</code></pre>\n\n<p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Compiled from &quot;Status.java&quot;\npublic final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; &#123;\n  public static final com.test.Status RUNNING;\n  public static final com.test.Status STUDY;\n  public static final com.test.Status SLEEP;\n  public static com.test.Status[] values();\n  public static com.test.Status valueOf(java.lang.String);\n  static &#123;&#125;;\n&#125;</code></pre>\n\n<p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum Status &#123;\n    RUNNING(&quot;睡觉&quot;), STUDY(&quot;学习&quot;), SLEEP(&quot;睡觉&quot;);   &#x2F;&#x2F;无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）\n\n    private final String name;    &#x2F;&#x2F;枚举的成员变量\n    Status(String name)&#123;    &#x2F;&#x2F;覆盖原有构造方法（默认private，只能内部使用！）\n        this.name &#x3D; name;\n    &#125;\n  \n  \tpublic String getName() &#123;   &#x2F;&#x2F;获取封装的成员变量\n        return name;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student student &#x3D; new Student(&quot;小明&quot;, 18);\n    student.setStatus(Status.RUNNING);\n    System.out.println(student.getStatus().getName());\n&#125;</code></pre>\n\n<p>枚举类还自带一些继承下来的实用方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Status.valueOf(&quot;&quot;)   &#x2F;&#x2F;将名称相同的字符串转换为枚举\nStatus.values()   &#x2F;&#x2F;快速获取所有的枚举</code></pre>\n\n<h2 id=\"基本类型包装类\"><a href=\"#基本类型包装类\" class=\"headerlink\" title=\"基本类型包装类\"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p>\n<p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png\" alt=\"img\"></p>\n<ul>\n<li>byte  -&gt;  Byte      </li>\n<li>boolean  -&gt;  Boolean   </li>\n<li>short  -&gt;  Short    </li>\n<li>char  -&gt;  Character  </li>\n<li>int -&gt; Integer    </li>\n<li>long -&gt;  Long     </li>\n<li>float -&gt; Float      </li>\n<li>double -&gt; Double</li>\n</ul>\n<p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final int value;   &#x2F;&#x2F;Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作\n\npublic Integer(int value) &#123;\n    this.value &#x3D; value;\n&#125;</code></pre>\n\n<p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n     Integer i &#x3D; 1;   &#x2F;&#x2F;包装类型可以直接接收对应类型的数据，并变为一个对象！\n     System.out.println(i + i);    &#x2F;&#x2F;包装类型可以直接被当做一个基本类型进行操作！\n&#125;</code></pre>\n\n<h4 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i &#x3D; 1;    &#x2F;&#x2F;其实这里只是简写了而已\nInteger i &#x3D; Integer.valueOf(1);  &#x2F;&#x2F;编译后真正的样子</code></pre>\n\n<p>调用valueOf来生成一个Integer对象！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)   &#x2F;&#x2F;注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）\n       return IntegerCache.cache[i + (-IntegerCache.low)];\n  \treturn new Integer(i);   &#x2F;&#x2F;返回一个新创建好的对象\n&#125;</code></pre>\n\n<p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Integer i &#x3D; Integer.valueOf(1);\n    int a &#x3D; i;    &#x2F;&#x2F;简写\n    int a &#x3D; i.intValue();   &#x2F;&#x2F;编译后实际的代码\n  \n  \tlong c &#x3D; i.longValue();   &#x2F;&#x2F;其他类型也有！\n&#125;</code></pre>\n\n<p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Integer i1 &#x3D; 28914;\n    Integer i2 &#x3D; 28914;\n\n    System.out.println(i1 &#x3D;&#x3D; i2);   &#x2F;&#x2F;实际上判断是两个对象是否为同一个对象（内存地址是否相同）\n    System.out.println(i1.equals(i2));   &#x2F;&#x2F;这个才是真正的值判断！\n&#125;</code></pre>\n\n<p>注意IntegerCache带来的影响！</p>\n<p>思考：下面这种情况结果会是什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Integer i1 &#x3D; 28914;\n    Integer i2 &#x3D; 28914;\n\n    System.out.println(i1+1 &#x3D;&#x3D; i2+1);\n&#125;</code></pre>\n\n<p>在集合类的学习中，我们还会继续用到我们的包装类型！</p>\n<hr>\n<h2 id=\"面向对象编程实战\"><a href=\"#面向对象编程实战\" class=\"headerlink\" title=\"面向对象编程实战\"></a>面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    int sum &#x3D; 0;\n    for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;   &#x2F;&#x2F;for循环暴力求解，简单，但是效率似乎低了一些\n        sum +&#x3D; i;\n    &#125;\n    System.out.println(sum);\n&#125;\n\npublic static void main(String[] args) &#123;\n    System.out.println((1 + 100) * 50);  &#x2F;&#x2F;高斯求和公式，利用数学，瞬间计算结果！\n&#125;</code></pre>\n\n<p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p>\n<h3 id=\"对象设计（面向对象、多态运用）\"><a href=\"#对象设计（面向对象、多态运用）\" class=\"headerlink\" title=\"对象设计（面向对象、多态运用）\"></a>对象设计（面向对象、多态运用）</h3><ul>\n<li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li>\n<li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li>\n<li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li>\n</ul>\n<h3 id=\"二分搜索（搜索算法）\"><a href=\"#二分搜索（搜索算法）\" class=\"headerlink\" title=\"二分搜索（搜索算法）\"></a>二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[]&#123;1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26&#125;;   &#x2F;&#x2F;测试用例\n\nprivate static int test(int[] arr, int target)&#123;\n    &#x2F;&#x2F;请在这里实现搜索算法\n&#125;</code></pre>\n\n<h3 id=\"快速排序（排序算法、递归分治）\"><a href=\"#快速排序（排序算法、递归分治）\" class=\"headerlink\" title=\"快速排序（排序算法、递归分治）\"></a>快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p>\n<p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p>\n<h3 id=\"0-x2F-1背包问题（回溯法、剪枝-x2F-动态规划优化）\"><a href=\"#0-x2F-1背包问题（回溯法、剪枝-x2F-动态规划优化）\" class=\"headerlink\" title=\"0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）\"></a>0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] w &#x3D; &#123;2, 3, 4, 5&#125;;\nint[] v &#x3D; &#123;3, 4, 5, 6&#125;;\nint capacity &#x3D; 8;</code></pre>","text":"Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%A4%9A%E6%80%81-%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89\"><span class=\"toc-text\">Java对象和多态 （面向对象）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">面向对象基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">类的基本结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">成员变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">成员方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">方法的定义和使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">对象设计练习</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法的重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态变量和静态方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%80%E8%BF%B0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">简述类加载机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">代码块和静态代码块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String%E5%92%8CStringBuilder%E7%B1%BB\"><span class=\"toc-text\">String和StringBuilder类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">包和访问控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">包声明和导入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">静态导入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">访问控制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数组类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">一维数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">数组的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">传统for循环</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#foreach\"><span class=\"toc-text\">foreach</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">二维数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">多维数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变长参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%EF%BC%9A%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">实战：三大基本排序算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">封装、继承和多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">封装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法的重写</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%B0%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">再谈类型转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#instanceof%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">instanceof关键字</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%B0%88final%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">再谈final关键字</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">成员内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">静态内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">局部内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">匿名内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">lambda表达式</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">枚举类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">基本类型包装类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">自动装箱和拆箱</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">面向对象编程实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%A4%9A%E6%80%81%E8%BF%90%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">对象设计（面向对象、多态运用）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">二分搜索（搜索算法）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%81%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%EF%BC%89\"><span class=\"toc-text\">快速排序（排序算法、递归分治）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#0-x2F-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%81%E5%89%AA%E6%9E%9D-x2F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%EF%BC%89\"><span class=\"toc-text\">0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）</span></a></li></ol></li></ol></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaSE笔记（三）","uid":"3acd6dd0df5d1947dcaf1fc3fec39ce8","slug":"JavaSE笔记（三）","date":"2022-03-09T03:41:52.829Z","updated":"2022-03-09T05:26:12.222Z","comments":true,"path":"api/articles/JavaSE笔记（三）.json","keywords":null,"cover":null,"text":"Java异常机制在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ public static void ...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaSE笔记（一）","uid":"c77d7175e79dc8945326daf0b5bc2787","slug":"JavaSE笔记（一）","date":"2022-03-09T03:41:38.630Z","updated":"2022-03-09T05:25:46.843Z","comments":true,"path":"api/articles/JavaSE笔记（一）.json","keywords":null,"cover":null,"text":"Java语法规范所有的Java语句必须以;结尾！ 无论是()、[]还是&#123;&#125;，所有的括号必须一一匹配！ 主方法的代码只能写在&#123;&#125;中！ Java基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Pyth...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}