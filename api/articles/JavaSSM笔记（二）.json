{"title":"JavaSSM笔记（二）","uid":"cb5396739d768c57aa162224d7506a32","slug":"JavaSSM笔记（二）","date":"2022-03-05T16:22:45.742Z","updated":"2022-03-05T16:23:57.708Z","comments":true,"path":"api/articles/JavaSSM笔记（二）.json","keywords":null,"cover":[],"content":"<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-37ff43e92267558c2fbaa70aedbfc133_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641702986&t=9a8080a4683d1e65b0b5e6f1ac764dfe\" alt=\"img\"></p>\n<h1 id=\"SpringMVC\"><a href=\"#SpringMVC\" class=\"headerlink\" title=\"SpringMVC\"></a>SpringMVC</h1><p>在前面学习完Spring框架技术之后，差不多会出现两批人：一批是听得云里雾里，依然不明白这个东西是干嘛的；还有一批就是差不多理解了核心思想，但是不知道这些东西该如何去发挥它的作用。在SpringMVC阶段，你就能逐渐够体会到Spring框架为我们带来的便捷之处了。</p>\n<p>此阶段，我们将再次回到Tomcat的Web应用程序开发中，去感受SpringMVC为我们带来的巨大便捷。</p>\n<h2 id=\"MVC理论基础\"><a href=\"#MVC理论基础\" class=\"headerlink\" title=\"MVC理论基础\"></a>MVC理论基础</h2><p>在之前，我们给大家讲解了三层架构，包括：</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs4.51cto.com%2Fwyfs02%2FM00%2F8B%2FBA%2FwKioL1hXU8vRX8elAAA2bXqAxMs799.png&refer=http%3A%2F%2Fs4.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641788288&t=1658084627505c12812596d8ca1b9885\" alt=\"点击查看源网页\"></p>\n<p>每一层都有着各自的职责，其中最关键的当属表示层，因为它相当于就是直接与用户的浏览器打交道的一层，并且所有的请求都会经过它进行解析，然后再告知业务层进行处理，任何页面的返回和数据填充也全靠表示层来完成，因此它实际上是整个三层架构中最关键的一层，而在之前的实战开发中，我们编写了大量的Servlet（也就是表示层实现）来处理来自浏览器的各种请求，但是我们发现，仅仅是几个很小的功能，以及几个很基本的页面，我们都要编写将近十个Servlet，如果是更加大型的网站系统，比如淘宝、B站，光是一个页面中可能就包含了几十甚至上百个功能，想想那样的话写起来得多恐怖。</p>\n<p>因此，SpringMVC正是为了解决这种问题而生的，它是一个非常优秀的表示层框架（在此之前还有一个叫做Struts2的框架，但是现阶段貌似快凉透了），采用MVC思想设计实现。</p>\n<p>MVC解释如下：</p>\n<ul>\n<li>M是指业务模型（Model）：通俗的讲就是我们之前用于封装数据传递的实体类。</li>\n<li>V是指用户界面（View）：一般指的是前端页面。</li>\n<li>C则是控制器（Controller）：控制器就相当于Servlet的基本功能，处理请求，返回响应。</li>\n</ul>\n<p><img src=\"https://pics5.baidu.com/feed/d0c8a786c9177f3e5707320277aeb1c39f3d5677.jpeg?token=e4c298063f4efa11fd0f94c2760c252b&s=782834721BC044435C55F4CA0000E0B1\" alt=\"点击查看源网页\"></p>\n<p>SpringMVC正是希望这三者之间进行解耦，实现各干各的，更加精细地划分对应的职责。最后再将View和Model进行渲染，得到最终的页面并返回给前端（就像之前使用Thymeleaf那样，把实体数据对象和前端页面都给到Thymeleaf，然后它会将其进行整合渲染得到最终有数据的页面，而本教程也会使用Thymeleaf作为视图解析器进行讲解）</p>\n<hr>\n<h2 id=\"配置环境并搭建项目\"><a href=\"#配置环境并搭建项目\" class=\"headerlink\" title=\"配置环境并搭建项目\"></a>配置环境并搭建项目</h2><p>由于SpringMVC还没有支持最新的Tomcat10（主要是之前提到的包名问题，神仙打架百姓遭殃）所以我们干脆就再来配置一下Tomcat9环境，相当于回顾一下。</p>\n<p>下载地址：<a href=\"https://tomcat.apache.org/download-90.cgi\">https://tomcat.apache.org/download-90.cgi</a></p>\n<p>添加SpringMVC的依赖：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.13&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>接着我们需要配置一下web.xml，将DispatcherServlet替换掉Tomcat自带的Servlet，这里url-pattern需要写为<code>/</code>，即可完成替换：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;mvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;mvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;</code></pre>\n\n<p>接着需要为整个Web应用程序配置一个Spring上下文环境（也就是容器），因为SpringMVC是基于Spring开发的，它直接利用Spring提供的容器来实现各种功能，这里我们直接使用注解方式进行配置，不再使用XML配置文件：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;com.example.config.MvcConfiguration&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;</code></pre>\n\n<p>如果还是想使用XML配置文件进行配置，那么可以直接这样写：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;init-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;配置文件名称&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;</code></pre>\n\n<p>如果你希望完完全全丢弃配置文件，可以直接添加一个类，Tomcat会在类路径中查找实现ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器，Spring提供了这个接口的实现类 SpringServletContainerInitializer , 通过@HandlesTypes(WebApplicationInitializer.class)设置，这个类反过来会查找实现WebApplicationInitializer 的类，并将配置的任务交给他们来完成，因此直接实现接口即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;MainConfiguration.class&#125;;   &#x2F;&#x2F;基本的Spring配置类，一般用于业务层配置\n    &#125;\n\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[0];  &#x2F;&#x2F;配置DispatcherServlet的配置类、主要用于Controller等配置\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#x2F;&#x2F;匹配路径，与上面一致\n    &#125;\n&#125;</code></pre>\n\n<p>顺便编写一下最基本的配置类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MainConfiguration &#123;\n\n&#125;</code></pre>\n\n<p>后面我们都采用无XML配置方式进行讲解。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/738818/201906/738818-20190617214214614-761905677.png\" alt=\"img\"></p>\n<p>这样，就完成最基本的配置了，现在任何请求都会优先经过<code>DispatcherServlet</code>进行集中处理，下面我们会详细讲解如何使用它。</p>\n<hr>\n<h2 id=\"Controller控制器\"><a href=\"#Controller控制器\" class=\"headerlink\" title=\"Controller控制器\"></a>Controller控制器</h2><p>有了SpringMVC之后，我们不必再像之前那样一个请求地址创建一个Servlet了，它使用<code>DispatcherServlet</code>替代Tomcat为我们提供的默认的静态资源Servlet，也就是说，现在所有的请求（除了jsp，因为Tomcat还提供了一个jsp的Servlet）都会经过<code>DispatcherServlet</code>进行处理。</p>\n<p>那么<code>DispatcherServlet</code>会帮助我们做什么呢？</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1190675%2F201812%2F1190675-20181203121258033-524477408.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642058685&t=13fd16796a8b5ed58762c9947f15681f\" alt=\"点击查看源网页\"></p>\n<p>根据图片我们可以了解，我们的请求到达Tomcat服务器之后，会交给当前的Web应用程序进行处理，而SpringMVC使用<code>DispatcherServlet</code>来处理所有的请求，也就是说它被作为一个统一的访问点，所有的请求全部由它来进行调度。</p>\n<p>当一个请求经过<code>DispatcherServlet</code>之后，会先走<code>HandlerMapping</code>，它会将请求映射为<code>HandlerExecutionChain</code>，依次经过<code>HandlerInterceptor</code>有点类似于之前我们所学的过滤器，不过在SpringMVC中我们使用的是拦截器，然后再交给<code>HandlerAdapter</code>，根据请求的路径选择合适的控制器进行处理，控制器处理完成之后，会返回一个<code>ModelAndView</code>对象，包括数据模型和视图，通俗的讲就是页面中数据和页面本身（只包含视图名称即可）。</p>\n<p>返回<code>ModelAndView</code>之后，会交给<code>ViewResolver</code>（视图解析器）进行处理，视图解析器会对整个视图页面进行解析，SpringMVC自带了一些视图解析器，但是只适用于JSP页面，我们也可以像之前一样使用Thymeleaf作为视图解析器，这样我们就可以根据给定的视图名称，直接读取HTML编写的页面，解析为一个真正的View。</p>\n<p>解析完成后，就需要将页面中的数据全部渲染到View中，最后返回给<code>DispatcherServlet</code>一个包含所有数据的成形页面，再响应给浏览器，完成整个过程。</p>\n<p>因此，实际上整个过程我们只需要编写对应请求路径的的Controller以及配置好我们需要的ViewResolver即可，之后还可以继续补充添加拦截器，而其他的流程已经由SpringMVC帮助我们完成了。</p>\n<h3 id=\"配置视图解析器和控制器\"><a href=\"#配置视图解析器和控制器\" class=\"headerlink\" title=\"配置视图解析器和控制器\"></a>配置视图解析器和控制器</h3><p>首先我们需要实现最基本的页面解析并返回，第一步就是配置视图解析器，这里我们使用Thymeleaf为我们提供的视图解析器，导入需要的依赖：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.0.12.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>配置视图解析器非常简单，我们只需要将对应的<code>ViewResolver</code>注册为Bean即可，这里我们直接在配置类中编写：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ComponentScan(&quot;com.example.controller&quot;)\n@Configuration\n@EnableWebMvc\npublic class WebConfiguration &#123;\n\n  &#x2F;&#x2F;我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面\n    @Bean\n    public ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)&#123;\n        ThymeleafViewResolver resolver &#x3D; new ThymeleafViewResolver();\n        resolver.setOrder(1);   &#x2F;&#x2F;可以存在多个视图解析器，并且可以为他们设定解析顺序\n        resolver.setCharacterEncoding(&quot;UTF-8&quot;);   &#x2F;&#x2F;编码格式是重中之重\n        resolver.setTemplateEngine(springTemplateEngine);   &#x2F;&#x2F;和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎\n        return resolver;\n    &#125;\n  \n  \t&#x2F;&#x2F;配置模板解析器\n  \t@Bean\n    public SpringResourceTemplateResolver templateResolver()&#123;\n        SpringResourceTemplateResolver resolver &#x3D; new SpringResourceTemplateResolver();\n        resolver.setSuffix(&quot;.html&quot;);   &#x2F;&#x2F;需要解析的后缀名称\n        resolver.setPrefix(&quot;&#x2F;&quot;);   &#x2F;&#x2F;需要解析的HTML页面文件存放的位置\n        return resolver;\n    &#125;\n  \t\n  \t&#x2F;&#x2F;配置模板引擎Bean\n  \t@Bean\n    public SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver)&#123;\n        SpringTemplateEngine engine &#x3D; new SpringTemplateEngine();\n        engine.setTemplateResolver(resolver);   &#x2F;&#x2F;模板解析器，默认即可\n        return engine;\n    &#125;\n&#125;</code></pre>\n\n<p>别忘了在<code>Initializer</code>中添加此类作为配置：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n    return new Class[]&#123;MvcConfiguration.class&#125;;\n&#125;</code></pre>\n\n<p>现在我们就完成了视图解析器的配置，我们接着来创建一个Controller，创建Controller也非常简单，只需在一个类上添加一个<code>@Controller</code>注解即可，它会被Spring扫描并自动注册为Controller类型的Bean，然后我们只需要在类中编写方法用于处理对应地址的请求即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller   &#x2F;&#x2F;直接添加注解即可\npublic class MainController &#123;\n\n    @RequestMapping(&quot;&#x2F;index&quot;)   &#x2F;&#x2F;直接填写访问路径\n    public ModelAndView index()&#123;\n        return new ModelAndView(&quot;index&quot;);  &#x2F;&#x2F;返回ModelAndView对象，这里填入了视图的名称\n      \t&#x2F;&#x2F;返回后会经过视图解析器进行处理\n    &#125;\n&#125;</code></pre>\n\n<p>我们会发现，打开浏览器之后就可以直接访问我们的HTML页面了。</p>\n<p>而页面中的数据我们可以直接向Model进行提供：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index()&#123;\n    ModelAndView modelAndView &#x3D; new ModelAndView(&quot;index&quot;);\n    modelAndView.getModel().put(&quot;name&quot;, &quot;啊这&quot;);\n    return modelAndView;\n&#125;</code></pre>\n\n<p>这样Thymeleaf就能收到我们传递的数据进行解析：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;static&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    HelloWorld！\n    &lt;div th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>当然，如果仅仅是传递一个页面不需要任何的附加属性，我们可以直接返回View名称，SpringMVC会将其自动包装为ModelAndView对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>还可以单独添加一个Model作为形参进行设置，SpringMVC会自动帮助我们传递实例对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index(Model model)&#123;  &#x2F;&#x2F;这里不仅仅可以是Model，还可以是Map、ModelMap\n    model.addAttribute(&quot;name&quot;, &quot;yyds&quot;);\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>这么方便的写法，你就说你爱不爱吧，你爱不爱。</p>\n<p>注意，一定要保证视图名称下面出现横线并且按住Ctrl可以跳转，配置才是正确的（最新版IDEA）</p>\n<p>我们的页面中可能还会包含一些静态资源，比如js、css，因此这里我们还需要配置一下，让静态资源通过Tomcat提供的默认Servlet进行解析，我们需要让配置类实现一下<code>WebMvcConfigurer</code>接口，这样在Web应用程序启动时，会根据我们重写方法里面的内容进行进一步的配置：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n    configurer.enable();   &#x2F;&#x2F;开启默认的Servlet\n&#125;\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    registry.addResourceHandler(&quot;&#x2F;static&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;WEB-INF&#x2F;static&#x2F;&quot;);   \n  \t&#x2F;&#x2F;配置静态资源的访问路径\n&#125;</code></pre>\n\n<p>我们编写一下前端内容：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n      &lt;!-- 引用静态资源，这里使用Thymeleaf的网址链接表达式，Thymeleaf会自动添加web应用程序的名称到链接前面 --&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;test.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    HelloWorld！\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>创建<code>test.js</code>并编写如下内容：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">window.alert(&quot;欢迎来到GayHub全球最大同性交友网站&quot;)</code></pre>\n\n<p>最后访问页面，页面在加载时就会显示一个弹窗，这样我们就完成了最基本的页面配置。相比之前的方式，这样就简单很多了，直接避免了编写大量的Servlet来处理请求。</p>\n<h3 id=\"RequestMapping详解\"><a href=\"#RequestMapping详解\" class=\"headerlink\" title=\"@RequestMapping详解\"></a>@RequestMapping详解</h3><p>前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个<code>@RequestMapping</code>即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊<code>@RequestMapping</code>吧，注解定义如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Mapping\npublic @interface RequestMapping &#123;\n    String name() default &quot;&quot;;\n\n    @AliasFor(&quot;path&quot;)\n    String[] value() default &#123;&#125;;\n\n    @AliasFor(&quot;value&quot;)\n    String[] path() default &#123;&#125;;\n\n    RequestMethod[] method() default &#123;&#125;;\n\n    String[] params() default &#123;&#125;;\n\n    String[] headers() default &#123;&#125;;\n\n    String[] consumes() default &#123;&#125;;\n\n    String[] produces() default &#123;&#125;;\n&#125;</code></pre>\n\n<p>其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&#123;&quot;&#x2F;index&quot;, &quot;&#x2F;test&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>现在我们访问&#x2F;index或是&#x2F;test都会经过此方法进行处理。</p>\n<p>我们也可以直接将<code>@RequestMapping</code>添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\n@RequestMapping(&quot;&#x2F;yyds&quot;)\npublic class MainController &#123;\n\n    @RequestMapping(&#123;&quot;&#x2F;index&quot;, &quot;&#x2F;test&quot;&#125;)\n    public ModelAndView index()&#123;\n        return new ModelAndView(&quot;index&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>那么现在我们需要访问<code>/yyds/index</code>或是<code>/yyds/test</code>才可以得到此页面。我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。</p>\n<p>路径还支持使用通配符进行匹配：</p>\n<ul>\n<li>?：表示任意一个字符，比如<code>@RequestMapping(&quot;/index/x?&quot;)</code>可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb等等。</li>\n<li>*：表示任意0-n个字符，比如<code>@RequestMapping(&quot;/index/*&quot;)</code>可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds等。</li>\n<li>**：表示当前目录或基于当前目录的多级目录，比如<code>@RequestMapping(&quot;/index/**&quot;)</code>可以匹配&#x2F;index、&#x2F;index&#x2F;xxx等。</li>\n</ul>\n<p>我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.POST)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>现在我们如果直接使用浏览器访问此页面，会显示405方法不支持，因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。</p>\n<p>我们也可以使用衍生注解直接设定为指定类型的请求映射：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>这里使用了<code>@PostMapping</code>直接指定为POST请求类型的请求映射，同样的，还有<code>@GetMapping</code>可以直接指定为GET请求方式，这里就不一一列举了。</p>\n<p>我们可以使用<code>params</code>属性来指定请求必须携带哪些请求参数，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;username&quot;, &quot;password&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>比如这里我们要求请求中必须携带<code>username</code>和<code>password</code>属性，否则无法访问。它还支持表达式，比如我们可以这样编写：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;!username&quot;, &quot;password&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;username!&#x3D;test&quot;, &quot;password&#x3D;123&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>这样，请求参数username不允许为test，并且password必须为123，否则无法访问。</p>\n<p><code>header</code>属性用法与<code>params</code>一致，但是它要求的是请求头中需要携带什么内容，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, headers &#x3D; &quot;!Connection&quot;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>那么，如果请求头中携带了<code>Connection</code>属性，将无法访问。其他两个属性：</p>\n<ul>\n<li>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</li>\n<li>produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>\n</ul>\n<h3 id=\"RequestParam和-RequestHeader详解\"><a href=\"#RequestParam和-RequestHeader详解\" class=\"headerlink\" title=\"@RequestParam和@RequestHeader详解\"></a>@RequestParam和@RequestHeader详解</h3><p>我们接着来看，如何获取到请求中的参数。</p>\n<p>我们只需要为方法添加一个形式参数，并在形式参数前面添加<code>@RequestParam</code>注解即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(&quot;username&quot;) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>我们需要在<code>@RequestParam</code>中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加<code>@RequestParam</code>也能获取到参数值。</p>\n<p>一旦添加<code>@RequestParam</code>，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false, defaultValue &#x3D; &quot;伞兵一号&quot;) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>如果需要使用Servlet原本的一些类，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpServletRequest request)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+request.getParameterMap().keySet());\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>直接添加<code>HttpServletRequest</code>为形式参数即可，SpringMVC会自动传递该请求原本的<code>HttpServletRequest</code>对象，同理，我们也可以添加<code>HttpServletResponse</code>作为形式参数，甚至可以直接将HttpSession也作为参数传递：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpSession session)&#123;\n    System.out.println(session.getAttribute(&quot;test&quot;));\n    session.setAttribute(&quot;test&quot;, &quot;鸡你太美&quot;);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>我们还可以直接将请求参数传递给一个实体类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class User &#123;\n    String username;\n    String password;\n&#125;</code></pre>\n\n<p>注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(User user)&#123;\n    System.out.println(&quot;获取到cookie值为：&quot;+user);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p><code>@RequestHeader</code>与<code>@RequestParam</code>用法一致，不过它是用于获取请求头参数的，这里就不再演示了。</p>\n<h3 id=\"CookieValue和-SessionAttrbutie\"><a href=\"#CookieValue和-SessionAttrbutie\" class=\"headerlink\" title=\"@CookieValue和@SessionAttrbutie\"></a>@CookieValue和@SessionAttrbutie</h3><p>通过使用<code>@CookieValue</code>注解，我们也可以快速获取请求携带的Cookie信息：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpServletResponse response,\n                          @CookieValue(value &#x3D; &quot;test&quot;, required &#x3D; false) String test)&#123;\n    System.out.println(&quot;获取到cookie值为：&quot;+test);\n    response.addCookie(new Cookie(&quot;test&quot;, &quot;lbwnb&quot;));\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>同样的，Session也能使用注解快速获取：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@SessionAttribute(value &#x3D; &quot;test&quot;, required &#x3D; false) String test,\n                          HttpSession session)&#123;\n    session.setAttribute(&quot;test&quot;, &quot;xxxx&quot;);\n    System.out.println(test);\n    return new ModelAndView(&quot;index&quot;);\n&#125;</code></pre>\n\n<p>可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。</p>\n<h3 id=\"重定向和请求转发\"><a href=\"#重定向和请求转发\" class=\"headerlink\" title=\"重定向和请求转发\"></a>重定向和请求转发</h3><p>重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;redirect:home&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;home&quot;)\npublic String home()&#123;\n    return &quot;home&quot;;\n&#125;</code></pre>\n\n<p>通过添加<code>redirect:</code>前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用<code>forward:</code>前缀表示转发给其他请求映射：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;forward:home&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;home&quot;)\npublic String home()&#123;\n    return &quot;home&quot;;\n&#125;</code></pre>\n\n<p>使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。</p>\n<h3 id=\"Bean的Web作用域\"><a href=\"#Bean的Web作用域\" class=\"headerlink\" title=\"Bean的Web作用域\"></a>Bean的Web作用域</h3><p>在学习Spring时我们讲解了Bean的作用域，包括<code>singleton</code>和<code>prototype</code>，Bean分别会以单例和多例模式进行创建，而在SpringMVC中，它的作用域被继续细分：</p>\n<ul>\n<li>request：对于每次HTTP请求，使用request作用域定义的Bean都将产生一个新实例，请求结束后Bean也消失。</li>\n<li>session：对于每一个会话，使用session作用域定义的Bean都将产生一个新实例，会话过期后Bean也消失。</li>\n<li>global session：不常用，不做讲解。</li>\n</ul>\n<p>这里我们创建一个测试类来试试看：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestBean &#123;\n\n&#125;</code></pre>\n\n<p>接着将其注册为Bean，注意这里需要添加<code>@RequestScope</code>或是<code>@SessionScope</code>表示此Bean的Web作用域：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\n@RequestScope\npublic TestBean testBean()&#123;\n    return new TestBean();\n&#125;</code></pre>\n\n<p>接着我们将其自动注入到Controller中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class MainController &#123;\n\n    @Resource\n    TestBean bean;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\n    public ModelAndView index()&#123;\n        System.out.println(bean);\n        return new ModelAndView(&quot;index&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>我们发现，每次发起得到的Bean实例都不同，接着我们将其作用域修改为<code>@SessionScope</code>，这样作用域就上升到Session，只要清理浏览器的Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么Bean实例始终不变。</p>\n<p>实际上，它也是通过代理实现的，我们调用Bean中的方法会被转发到真正的Bean对象去执行。</p>\n<hr>\n<h2 id=\"RestFul风格\"><a href=\"#RestFul风格\" class=\"headerlink\" title=\"RestFul风格\"></a>RestFul风格</h2><p>中文释义为<strong>“表现层状态转换”</strong>（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST&#x2F;GET&#x2F;PUT&#x2F;DELETE），来执行相同请求地址的不同类型操作。</p>\n<p>因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：</p>\n<p><code>http://localhost:8080/mvc/index/123456</code></p>\n<p>我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&#x2F;&#123;str&#125;&quot;)\npublic String index(@PathVariable String str) &#123;\n    System.out.println(str);\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了<code>@PathVariable</code>注解的参数，或是由<code>@PathVariable</code>注解指定为占位符名称：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&#x2F;&#123;str&#125;&quot;)\npublic String index(@PathVariable(&quot;str&quot;) String text)&#123;\n    System.out.println(text);\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>如果没有配置正确，方法名称上会出现黄线。</p>\n<p>我们可以按照不同功能进行划分：</p>\n<ul>\n<li>POST <a href=\"http://localhost:8080/mvc/index\">http://localhost:8080/mvc/index</a>  -  添加用户信息，携带表单数据</li>\n<li>GET <a href=\"http://localhost:8080/mvc/index/%7Bid%7D\">http://localhost:8080/mvc/index/{id}</a>  -  获取用户信息，id直接放在请求路径中</li>\n<li>PUT <a href=\"http://localhost:8080/mvc/index\">http://localhost:8080/mvc/index</a>  -  修改用户信息，携带表单数据</li>\n<li>DELETE <a href=\"http://localhost:8080/mvc/index/%7Bid%7D\">http://localhost:8080/mvc/index/{id}</a>  -  删除用户信息，id直接放在请求路径中</li>\n</ul>\n<p>我们分别编写四个请求映射：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class MainController &#123;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)\n    public String get(@PathVariable(&quot;id&quot;) String text)&#123;\n        System.out.println(&quot;获取用户：&quot;+text);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.POST)\n    public String post(String username)&#123;\n        System.out.println(&quot;添加用户：&quot;+username);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.DELETE)\n    public String delete(@PathVariable(&quot;id&quot;) String text)&#123;\n        System.out.println(&quot;删除用户：&quot;+text);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.PUT)\n    public String put(String username)&#123;\n        System.out.println(&quot;修改用户：&quot;+username);\n        return &quot;index&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>这只是一种设计风格而已，各位小伙伴了解即可。</p>\n<hr>\n<h2 id=\"Interceptor拦截器\"><a href=\"#Interceptor拦截器\" class=\"headerlink\" title=\"Interceptor拦截器\"></a>Interceptor拦截器</h2><p>拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的拦截器才可以成功到达Servlet，而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理，它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F4685968-ca4e9021f653c954.png%3FimageMogr2%2Fauto-orient%2Fstrip%257CimageView2%2F2%2Fw%2F1240&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1642340637&t=70d3dd6b52ae01ac76c04d99e6bd95ed\" alt=\"点击查看源网页\"></p>\n<h3 id=\"创建拦截器\"><a href=\"#创建拦截器\" class=\"headerlink\" title=\"创建拦截器\"></a>创建拦截器</h3><p>创建一个拦截器我们需要实现一个<code>HandlerInterceptor</code>接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MainInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;我是处理之前！&quot;);\n        return true;   &#x2F;&#x2F;只有返回true才会继续，否则直接结束\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;我是处理之后！&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;我是完成之后！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>接着我们需要在配置类中进行注册：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    registry.addInterceptor(new MainInterceptor())\n      .addPathPatterns(&quot;&#x2F;**&quot;)    &#x2F;&#x2F;添加拦截器的匹配路径，只要匹配一律拦截\n      .excludePathPatterns(&quot;&#x2F;home&quot;);   &#x2F;&#x2F;拦截器不进行拦截的路径\n&#125;</code></pre>\n\n<p>现在我们在浏览器中访问index页面，拦截器已经生效。</p>\n<p>得到整理拦截器的执行顺序：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我是处理之前！</p>\n<p>我是处理！</p>\n<p>我是处理之后！</p>\n<p>我是完成之后！</p></blockquote>\n<p>也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次<code>afterCompletion</code>方法，其实整个过程与我们之前所认识的Filter类似，不过在处理前，我们只需要返回true或是false表示是否被拦截即可，而不是再去使用FilterChain进行向下传递。</p>\n<p>那么我们就来看看，如果处理前返回false，会怎么样：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我是处理之前！</p></blockquote>\n<p>通过结果发现一旦返回false，之后的所有流程全部取消，那么如果是在处理中发生异常了呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    System.out.println(&quot;我是处理！&quot;);\n    if(true) throw new RuntimeException(&quot;&quot;);\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>结果为：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我是处理之前！<br>我是处理！<br>我是完成之后！</p></blockquote>\n<p>我们发现如果处理过程中抛出异常，那么久不会执行处理后<code>postHandle</code>方法，但是会执行<code>afterCompletion</code>方法，我们可以在此方法中获取到抛出的异常。</p>\n<h3 id=\"多级拦截器\"><a href=\"#多级拦截器\" class=\"headerlink\" title=\"多级拦截器\"></a>多级拦截器</h3><p>前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SubInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是处理之前！&quot;);\n        return true;\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是处理之后！&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是完成之后！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p>注册二号拦截器：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n  \t&#x2F;&#x2F;一号拦截器\n    registry.addInterceptor(new MainInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(&quot;&#x2F;home&quot;);\n  \t&#x2F;&#x2F;二号拦截器\n    registry.addInterceptor(new SubInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);\n&#125;</code></pre>\n\n<p>注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一号拦截器：我是处理之前！<br>二号拦截器：我是处理之前！<br>我是处理！<br>二号拦截器：我是处理之后！<br>一号拦截器：我是处理之后！<br>二号拦截器：我是完成之后！<br>一号拦截器：我是完成之后！</p></blockquote>\n<p>和多级Filter相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法，而完成后是在所有的<code>postHandle</code>执行之后再同样的以倒序方式执行。</p>\n<p>那么如果这时一号拦截器在处理前就返回了false呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n    System.out.println(&quot;一号拦截器：我是处理之前！&quot;);\n    return false;\n&#125;</code></pre>\n\n<p>得到结果如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一号拦截器：我是处理之前！</p></blockquote>\n<p>我们发现，与单个拦截器的情况一样，一旦拦截器返回false，那么之后无论有无拦截器，都不再继续。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为SpringMVC为我们提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。</p>\n<p>我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ControllerAdvice\npublic class ErrorController &#123;\n\n    @ExceptionHandler(Exception.class)\n    public String error(Exception e, Model model)&#123;  &#x2F;&#x2F;可以直接添加形参来获取异常\n        e.printStackTrace();\n        model.addAttribute(&quot;e&quot;, e);\n        return &quot;500&quot;;\n    &#125;\n&#125;</code></pre>\n\n<p>接着我们编写一个专门显示异常的页面：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  500 - 服务器出现了一个内部错误QAQ\n  &lt;div th:text&#x3D;&quot;$&#123;e&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>接着修改：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    System.out.println(&quot;我是处理！&quot;);\n    if(true) throw new RuntimeException(&quot;您的氪金力度不足，无法访问！&quot;);\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。</p>\n<h2 id=\"JSON数据格式与AJAX请求\"><a href=\"#JSON数据格式与AJAX请求\" class=\"headerlink\" title=\"JSON数据格式与AJAX请求\"></a>JSON数据格式与AJAX请求</h2><p>JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。</p>\n<p>我们现在推崇的是前后端分离的开发模式，而不是所有的内容全部交给后端渲染再发送给浏览器，也就是说，整个Web页面的内容在一开始就编写完成了，而其中的数据由前端执行JS代码来向服务器动态获取，再到前端进行渲染（填充），这样可以大幅度减少后端的压力，并且后端只需要传输关键数据即可（在即将到来的SpringBoot阶段，我们将完全采用前后端分离的开发模式）</p>\n<h3 id=\"JSON数据格式\"><a href=\"#JSON数据格式\" class=\"headerlink\" title=\"JSON数据格式\"></a>JSON数据格式</h3><p>既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。因此JSON横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过JSON格式承载的。</p>\n<p>一个JSON格式的数据长这样，以学生对象为例：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;</code></pre>\n\n<p>多个学生可以以数组的形式表示：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">[&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;]</code></pre>\n\n<p>嵌套关系可以表示为：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;&quot;studentList&quot;: [&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;], &quot;count&quot;: 2&#125;</code></pre>\n\n<p>它直接包括了属性的名称和属性的值，与JavaScript的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个JS对象，我们可以直接在控制台窗口中测试：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let obj &#x3D; JSON.parse(&#39;&#123;&quot;studentList&quot;: [&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;], &quot;count&quot;: 2&#125;&#39;)\n&#x2F;&#x2F;将JSON格式字符串转换为JS对象\nobj.studentList[0].name   &#x2F;&#x2F;直接访问第一个学生的名称</code></pre>\n\n<p>我们也可以将JS对象转换为JSON字符串：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">JSON.stringify(obj)</code></pre>\n\n<p>我们后端就可以以JSON字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。</p>\n<p>那么后端如何快速创建一个JSON格式的数据呢？我们首先需要导入以下依赖：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.78&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>JSON解析框架有很多种，比较常用的是Jackson和FastJSON，这里我们使用阿里巴巴的FastJSON进行解析。</p>\n<p>首先要介绍的是JSONObject，它和Map的使用方法一样（实现了Map接口），比如我们向其中存放几个数据：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    JSONObject object &#x3D; new JSONObject();\n    object.put(&quot;name&quot;, &quot;杰哥&quot;);\n    object.put(&quot;age&quot;, 18);\n    System.out.println(object.toJSONString());   &#x2F;&#x2F;以JSON格式输出JSONObject字符串\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>最后我们得到的结果为：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;</code></pre>\n\n<p>实际上JSONObject就是对JSON数据的一种对象表示。同样的还有JSONArray，它表示一个数组，用法和List一样，数组中可以嵌套其他的JSONObject或是JSONArray：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    JSONObject object &#x3D; new JSONObject();\n    object.put(&quot;name&quot;, &quot;杰哥&quot;);\n    object.put(&quot;age&quot;, 18);\n    JSONArray array &#x3D; new JSONArray();\n    array.add(object);\n    System.out.println(array.toJSONString());\n    return &quot;index&quot;;\n&#125;</code></pre>\n\n<p>得到的结果为：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">[&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;]</code></pre>\n\n<p>当出现循环引用时，会按照以下语法来解析：<img src=\"https://img2018.cnblogs.com/blog/1758707/201908/1758707-20190814212141691-1998020800.png\" alt=\"img\"></p>\n<p>我们可以也直接创建一个实体类，将实体类转换为JSON格式的数据：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, produces &#x3D; &quot;application&#x2F;json&quot;)\n@ResponseBody\npublic String data()&#123;\n    Student student &#x3D; new Student();\n    student.setName(&quot;杰哥&quot;);\n    student.setAge(18);\n    return JSON.toJSONString(student);\n&#125;</code></pre>\n\n<p>这里我们修改了<code>produces</code>的值，将返回的内容类型设定为<code>application/json</code>，表示服务器端返回了一个JSON格式的数据（当然不设置也行，也能展示，这样是为了规范）然后我们在方法上添加一个<code>@ResponseBody</code>表示方法返回（也可以在类上添加<code>@RestController</code>表示此Controller默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。</p>\n<p>接着我们使用JSON工具类将其转换为JSON格式的字符串，打开浏览器，得到JSON格式数据。</p>\n<p>SpringMVC非常智能，我们可以直接返回一个对象类型，它会被自动转换为JSON字符串格式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;data&quot;, produces &#x3D; &quot;application&#x2F;json&quot;)\n@ResponseBody\npublic Student data()&#123;\n    Student student &#x3D; new Student();\n    student.setName(&quot;杰哥&quot;);\n    student.setAge(18);\n    return student;\n&#125;</code></pre>\n\n<p>注意需要在配置类中添加一下FastJSON转换器（默认只支持JackSon）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n    converters.add(new FastJsonHttpMessageConverter());\n&#125;</code></pre>\n\n<h3 id=\"AJAX请求\"><a href=\"#AJAX请求\" class=\"headerlink\" title=\"AJAX请求\"></a>AJAX请求</h3><p>前面我们讲解了如何向浏览器发送一个JSON格式的数据，那么我们现在来看看如何向服务器请求数据。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/09/ajax-yl.png\" alt=\"AJAX\"></p>\n<p>Ajax即<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML（异步JavaScript和XML），它的目标就是实现页面中的数据动态更新，而不是直接刷新整个页面，它是一个概念。</p>\n<p>它在JQuery框架中有实现，因此我们直接导入JQuery（JQuery极大地简化了JS的开发，封装了很多内容，感兴趣的可以了解一下）：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre>\n\n<p>接着我们就可以直接使用了，首先修改一下前端页面：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;test.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    你好，\n    &lt;span id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;span&gt;\n    您的年龄是：\n    &lt;span id&#x3D;&quot;age&quot;&gt;&lt;&#x2F;span&gt;\n    &lt;button onclick&#x3D;&quot;updateData()&quot;&gt;点我更新页面数据&lt;&#x2F;button&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>现在我们希望用户名称和年龄需要在我们点击按钮之后才会更新，我们接着来编写一下JS：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function updateData() &#123;\n    &#x2F;&#x2F;美元符.的方式来使用Ajax请求，这里使用的是get方式，第一个参数为请求的地址（注意需要带上Web应用程序名称），第二个参数为成功获取到数据的方法，data就是返回的数据内容\n  \t$.get(&quot;&#x2F;mvc&#x2F;data&quot;, function (data) &#123;   &#x2F;&#x2F;获取成功执行的方法\n        window.alert(&#39;接受到异步请求数据：&#39;+JSON.stringify(data))  &#x2F;&#x2F;弹窗展示数据\n        $(&quot;#username&quot;).text(data.name)   &#x2F;&#x2F;这里使用了JQuery提供的选择器，直接选择id为username的元素，更新数据\n        $(&quot;#age&quot;).text(data.age)\n    &#125;)\n&#125;</code></pre>\n\n<p>使用JQuery非常方便，我们直接通过JQuery的选择器就可以快速获取页面中的元素，注意这里获取的元素是被JQuery封装过的元素，需要使用JQuery提供的方法来进行操作。</p>\n<p>这样，我们就实现了从服务端获取数据并更新到页面中（实际上之前，我们在JavaWeb阶段使用XHR请求也演示过，不过当时是纯粹的数据）</p>\n<p>那么我们接着来看，如何向服务端发送一个JS对象数据并进行解析：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function submitData() &#123;\n    $.post(&quot;&#x2F;mvc&#x2F;submit&quot;, &#123;   &#x2F;&#x2F;这里使用POST方法发送请求\n        name: &quot;测试&quot;,     &#x2F;&#x2F;第二个参数是要传递的对象，会以表单数据的方式发送\n      \tage: 18   \n    &#125;, function (data) &#123;\n        window.alert(JSON.stringify(data))   &#x2F;&#x2F;发送成功执行的方法\n    &#125;)\n&#125;</code></pre>\n\n<p>服务器端只需要在请求参数位置添加一个对象接收即可（和前面是一样的，因为这里也是提交的表单数据）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;submit&quot;)\n@ResponseBody\npublic String submit(Student student)&#123;\n    System.out.println(&quot;接收到前端数据：&quot;+student);\n    return &quot;&#123;\\&quot;success\\&quot;: true&#125;&quot;;\n&#125;</code></pre>\n\n<p>我们也可以将js对象转换为JSON字符串的形式进行传输，这里需要使用ajax方法来处理：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function submitData() &#123;\n    $.ajax(&#123;   &#x2F;&#x2F;最基本的请求方式，需要自己设定一些参数\n        type: &#39;POST&#39;,   &#x2F;&#x2F;设定请求方法\n        url: &quot;&#x2F;mvc&#x2F;submit&quot;,   &#x2F;&#x2F;请求地址\n        data: JSON.stringify(&#123;name: &quot;测试&quot;, age: 18&#125;),  &#x2F;&#x2F;转换为JSON字符串进行发送\n        success: function (data) &#123;\n            window.alert(JSON.stringify(data))\n        &#125;,\n        contentType: &quot;application&#x2F;json&quot;  &#x2F;&#x2F;请求头Content-Type一定要设定为JSON格式\n    &#125;)\n&#125;</code></pre>\n\n<p>如果我们需要读取前端发送给我们的JSON格式数据，那么这个时候就需要添加<code>@RequestBody</code>注解：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(&quot;&#x2F;submit&quot;)\n@ResponseBody\npublic String submit(@RequestBody JSONObject object)&#123;\n    System.out.println(&quot;接收到前端数据：&quot;+object);\n    return &quot;&#123;\\&quot;success\\&quot;: true&#125;&quot;;\n&#125;</code></pre>\n\n<p>这样，我们就实现了前后端使用JSON字符串进行通信。</p>\n<h2 id=\"实现文件上传和下载\"><a href=\"#实现文件上传和下载\" class=\"headerlink\" title=\"实现文件上传和下载\"></a>实现文件上传和下载</h2><p>利用SpringMVC，我们可以很轻松地实现文件上传和下载，同样的，我们只需要配置一个Resolver：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean(&quot;multipartResolver&quot;)   &#x2F;&#x2F;注意这里Bean的名称是固定的，必须是multipartResolver\npublic CommonsMultipartResolver commonsMultipartResolver()&#123;\n    CommonsMultipartResolver resolver &#x3D; new CommonsMultipartResolver();\n    resolver.setMaxUploadSize(1024 * 1024 * 10);   &#x2F;&#x2F;最大10MB大小\n    resolver.setDefaultEncoding(&quot;UTF-8&quot;);   &#x2F;&#x2F;默认编码格式\n    return resolver;\n&#125;</code></pre>\n\n<p>接着我们直接编写Controller即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;upload&quot;, method &#x3D; RequestMethod.POST)\n@ResponseBody\npublic String upload(@RequestParam CommonsMultipartFile file) throws IOException &#123;\n    File fileObj &#x3D; new File(&quot;test.html&quot;);\n    file.transferTo(fileObj);\n    System.out.println(&quot;用户上传的文件已保存到：&quot;+fileObj.getAbsolutePath());\n    return &quot;文件上传成功！&quot;;\n&#125;</code></pre>\n\n<p>使用CommonsMultipartFile对象来接收用户上传的文件。它是基于Apache的Commons-fileupload框架实现的，我们还需要导入一个依赖：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>最后在前端添加一个文件的上传点：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;div&gt;\n    &lt;form action&#x3D;&quot;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&gt;\n        &lt;input type&#x3D;&quot;submit&quot;&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>这样，点击提交之后，文件就会上传到服务器了。</p>\n<p>下载其实和我们之前的写法大致一样，直接使用HttpServletResponse，并向输出流中传输数据即可。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;download&quot;, method &#x3D; RequestMethod.GET)\n@ResponseBody\npublic void download(HttpServletResponse response)&#123;\n    response.setContentType(&quot;multipart&#x2F;form-data&quot;);\n    try(OutputStream stream &#x3D; response.getOutputStream();\n        InputStream inputStream &#x3D; new FileInputStream(&quot;test.html&quot;))&#123;\n        IOUtils.copy(inputStream, stream);\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>在前端页面中添加一个下载点：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;a href&#x3D;&quot;download&quot; download&#x3D;&quot;test.html&quot;&gt;下载最新资源&lt;&#x2F;a&gt;</code></pre>\n\n<h2 id=\"解读DispatcherServlet源码\"><a href=\"#解读DispatcherServlet源码\" class=\"headerlink\" title=\"解读DispatcherServlet源码\"></a>解读DispatcherServlet源码</h2><p><strong>注意：</strong>本部分作为选学内容！</p>\n<p>到目前为止，关于SpringMVC的相关内容就学习得差不多了，但是我们在最后还是需要深入了解一下DispatcherServlet底层是如何进行调度的，因此，我们会从源码角度进行讲解。</p>\n<p>首先我们需要找到<code>DispatcherServlet</code>的最顶层<code>HttpServletBean</code>，在这里直接继承的<code>HttpServlet</code>，那么我们首先来看一下，它在初始化方法中做了什么：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void init() throws ServletException &#123;\n  \t&#x2F;&#x2F;读取配置参数，并进行配置\n    PropertyValues pvs &#x3D; new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);\n    if (!pvs.isEmpty()) &#123;\n        try &#123;\n            BeanWrapper bw &#x3D; PropertyAccessorFactory.forBeanPropertyAccess(this);\n            ResourceLoader resourceLoader &#x3D; new ServletContextResourceLoader(this.getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));\n            this.initBeanWrapper(bw);\n            bw.setPropertyValues(pvs, true);\n        &#125; catch (BeansException var4) &#123;\n            if (this.logger.isErrorEnabled()) &#123;\n                this.logger.error(&quot;Failed to set bean properties on servlet &#39;&quot; + this.getServletName() + &quot;&#39;&quot;, var4);\n            &#125;\n\n            throw var4;\n        &#125;\n    &#125;\n\t\t&#x2F;&#x2F;此初始化阶段由子类实现，\n    this.initServletBean();\n&#125;</code></pre>\n\n<p>我们接着来看<code>initServletBean()</code>方法是如何实现的，它是在子类<code>FrameworkServlet</code>中定义的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final void initServletBean() throws ServletException &#123;\n    this.getServletContext().log(&quot;Initializing Spring &quot; + this.getClass().getSimpleName() + &quot; &#39;&quot; + this.getServletName() + &quot;&#39;&quot;);\n    if (this.logger.isInfoEnabled()) &#123;\n        this.logger.info(&quot;Initializing Servlet &#39;&quot; + this.getServletName() + &quot;&#39;&quot;);\n    &#125;\n\n    long startTime &#x3D; System.currentTimeMillis();\n\n    try &#123;\n      \t&#x2F;&#x2F;注意：我们在一开始说了SpringMVC有两个容器，一个是Web容器一个是根容器\n      \t&#x2F;&#x2F;Web容器只负责Controller等表现层内容\n      \t&#x2F;&#x2F;根容器就是Spring容器，它负责Service、Dao等，并且它是Web容器的父容器。\n      \t&#x2F;&#x2F;初始化WebApplicationContext，这个阶段会为根容器和Web容器进行父子关系建立\n        this.webApplicationContext &#x3D; this.initWebApplicationContext();\n        this.initFrameworkServlet();\n    &#125; catch (RuntimeException | ServletException var4) &#123;\n      &#x2F;&#x2F;...以下内容全是打印日志\n&#125;</code></pre>\n\n<p><img src=\"https://images2018.cnblogs.com/blog/1290804/201712/1290804-20171209164442730-1374080285.png\" alt=\"img\"></p>\n<p>我们来看看<code>initWebApplicationContext</code>是如何进行初始化的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected WebApplicationContext initWebApplicationContext() &#123;\n  \t&#x2F;&#x2F;这里获取的是根容器，一般用于配置Service、数据源等\n    WebApplicationContext rootContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());\n    WebApplicationContext wac &#x3D; null;\n    if (this.webApplicationContext !&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果webApplicationContext在之前已经存在，则直接给到wac\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext)wac;\n            if (!cwac.isActive()) &#123;\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                  \t&#x2F;&#x2F;设定根容器为Web容器的父容器\n                    cwac.setParent(rootContext);\n                &#125;\n\n                this.configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n\n    if (wac &#x3D;&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果webApplicationContext是空，那么就从ServletContext找一下有没有初始化上下文\n        wac &#x3D; this.findWebApplicationContext();\n    &#125;\n\n    if (wac &#x3D;&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果还是找不到，直接创个新的，并直接将根容器作为父容器\n        wac &#x3D; this.createWebApplicationContext(rootContext);\n    &#125;\n\n    if (!this.refreshEventReceived) &#123;\n        synchronized(this.onRefreshMonitor) &#123;\n          \t&#x2F;&#x2F;此方法由DispatcherServlet实现\n            this.onRefresh(wac);\n        &#125;\n    &#125;\n\n    if (this.publishContext) &#123;\n        String attrName &#x3D; this.getServletContextAttributeName();\n      \t&#x2F;&#x2F;把Web容器丢进ServletContext\n        this.getServletContext().setAttribute(attrName, wac);\n    &#125;\n\n    return wac;\n&#125;</code></pre>\n\n<p>我们接着来看DispatcherServlet中实现的<code>onRefresh()</code>方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void onRefresh(ApplicationContext context) &#123;\n    initStrategies(context);\n&#125;\n    \nprotected void initStrategies(ApplicationContext context) &#123;\n  \t&#x2F;&#x2F;初始化各种解析器\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n  \t&#x2F;&#x2F;在容器中查找所有的HandlerMapping，放入集合中\n  \t&#x2F;&#x2F;HandlerMapping保存了所有的请求映射信息（Controller中定义的），它可以根据请求找到处理器Handler，但并不是简单的返回处理器，而是将处理器和拦截器封装，形成一个处理器执行链（类似于之前的Filter）\n    initHandlerMappings(context);\n  \t&#x2F;&#x2F;在容器中查找所有的HandlerAdapter，它用于处理请求并返回ModelAndView对象\n  \t&#x2F;&#x2F;默认有三种实现HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter\n  \t&#x2F;&#x2F;当HandlerMapping找到处理请求的Controller之后，会选择一个合适的HandlerAdapter处理请求\n  \t&#x2F;&#x2F;比如我们之前使用的是注解方式配置Controller，现在有一个请求携带了一个参数，那么HandlerAdapter会对请求的数据进行解析，并传入方法作为实参，最后根据方法的返回值将其封装为ModelAndView对象\n    initHandlerAdapters(context);\n  \t&#x2F;&#x2F;其他的内容\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n&#125;</code></pre>\n\n<p>DispatcherServlet初始化过程我们已经了解了，那么我们接着来看DispatcherServlet是如何进行调度的，首先我们的请求肯定会经过<code>HttpServlet</code>，然后其交给对应的doGet、doPost等方法进行处理，而在<code>FrameworkServlet</code>中，这些方法都被重写，并且使用<code>processRequest</code>来进行处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    this.processRequest(request, response);\n&#125;\n\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    this.processRequest(request, response);\n&#125;</code></pre>\n\n<p>我们来看看<code>processRequest</code>做了什么：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n  \t&#x2F;&#x2F;前期准备工作\n    long startTime &#x3D; System.currentTimeMillis();\n    Throwable failureCause &#x3D; null;\n    LocaleContext previousLocaleContext &#x3D; LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext &#x3D; this.buildLocaleContext(request);\n    RequestAttributes previousAttributes &#x3D; RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes &#x3D; this.buildRequestAttributes(request, response, previousAttributes);\n    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor());\n    this.initContextHolders(request, localeContext, requestAttributes);\n\n    try &#123;\n      \t&#x2F;&#x2F;重点在这里，这里进行了Service的执行，不过是在DispatcherServlet中定义的\n        this.doService(request, response);\n    &#125; catch (IOException | ServletException var16) &#123;\n        &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>请各位一定要耐心，这些大型框架的底层一般都是层层套娃，因为这样写起来层次会更加清晰，那么我们来看看<code>DispatcherServlet</code>中是如何实现的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n   &#x2F;&#x2F;...\n    try &#123;\n      \t&#x2F;&#x2F;重点在这里，这才是整个处理过程中最核心的部分\n        this.doDispatch(request, response);\n    &#125; finally &#123;\n        &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<p>终于找到最核心的部分了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n    HttpServletRequest processedRequest &#x3D; request;\n    HandlerExecutionChain mappedHandler &#x3D; null;\n    boolean multipartRequestParsed &#x3D; false;\n    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n\n    try &#123;\n        try &#123;\n            ModelAndView mv &#x3D; null;\n            Object dispatchException &#x3D; null;\n\n            try &#123;\n                processedRequest &#x3D; this.checkMultipart(request);\n                multipartRequestParsed &#x3D; processedRequest !&#x3D; request;\n              \t&#x2F;&#x2F;在HandlerMapping集合中寻找可以处理当前请求的HandlerMapping\n                mappedHandler &#x3D; this.getHandler(processedRequest);\n                if (mappedHandler &#x3D;&#x3D; null) &#123;\n                    this.noHandlerFound(processedRequest, response);\n                  \t&#x2F;&#x2F;找不到HandlerMapping则无法进行处理\n                    return;\n                &#125;\n\n              \t&#x2F;&#x2F;根据HandlerMapping提供的信息，找到可以处理的HandlerAdapter\n                HandlerAdapter ha &#x3D; this.getHandlerAdapter(mappedHandler.getHandler());\n                String method &#x3D; request.getMethod();\n                boolean isGet &#x3D; HttpMethod.GET.matches(method);\n                if (isGet || HttpMethod.HEAD.matches(method)) &#123;\n                    long lastModified &#x3D; ha.getLastModified(request, mappedHandler.getHandler());\n                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;\n                        return;\n                    &#125;\n                &#125;\n\n              \t&#x2F;&#x2F;执行所有拦截器的preHandle()方法\n                if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;\n                    return;\n                &#125;\n\n              \t&#x2F;&#x2F;使用HandlerAdapter进行处理（我们编写的请求映射方法在这个位置才真正地执行了）\n              \t&#x2F;&#x2F;HandlerAdapter会帮助我们将请求的数据进行处理，再来调用我们编写的请求映射方法\n              \t&#x2F;&#x2F;最后HandlerAdapter会将结果封装为ModelAndView返回给mv\n                mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n                if (asyncManager.isConcurrentHandlingStarted()) &#123;\n                    return;\n                &#125;\n\n                this.applyDefaultViewName(processedRequest, mv);\n              \t&#x2F;&#x2F;执行所有拦截器的postHandle()方法\n                mappedHandler.applyPostHandle(processedRequest, response, mv);\n            &#125; catch (Exception var20) &#123;\n                dispatchException &#x3D; var20;\n            &#125; catch (Throwable var21) &#123;\n                dispatchException &#x3D; new NestedServletException(&quot;Handler dispatch failed&quot;, var21);\n            &#125;\n\n          \t&#x2F;&#x2F;最后处理结果，对视图进行渲染等，如果抛出异常会出现错误页面\n            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);\n        &#125; catch (Exception var22) &#123;\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n        &#125; catch (Throwable var23) &#123;\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, var23));\n        &#125;\n\n    &#125; finally &#123;\n        if (asyncManager.isConcurrentHandlingStarted()) &#123;\n            if (mappedHandler !&#x3D; null) &#123;\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            &#125;\n        &#125; else if (multipartRequestParsed) &#123;\n            this.cleanupMultipart(processedRequest);\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>所以，根据以上源码分析得出最终的流程图：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1338162/201901/1338162-20190113192808388-307235311.png\" alt=\"img\"></p>\n<p>虽然完成本章学习后，我们已经基本能够基于Spring去重新编写一个更加高级的图书管理系统了，但是登陆验证复杂的问题依然没有解决，如果我们依然按照之前的方式编写登陆验证，显然太过简单，它仅仅只是一个登陆，但是没有任何的权限划分或是加密处理，我们需要更加高级的权限校验框架来帮助我们实现登陆操作，下一章，我们会详细讲解如何使用更加高级的SpringSecurity框架来进行权限验证，并在学习的过程中，重写我们的图书管理系统。</p>\n","text":" SpringMVC在前面学习完Spring框架技术之后，差不多会出现两批人：一批是听得云里雾里，依然不明白这个东西是干嘛的；还有一批就是差不多理解了核心思想，但是不知道这些东西该如何去发挥它的作用。在SpringMVC阶段，你就能逐渐够体会到Spring框架为我们带来的便捷之处...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":4,"path":"api/tags/JavaSSM笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringMVC\"><span class=\"toc-text\">SpringMVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVC%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">MVC理论基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%B9%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">配置环境并搭建项目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Controller%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">Controller控制器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">配置视图解析器和控制器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RequestMapping%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">@RequestMapping详解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RequestParam%E5%92%8C-RequestHeader%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">@RequestParam和@RequestHeader详解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CookieValue%E5%92%8C-SessionAttrbutie\"><span class=\"toc-text\">@CookieValue和@SessionAttrbutie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">重定向和请求转发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Bean%E7%9A%84Web%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">Bean的Web作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RestFul%E9%A3%8E%E6%A0%BC\"><span class=\"toc-text\">RestFul风格</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interceptor%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">Interceptor拦截器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">创建拦截器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%A7%E6%8B%A6%E6%88%AA%E5%99%A8\"><span class=\"toc-text\">多级拦截器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8EAJAX%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">JSON数据格式与AJAX请求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">JSON数据格式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AJAX%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">AJAX请求</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD\"><span class=\"toc-text\">实现文件上传和下载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E8%AF%BBDispatcherServlet%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">解读DispatcherServlet源码</span></a></li></ol></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaSSM笔记（三）","uid":"7706992de04d833db29722d37e1933b8","slug":"JavaSSM笔记（三）","date":"2022-03-05T16:22:50.343Z","updated":"2022-03-05T16:24:05.940Z","comments":true,"path":"api/articles/JavaSSM笔记（三）.json","keywords":null,"cover":[],"text":" SpringSecurity本章我们会一边讲解SpringSecurity框架，一边从头开始编写图书管理系统。 SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括： 认证 （用户登录） 授权 （此用户能够做哪些事情） 攻击防护 （防止...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":4,"path":"api/tags/JavaSSM笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaSSM笔记（一）","uid":"9c23c4d0502f19daa98fa35771fc4957","slug":"JavaSSM笔记（一）","date":"2022-03-05T16:22:39.785Z","updated":"2022-03-05T16:23:38.159Z","comments":true,"path":"api/articles/JavaSSM笔记（一）.json","keywords":null,"cover":[],"text":" 建议：对Java开发还不是很熟悉的同学，最好先花费半个月到一个月时间大量地去编写小项目，不推荐一口气学完，后面的内容相比前面的内容几乎是降维打击，一口气学完很容易忘记之前所学的基础知识，尤其是JavaSE阶段的内容。 Spring框架技术恭喜各位顺利进入到SSM（Spring+...","link":"","photos":[],"count_time":{"symbolsCount":"89k","symbolsTime":"1:21"},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":4,"path":"api/tags/JavaSSM笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}