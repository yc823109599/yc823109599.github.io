{"title":"JavaSE笔记（三）","uid":"3acd6dd0df5d1947dcaf1fc3fec39ce8","slug":"JavaSE笔记（三）","date":"2022-03-09T03:41:52.829Z","updated":"2022-03-09T05:26:12.222Z","comments":true,"path":"api/articles/JavaSE笔记（三）.json","keywords":null,"cover":null,"content":"<h1 id=\"Java异常机制\"><a href=\"#Java异常机制\" class=\"headerlink\" title=\"Java异常机制\"></a>Java异常机制</h1><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    test(1, 0);   &#x2F;&#x2F;当b为0的时候，还能正常运行吗？\n&#125;\n\nprivate static int test(int a, int b)&#123;\n    return a&#x2F;b;   &#x2F;&#x2F;没有任何的判断而是直接做计算\n&#125;\n\nException in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero\n\tat com.test.Application.test(Application.java:9)\n\tat com.test.Application.main(Application.java:5)</code></pre>\n\n<p>当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p>\n<h3 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h3><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自<code>RuntimeException</code>。</p>\n<h3 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h3><p>异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File file &#x3D; new File(&quot;my.txt&quot;);\nfile.createNewFile();   &#x2F;&#x2F;要调用此方法，首先需要处理异常</code></pre>\n\n<h2 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h2><p>错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[Integer.MAX_VALUE];   &#x2F;&#x2F;能创建如此之大的数组吗？</code></pre>\n\n<p>运行后得到以下内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit\n\tat com.test.Main.main(Main.java:14)</code></pre>\n\n<p>错误都继承自<code>Error</code>类，一般情况下，程序中只能处理异常，错误是很难进行处理的，<code>Error</code>和<code>Execption</code>都继承自<code>Throwable</code>类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[Integer.MAX_VALUE];\nSystem.out.println(&quot;lbwnb&quot;);  &#x2F;&#x2F;还能正常打印吗？</code></pre>\n\n<h2 id=\"异常的处理\"><a href=\"#异常的处理\" class=\"headerlink\" title=\"异常的处理\"></a>异常的处理</h2><p>当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[5];\narr[5] &#x3D; 1;  &#x2F;&#x2F;我们需要处理这种情况，保证后面的代码正常运行！\nSystem.out.println(&quot;lbwnb&quot;);</code></pre>\n\n<p>我们可以使用<code>try</code>和<code>catch</code>语句块来处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int[] arr &#x3D; new int[5];\ntry&#123;    &#x2F;&#x2F;在try块中运行代码\n     arr[5] &#x3D; 1;    &#x2F;&#x2F;当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象\n&#125;catch (ArrayIndexOutOfBoundsException e)&#123;   &#x2F;&#x2F;捕获的异常类型\n     System.out.println(&quot;程序运行出现异常！&quot;);  &#x2F;&#x2F;出现异常时执行\n&#125;\n&#x2F;&#x2F;后面的代码会正常运行\nSystem.out.println(&quot;lbwnb&quot;);</code></pre>\n\n<p>当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。</p>\n<p>我们可以通过使用<code>e.printStackTrace()</code>来打印栈追踪信息，定位我们的异常出现位置：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java.lang.ArrayIndexOutOfBoundsException: 5\n\tat com.test.Main.main(Main.java:7)    &#x2F;&#x2F;Main类的第7行出现问题\n程序运行出现异常！\nlbwnb</code></pre>\n\n<p>运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File file &#x3D; new File(&quot;my.txt&quot;);\ntry &#123;\n  file.createNewFile();\n&#125; catch (IOException e) &#123;  &#x2F;&#x2F;捕获声明的异常类型\n  e.printStackTrace();\n&#125;</code></pre>\n\n<p>可以捕获到类型不止是<code>Exception</code>的子类，只要是继承自<code>Throwalbe</code>的类，都能被捕获，也就是说，<code>Error</code>也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现<code>Error</code>应该从问题的根源去解决。</p>\n<h2 id=\"异常的抛出\"><a href=\"#异常的抛出\" class=\"headerlink\" title=\"异常的抛出\"></a>异常的抛出</h2><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n        try &#123;\n            test(1, 0);\n        &#125; catch (Exception e) &#123;   &#x2F;&#x2F;捕获方法中会出现的异常\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    private static int test(int a, int b) throws Exception &#123;  &#x2F;&#x2F;声明抛出的异常类型\n        if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);  &#x2F;&#x2F;创建异常对象并抛出异常\n        return a&#x2F;b;  &#x2F;&#x2F;抛出异常会终止代码运行\n    &#125;</code></pre>\n\n<p>通过<code>throw</code>关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。</p>\n<p>如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息）</p>\n<p>如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明<code>throws</code>来继续交给上一级处理。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;  &#x2F;&#x2F;出现异常就再往上抛，而不是在此方法内处理\n  test(1, 0);\n&#125;\n\nprivate static int test(int a, int b) throws Exception &#123;  &#x2F;&#x2F;声明抛出的异常类型\n  if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);  &#x2F;&#x2F;创建异常对象并抛出异常      \n  return a&#x2F;b;  \n&#125;</code></pre>\n\n<p>当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息）</p>\n<p>异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws Exception &#123;\n        try&#123;\n            test(1, 0);\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;外层&quot;);\n        &#125;\n    &#125;\n\n    private static int test(int a, int b)&#123;\n        try&#123;\n            if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;内层&quot;);\n            return 0;\n        &#125;\n        return a&#x2F;b;\n    &#125;</code></pre>\n\n<h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><p>JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyException extends Exception &#123;  &#x2F;&#x2F;直接继承即可\n    \n&#125;\n\npublic static void main(String[] args) throws MyException &#123;\n        throw new MyException();   &#x2F;&#x2F;直接使用\n    &#125;</code></pre>\n\n<p>也可以使用父类的带描述的构造方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyException extends Exception &#123;\n\n    public MyException(String message)&#123;\n        super(message);\n    &#125;\n&#125;\n\npublic static void main(String[] args) throws MyException &#123;\n    throw new MyException(&quot;出现了自定义的错误&quot;);\n&#125;</code></pre>\n\n<p>捕获异常指定的类型，会捕获其所有子异常类型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n  throw new MyException(&quot;出现了自定义的错误&quot;);\n&#125; catch (Exception e) &#123;    &#x2F;&#x2F;捕获父异常类型\n  System.out.println(&quot;捕获到异常&quot;);\n&#125;</code></pre>\n\n<h2 id=\"多重异常捕获和finally关键字\"><a href=\"#多重异常捕获和finally关键字\" class=\"headerlink\" title=\"多重异常捕获和finally关键字\"></a>多重异常捕获和finally关键字</h2><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n  &#x2F;&#x2F;....\n&#125; catch (NullPointerException e) &#123;\n            \n&#125; catch (IndexOutOfBoundsException e)&#123;\n\n&#125; catch (RuntimeException e)&#123;\n            \n&#125;</code></pre>\n\n<p>注意，类似于<code>if-else if</code>的结构，父异常类型只能放在最后！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n  &#x2F;&#x2F;....\n&#125; catch (RuntimeException e)&#123;  &#x2F;&#x2F;父类型在前，会将子类的也捕获\n\n&#125; catch (NullPointerException e) &#123;   &#x2F;&#x2F;永远都不会被捕获\n\n&#125; catch (IndexOutOfBoundsException e)&#123;   &#x2F;&#x2F;永远都不会被捕获\n\n&#125;</code></pre>\n\n<p>如果希望把这些异常放在一起进行处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n     &#x2F;&#x2F;....\n&#125; catch (NullPointerException | IndexOutOfBoundsException e) &#123;  &#x2F;&#x2F;用|隔开每种类型即可\n\n&#125;</code></pre>\n\n<p>当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给<code>finally</code>语句块来处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n    &#x2F;&#x2F;....\n&#125;catch (Exception e)&#123;\n            \n&#125;finally &#123;\n  System.out.println(&quot;lbwnb&quot;);   &#x2F;&#x2F;无论是否出现异常，都会在最后执行\n&#125;</code></pre>\n\n<p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try &#123;\n    int a &#x3D; 10;\n    a &#x2F;&#x3D; 0;\n&#125;finally &#123;  &#x2F;&#x2F;不捕获异常，程序会终止，但在最后依然会执行下面的内容\n    System.out.println(&quot;lbwnb&quot;); \n&#125;</code></pre>\n\n<p>思考：<code>try</code>、<code>catch</code>和<code>finally</code>执行顺序：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int test(int a)&#123;\n  try&#123;\n    return a;\n  &#125;catch (Exception e)&#123;\n    return 0;\n  &#125;finally &#123;\n    a &#x3D;  a + 1;\n  &#125;\n&#125;</code></pre>\n\n<h1 id=\"Java泛型与集合类\"><a href=\"#Java泛型与集合类\" class=\"headerlink\" title=\"Java泛型与集合类\"></a>Java泛型与集合类</h1><h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h2 id=\"利用代码块来快速添加内容\"><a href=\"#利用代码块来快速添加内容\" class=\"headerlink\" title=\"利用代码块来快速添加内容\"></a>利用代码块来快速添加内容</h2><h1 id=\"Java-BIO\"><a href=\"#Java-BIO\" class=\"headerlink\" title=\"Java BIO\"></a>Java BIO</h1><h2 id=\"try-with-resourse\"><a href=\"#try-with-resourse\" class=\"headerlink\" title=\"try-with-resourse\"></a>try-with-resourse</h2><h1 id=\"Java-多线程\"><a href=\"#Java-多线程\" class=\"headerlink\" title=\"Java 多线程\"></a>Java 多线程</h1><h1 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h1><h2 id=\"详谈类加载机制\"><a href=\"#详谈类加载机制\" class=\"headerlink\" title=\"详谈类加载机制\"></a>详谈类加载机制</h2><h1 id=\"Java注解\"><a href=\"#Java注解\" class=\"headerlink\" title=\"Java注解\"></a>Java注解</h1>","text":"Java异常机制在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？ public static void ...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Java异常机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">运行时异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">编译时异常</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常的处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA\"><span class=\"toc-text\">异常的抛出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">自定义异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%92%8Cfinally%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">多重异常捕获和finally关键字</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">Java泛型与集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9D%A5%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">利用代码块来快速添加内容</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-BIO\"><span class=\"toc-text\">Java BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#try-with-resourse\"><span class=\"toc-text\">try-with-resourse</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">Java 多线程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">Java反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%A6%E8%B0%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">详谈类加载机制</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">Java注解</span></a></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaSE笔记（四）","uid":"57463bbf531fd357a773ee081e3f2258","slug":"JavaSE笔记（四）","date":"2022-03-09T03:41:58.359Z","updated":"2022-03-09T05:26:21.391Z","comments":true,"path":"api/articles/JavaSE笔记（四）.json","keywords":null,"cover":[],"text":"Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 走进泛型为了统计学生成绩，要求设计...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaSE笔记（二）","uid":"c02ca665cd1f72f1b198d0583b891337","slug":"JavaSE笔记（二）","date":"2022-03-09T03:41:48.987Z","updated":"2022-03-09T05:26:00.939Z","comments":true,"path":"api/articles/JavaSE笔记（二）.json","keywords":null,"cover":[],"text":"Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming) 对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"JavaSSM笔记","slug":"JavaSSM笔记","count":11,"path":"api/categories/JavaSSM笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}