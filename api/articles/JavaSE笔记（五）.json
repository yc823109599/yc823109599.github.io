{"title":"JavaSE笔记（五）","uid":"3d7015538194631f51f4f8a71af09913","slug":"JavaSE笔记（五）","date":"2022-03-09T03:42:02.632Z","updated":"2022-03-09T06:43:42.302Z","comments":true,"path":"api/articles/JavaSE笔记（五）.json","keywords":null,"cover":[],"content":"<h1 id=\"Java-I-x2F-O\"><a href=\"#Java-I-x2F-O\" class=\"headerlink\" title=\"Java I&#x2F;O\"></a>Java I&#x2F;O</h1><p><strong>注意：</strong>这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p>\n<p>I&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I&#x2F;O设备。</p>\n<p>我们可以大致看一下整个计算机的总线结构：</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1896043%2F202005%2F1896043-20200507143508957-1866569205.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637387700&t=e6a5ade66f8e4af2ac64d12e6dd77dec\" alt=\"img\"></p>\n<p>常见的I&#x2F;O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p>\n<p>而我们在程序中，想要读取这些外部连接的I&#x2F;O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows&#x2F;Linux&#x2F;MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取&#x2F;写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p>\n<p>JDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO，</p>\n<p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p>\n<h3 id=\"文件字节流\"><a href=\"#文件字节流\" class=\"headerlink\" title=\"文件字节流\"></a>文件字节流</h3><p>首先介绍一下FileInputStream，通过它来获取文件的输入流。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try &#123;\n        FileInputStream inputStream &#x3D; new FileInputStream(&quot;路径&quot;);\n        &#x2F;&#x2F;路径支持相对路径和绝对路径\n    &#125; catch (FileNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\\\</code>，但是不能写为<code>\\</code>因为它是转义字符！</p>\n<p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    FileInputStream inputStream &#x3D; null;    &#x2F;&#x2F;定义可以先放在try外部\n    try &#123;\n        inputStream &#x3D; new FileInputStream(&quot;路径&quot;);\n    &#125; catch (FileNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;    &#x2F;&#x2F;建议在finally中进行，因为这个是任何情况都必须要执行的！\n            if(inputStream !&#x3D; null) inputStream.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n\n    &#x2F;&#x2F;注意，这种语法只支持实现了AutoCloseable接口的类！\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;路径&quot;)) &#123;   &#x2F;&#x2F;直接在try()中定义要在完成之后释放的资源\n\n    &#125; catch (IOException e) &#123;   &#x2F;&#x2F;这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的\n        e.printStackTrace();\n    &#125;\n    &#x2F;&#x2F;无需再编写finally语句块，因为在最后自动帮我们调用了close()\n&#125;</code></pre>\n\n<p>之后为了方便，我们都使用此语法进行教学。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：a\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        &#x2F;&#x2F;使用read()方法进行字符读取\n        System.out.println((char) inputStream.read());  &#x2F;&#x2F;读取一个字节的数据（英文字母只占1字节，中文占2字节）\n        System.out.println(inputStream.read());   &#x2F;&#x2F;唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        int tmp;\n        while ((tmp &#x3D; inputStream.read()) !&#x3D; -1)&#123;   &#x2F;&#x2F;通过while循环来一次性读完内容\n            System.out.println((char)tmp);\n        &#125;\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I&#x2F;O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n    System.out.println(inputStream.available());  &#x2F;&#x2F;查看剩余数量\n&#125;catch (IOException e)&#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        byte[] bytes &#x3D; new byte[inputStream.available()];   &#x2F;&#x2F;我们可以提前准备好合适容量的byte数组来存放\n        System.out.println(inputStream.read(bytes));   &#x2F;&#x2F;一次性读取全部内容（返回值是读取的字节数）\n        System.out.println(new String(bytes));   &#x2F;&#x2F;通过String(byte[])构造方法得到字符串\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>也可以控制要读取数量：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">System.out.println(inputStream.read(bytes, 1, 2));   &#x2F;&#x2F;第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</code></pre>\n\n<p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p>\n<p>通过<code>skip()</code>方法可以跳过指定数量的字节：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        System.out.println(inputStream.skip(1));\n        System.out.println((char) inputStream.read());   &#x2F;&#x2F;跳过了一个字节\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p>\n<p>既然有输入流，那么文件输出流也是必不可少的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;输出流也需要在最后调用close()方法，并且同样支持try-with-resource\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;)) &#123;\n        &#x2F;&#x2F;注意：若此文件不存在，会直接创建这个文件！\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;)) &#123;\n        outputStream.write(&#39;c&#39;);   &#x2F;&#x2F;同read一样，可以直接写入内容\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes());   &#x2F;&#x2F;也可以直接写入byte[]\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes(), 0, 1);  &#x2F;&#x2F;同上输入流\n      \toutputStream.flush();  &#x2F;&#x2F;建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;, true)) &#123;\n        outputStream.write(&quot;lb&quot;.getBytes());   &#x2F;&#x2F;现在只会进行追加写入，而不是直接替换原文件内容\n        outputStream.flush();\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;);\n        FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;   &#x2F;&#x2F;可以写入多个\n        byte[] bytes &#x3D; new byte[10];    &#x2F;&#x2F;使用长度为10的byte[]做传输媒介\n        int tmp;   &#x2F;&#x2F;存储本地读取字节数\n        while ((tmp &#x3D; inputStream.read(bytes)) !&#x3D; -1)&#123;   &#x2F;&#x2F;直到读取完成为止\n            outputStream.write(bytes, 0, tmp);    &#x2F;&#x2F;写入对应长度的数据到输出流\n        &#125;\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"文件字符流\"><a href=\"#文件字符流\" class=\"headerlink\" title=\"文件字符流\"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileReader reader &#x3D; new FileReader(&quot;test.txt&quot;))&#123;\n      \treader.skip(1);   &#x2F;&#x2F;现在跳过的是一个字符\n        System.out.println((char) reader.read());   &#x2F;&#x2F;现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>同理，字符流只支持<code>char[]</code>类型作为存储：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileReader reader &#x3D; new FileReader(&quot;test.txt&quot;))&#123;\n        char[] str &#x3D; new char[10];\n        reader.read(str);\n        System.out.println(str);   &#x2F;&#x2F;直接读取到char[]中\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>既然有了Reader肯定也有Writer：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(FileWriter writer &#x3D; new FileWriter(&quot;output.txt&quot;))&#123;\n      \twriter.getEncoding();   &#x2F;&#x2F;支持获取编码（不同的文本文件可能会有不同的编码类型）\n       writer.write(&#39;牛&#39;);\n       writer.append(&#39;牛&#39;);   &#x2F;&#x2F;其实功能和write一样\n      \twriter.flush();   &#x2F;&#x2F;刷新\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Appends the specified character to this writer.\n *\n * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;&#x2F;tt&gt;\n * behaves in exactly the same way as the invocation\n *\n * &lt;pre&gt;\n *     out.write(c) &lt;&#x2F;pre&gt;\n *\n * @param  c\n *         The 16-bit character to append\n *\n * @return  This writer\n *\n * @throws  IOException\n *          If an I&#x2F;O error occurs\n *\n * @since 1.5\n *&#x2F;\npublic Writer append(char c) throws IOException &#123;\n    write(c);\n    return this;\n&#125;</code></pre>\n\n<p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p>\n<p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件</p>\n<h3 id=\"File类\"><a href=\"#File类\" class=\"headerlink\" title=\"File类\"></a>File类</h3><p>File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    File file &#x3D; new File(&quot;test.txt&quot;);   &#x2F;&#x2F;直接创建文件对象，可以是相对路径，也可以是绝对路径\n    System.out.println(file.exists());   &#x2F;&#x2F;此文件是否存在\n    System.out.println(file.length());   &#x2F;&#x2F;获取文件的大小\n    System.out.println(file.isDirectory());   &#x2F;&#x2F;是否为一个文件夹\n    System.out.println(file.canRead());   &#x2F;&#x2F;是否可读\n    System.out.println(file.canWrite());   &#x2F;&#x2F;是否可写\n    System.out.println(file.canExecute());   &#x2F;&#x2F;是否可执行\n&#125;</code></pre>\n\n<p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File file &#x3D; new File(&quot;&#x2F;&quot;);\nSystem.out.println(Arrays.toString(file.list()));   &#x2F;&#x2F;快速获取文件夹下的文件名称列表\nfor (File f : file.listFiles())&#123;   &#x2F;&#x2F;所有子文件的File对象\n    System.out.println(f.getAbsolutePath());   &#x2F;&#x2F;获取文件的绝对路径\n&#125;</code></pre>\n\n<p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File file &#x3D; new File(&quot;test.txt&quot;);\ntry (FileInputStream inputStream &#x3D; new FileInputStream(file))&#123;   &#x2F;&#x2F;直接做参数\n    System.out.println(inputStream.available());\n&#125;catch (IOException e)&#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p>\n<hr>\n<h2 id=\"缓冲流\"><a href=\"#缓冲流\" class=\"headerlink\" title=\"缓冲流\"></a>缓冲流</h2><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I&#x2F;O设备去获取数据，由于外部I&#x2F;O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.wityx.com%2Fimage%2F201908%2F480873DBD936EBA9518F721ACDC22BFE.png&refer=http%3A%2F%2Fwww.wityx.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637457276&t=b4f7d52f08d9d5815baca0b21a01f925\" alt=\"img\"></p>\n<h3 id=\"缓冲字节流\"><a href=\"#缓冲字节流\" class=\"headerlink\" title=\"缓冲字节流\"></a>缓冲字节流</h3><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;   &#x2F;&#x2F;传入FileInputStream\n        System.out.println((char) bufferedInputStream.read());   &#x2F;&#x2F;操作和原来的流是一样的\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>实际上进行I&#x2F;O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void close() throws IOException &#123;\n    byte[] buffer;\n    while ( (buffer &#x3D; buf) !&#x3D; null) &#123;\n        if (bufUpdater.compareAndSet(this, buffer, null)) &#123;  &#x2F;&#x2F;CAS无锁算法，并发会用到，暂时不管\n            InputStream input &#x3D; in;\n            in &#x3D; null;\n            if (input !&#x3D; null)\n                input.close();\n            return;\n        &#125;\n        &#x2F;&#x2F; Else retry in case a new buf was CASed in fill()\n    &#125;\n&#125;</code></pre>\n\n<p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p>\n<p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * The internal buffer array where the data is stored. When necessary,\n * it may be replaced by another array of\n * a different size.\n *&#x2F;\nprotected volatile byte buf[];</code></pre>\n\n<p>I&#x2F;O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Marks the current position in this input stream. A subsequent\n * call to the &lt;code&gt;reset&lt;&#x2F;code&gt; method repositions this stream at\n * the last marked position so that subsequent reads re-read the same bytes.\n * &lt;p&gt;\n * The &lt;code&gt;readlimit&lt;&#x2F;code&gt; argument tells this input stream to\n * allow that many bytes to be read before the mark position gets\n * invalidated.\n * &lt;p&gt;\n * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;&#x2F;code&gt;.\n *\n * @param   readlimit   the maximum limit of bytes that can be read before\n *                      the mark position becomes invalid.\n * @see     java.io.FilterInputStream#in\n * @see     java.io.FilterInputStream#reset()\n *&#x2F;\npublic synchronized void mark(int readlimit) &#123;\n    in.mark(readlimit);\n&#125;</code></pre>\n\n<p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;\n        bufferedInputStream.mark(1);   &#x2F;&#x2F;只保留之后的1个字符\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n        bufferedInputStream.reset();   &#x2F;&#x2F;回到mark时的位置\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;), 1))&#123;  &#x2F;&#x2F;将缓冲区大小设置为1\n        bufferedInputStream.mark(1);   &#x2F;&#x2F;只保留之后的1个字符\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());   &#x2F;&#x2F;已经超过了readlimit，继续读取会导致mark失效\n        bufferedInputStream.reset();   &#x2F;&#x2F;mark已经失效，无法reset()\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedOutputStream outputStream &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;\n        outputStream.write(&quot;lbwnb&quot;.getBytes());\n        outputStream.flush();\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>操作和FileOutputStream一致，这里就不多做介绍了。</p>\n<h3 id=\"缓冲字符流\"><a href=\"#缓冲字符流\" class=\"headerlink\" title=\"缓冲字符流\"></a>缓冲字符流</h3><p>缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>使用和reader也是一样的，内部也包含一个缓存数组：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private char cb[];</code></pre>\n\n<p>相比Reader更方便的是，它支持按行读取：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        System.out.println(reader.readLine());   &#x2F;&#x2F;按行读取\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        reader\n                .lines()\n                .limit(2)\n                .distinct()\n                .sorted()\n                .forEach(System.out::println);\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        reader.mark(1);\n        System.out.println((char) reader.read());\n        reader.reset();\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (BufferedWriter reader &#x3D; new BufferedWriter(new FileWriter(&quot;output.txt&quot;)))&#123;\n        reader.newLine();   &#x2F;&#x2F;使用newLine进行换行\n        reader.write(&quot;汉堡做滴彳亍不彳亍&quot;);   &#x2F;&#x2F;可以直接写入一个字符串\n      \treader.flush();   &#x2F;&#x2F;清空缓冲区\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"转换流\"><a href=\"#转换流\" class=\"headerlink\" title=\"转换流\"></a>转换流</h2><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(OutputStreamWriter writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;test.txt&quot;)))&#123;  &#x2F;&#x2F;虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入\n        writer.write(&quot;lbwnb&quot;);   &#x2F;&#x2F;以操作Writer的样子写入OutputStream\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(InputStreamReader reader &#x3D; new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)))&#123;  &#x2F;&#x2F;虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p>\n<hr>\n<h2 id=\"打印流\"><a href=\"#打印流\" class=\"headerlink\" title=\"打印流\"></a>打印流</h2><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final static PrintStream out &#x3D; null;</code></pre>\n\n<p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(PrintStream stream &#x3D; new PrintStream(new FileOutputStream(&quot;test.txt&quot;)))&#123;\n        stream.println(&quot;lbwnb&quot;);   &#x2F;&#x2F;其实System.out就是一个PrintStream\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p>\n<p><img src=\"https://img-blog.csdn.net/20180906143936647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGkxMzg5Nzc0MTU1NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<p>因此实际上内部还包含这两个内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Track both the text- and character-output streams, so that their buffers\n * can be flushed without flushing the entire stream.\n *&#x2F;\nprivate BufferedWriter textOut;\nprivate OutputStreamWriter charOut;</code></pre>\n\n<p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p>\n<hr>\n<h2 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h2><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (DataInputStream dataInputStream &#x3D; new DataInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;\n        System.out.println(dataInputStream.readBoolean());   &#x2F;&#x2F;直接将数据读取为任意基本数据类型\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>用于写入基本数据类型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (DataOutputStream dataOutputStream &#x3D; new DataOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;\n        dataOutputStream.writeBoolean(false);\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p>\n<h2 id=\"对象流\"><a href=\"#对象流\" class=\"headerlink\" title=\"对象流\"></a>对象流</h2><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));\n         ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;\n        People people &#x3D; new People(&quot;lbw&quot;);\n        outputStream.writeObject(people);\n      \toutputStream.flush();\n        people &#x3D; (People) inputStream.readObject();\n        System.out.println(people.name);\n    &#125;catch (IOException | ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nstatic class People implements Serializable&#123;   &#x2F;&#x2F;必须实现Serializable接口才能被序列化\n    String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static class People implements Serializable&#123;\n    private static final long serialVersionUID &#x3D; 123456;   &#x2F;&#x2F;在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。\n\n    String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<p>当发生版本不匹配时，会无法反序列化为对象：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID &#x3D; 123456, local class serialVersionUID &#x3D; 1234567\n\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)\n\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:503)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:461)\n\tat com.test.Main.main(Main.java:27)</code></pre>\n\n<p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try (ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));\n         ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;\n        People people &#x3D; new People(&quot;lbw&quot;);\n        outputStream.writeObject(people);\n        outputStream.flush();\n        people &#x3D; (People) inputStream.readObject();\n        System.out.println(people.name);  &#x2F;&#x2F;虽然能得到对象，但是name属性并没有保存，因此为null\n    &#125;catch (IOException | ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nstatic class People implements Serializable&#123;\n    private static final long serialVersionUID &#x3D; 1234567;\n\n    transient String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;</code></pre>\n\n<p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p>\n<hr>\n<h2 id=\"Java-I-x2F-O编程实战\"><a href=\"#Java-I-x2F-O编程实战\" class=\"headerlink\" title=\"Java I&#x2F;O编程实战\"></a>Java I&#x2F;O编程实战</h2><h3 id=\"图书管理系统\"><a href=\"#图书管理系统\" class=\"headerlink\" title=\"图书管理系统\"></a>图书管理系统</h3><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>\n","text":"Java I&#x2F;O注意：这块会涉及到操作系统和计算机组成原理相关内容。 I&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/categories/JavaSE笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-I-x2F-O\"><span class=\"toc-text\">Java I&#x2F;O</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%B5%81\"><span class=\"toc-text\">文件流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">文件字节流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">文件字符流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#File%E7%B1%BB\"><span class=\"toc-text\">File类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">缓冲流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">缓冲字节流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">缓冲字符流</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">转换流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%8D%B0%E6%B5%81\"><span class=\"toc-text\">打印流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">数据流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E6%B5%81\"><span class=\"toc-text\">对象流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java-I-x2F-O%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">Java I&#x2F;O编程实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">图书管理系统</span></a></li></ol></li></ol></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaSE笔记（六）","uid":"546513fbd12f522410dcfae3c5802bbd","slug":"JavaSE笔记（六）","date":"2022-03-09T03:42:06.895Z","updated":"2022-03-09T06:43:31.817Z","comments":true,"path":"api/articles/JavaSE笔记（六）.json","keywords":null,"cover":[],"text":"Java多线程注意：本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/categories/JavaSE笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaSE笔记（四）","uid":"57463bbf531fd357a773ee081e3f2258","slug":"JavaSE笔记（四）","date":"2022-03-09T03:41:58.359Z","updated":"2022-03-09T06:43:39.623Z","comments":true,"path":"api/articles/JavaSE笔记（四）.json","keywords":null,"cover":[],"text":"Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 走进泛型为了统计学生成绩，要求设计...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/categories/JavaSE笔记.json"}],"tags":[{"name":"JavaSE笔记","slug":"JavaSE笔记","count":7,"path":"api/tags/JavaSE笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}