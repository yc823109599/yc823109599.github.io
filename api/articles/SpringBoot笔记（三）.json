{"title":"SpringBoot笔记（三）","uid":"25a60a06ed42cd757ab0410c2846114a","slug":"SpringBoot笔记（三）","date":"2022-03-05T14:38:57.839Z","updated":"2022-03-05T14:39:50.184Z","comments":true,"path":"api/articles/SpringBoot笔记（三）.json","keywords":null,"cover":[],"content":"<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-054d8ff6135b3638aca543eff7424f98_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644500043&t=72a4f8ecfca9ff5a2a0b3896edef4be7\" alt=\"点击查看源网页\"></p>\n<h1 id=\"Redis数据库\"><a href=\"#Redis数据库\" class=\"headerlink\" title=\"Redis数据库\"></a>Redis数据库</h1><p><strong>灵魂拷问：</strong>不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？</p>\n<p>在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。</p>\n<p>因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。</p>\n<h2 id=\"NoSQL概论\"><a href=\"#NoSQL概论\" class=\"headerlink\" title=\"NoSQL概论\"></a>NoSQL概论</h2><p>NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它：</p>\n<ul>\n<li>不保证关系数据的ACID特性</li>\n<li>并不遵循SQL标准</li>\n<li>消除数据之间关联性</li>\n</ul>\n<p>乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势：</p>\n<ul>\n<li>远超传统关系型数据库的性能</li>\n<li>非常易于扩展</li>\n<li>数据模型更加灵活</li>\n<li>高可用</li>\n</ul>\n<p>这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！</p>\n<p>NoSQL数据库分为以下几种：</p>\n<ul>\n<li><strong>键值存储数据库：</strong>所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。</li>\n<li><strong>列存储数据库：</strong>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。</li>\n<li><strong>文档型数据库：</strong>它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。</li>\n<li><strong>图形数据库：</strong>利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。</li>\n</ul>\n<p>其中我们要学习的Redis数据库，就是一个开源的<strong>键值存储数据库</strong>，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。</p>\n<p>实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。</p>\n<h2 id=\"Redis安装和部署\"><a href=\"#Redis安装和部署\" class=\"headerlink\" title=\"Redis安装和部署\"></a>Redis安装和部署</h2><p>我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找：</p>\n<ul>\n<li>官网地址：<a href=\"https://redis.io/\">https://redis.io</a></li>\n<li>GitHub Windows版本维护地址：<a href=\"https://github.com/tporadowski/redis/releases\">https://github.com/tporadowski/redis/releases</a></li>\n</ul>\n<hr>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过<code>insert</code>语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据）</p>\n<p>在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。</p>\n<p>我们可以通过<code>select</code>语句进行切换：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select 序号;</code></pre>\n\n<h3 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h3><p>我们来看看，如何向Redis数据库中添加数据：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">set &lt;key&gt; &lt;value&gt;\n-- 一次性多个\nmset [&lt;key&gt; &lt;value&gt;]...</code></pre>\n\n<p>所有存入的数据默认会以<strong>字符串</strong>的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw\nset user:info:用户ID:name lbw</code></pre>\n\n<p>我们可以通过键值获取存入的值：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">get &lt;key&gt;</code></pre>\n\n<p>你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">set &lt;key&gt; &lt;value&gt; EX 秒\nset &lt;key&gt; &lt;value&gt; PX 毫秒</code></pre>\n\n<p>当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">expire &lt;key&gt; 秒</code></pre>\n\n<p>通过下面的命令来查询某个键值对的过期时间还剩多少：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ttl &lt;key&gt;\n-- 毫秒显示\npttl &lt;key&gt;\n-- 转换为永久\npersist &lt;key&gt;</code></pre>\n\n<p>那么当我们想直接删除这个数据时呢？直接使用：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">del &lt;key&gt;...</code></pre>\n\n<p>删除命令可以同时拼接多个键值一起删除。</p>\n<p>当我们想要查看数据库中所有的键值时：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">keys *</code></pre>\n\n<p>也可以查询某个键是否存在：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">exists &lt;key&gt;...</code></pre>\n\n<p>还可以随机拿一个键：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">randomkey</code></pre>\n\n<p>我们可以将一个数据库中的内容移动到另一个数据库中：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">move &lt;key&gt; 数据库序号</code></pre>\n\n<p>修改一个键为另一个键：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">rename &lt;key&gt; &lt;新的名称&gt;\n-- 下面这个会检查新的名称是否已经存在\nrenamex &lt;key&gt; &lt;新的名称&gt;</code></pre>\n\n<p>如果存放的数据是一个数字，我们还可以对其进行自增自减操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 等价于a &#x3D; a + 1\nincr &lt;key&gt;\n-- 等价于a &#x3D; a + b\nincrby &lt;key&gt; b\n-- 等价于a &#x3D; a - 1\ndecr &lt;key&gt;</code></pre>\n\n<p>最后就是查看值的数据类型：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">type &lt;key&gt;</code></pre>\n\n<p>Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。</p>\n<h2 id=\"数据类型介绍\"><a href=\"#数据类型介绍\" class=\"headerlink\" title=\"数据类型介绍\"></a>数据类型介绍</h2><p>一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。</p>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">#Redis默认存String类似于这样：\nMap&lt;String, String&gt; hash &#x3D; new HashMap&lt;&gt;();\n#Redis存Hash类型的数据类似于这样：\nMap&lt;String, Map&lt;String, String&gt;&gt; hash &#x3D; new HashMap&lt;&gt;();</code></pre>\n\n<p>它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。</p>\n<p>我们可以像这样来添加一个Hash类型的数据：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hset &lt;key&gt; [&lt;字段&gt; &lt;值&gt;]...</code></pre>\n\n<p>我们可以直接获取：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hget &lt;key&gt; &lt;字段&gt;\n-- 如果想要一次性获取所有的字段和值\nhgetall &lt;key&gt;</code></pre>\n\n<p>同样的，我们也可以判断某个字段是否存在：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hexists &lt;key&gt; &lt;字段&gt;</code></pre>\n\n<p>删除Hash中的某个字段：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hdel &lt;key&gt;</code></pre>\n\n<p>我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个<code>h</code>，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。</p>\n<p>我们现在想要知道Hash中一共存了多少个键值对：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hlen &lt;key&gt;</code></pre>\n\n<p>我们也可以一次性获取所有字段的值：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">hvals &lt;key&gt;</code></pre>\n\n<p>唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。</p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。</p>\n<p>我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 向列表头部添加元素\nlpush &lt;key&gt; &lt;element&gt;...\n-- 向列表尾部添加元素\nrpush &lt;key&gt; &lt;element&gt;...\n-- 在指定元素前面&#x2F;后面插入元素\nlinsert &lt;key&gt; before&#x2F;after &lt;指定元素&gt; &lt;element&gt;</code></pre>\n\n<p>同样的，获取元素也非常简单：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 根据下标获取元素\nlindex &lt;key&gt; &lt;下标&gt;\n-- 获取并移除头部元素\nlpop &lt;key&gt;\n-- 获取并移除尾部元素\nrpop &lt;key&gt;\n-- 获取指定范围内的\nlrange &lt;key&gt; start stop</code></pre>\n\n<p>注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）:</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 获取列表a中的全部元素\nlrange a 0 -1</code></pre>\n\n<p>没想到吧，push和pop还能连着用呢：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素\nrpoplpush 当前数组 目标数组</code></pre>\n\n<p>它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行\nblpop &lt;key&gt;... timeout</code></pre>\n\n<h3 id=\"Set和SortedSet\"><a href=\"#Set和SortedSet\" class=\"headerlink\" title=\"Set和SortedSet\"></a>Set和SortedSet</h3><p>Set集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。</p>\n<p>向Set中添加一个或多个值：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">sadd &lt;key&gt; &lt;value&gt;...</code></pre>\n\n<p>查看Set集合中有多少个值：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">scard &lt;key&gt;</code></pre>\n\n<p>判断集合中是否包含：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 是否包含指定值\nsismember &lt;key&gt; &lt;value&gt;\n-- 列出所有值\nsmembers &lt;key&gt;</code></pre>\n\n<p>集合之间的运算：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 集合之间的差集\nsdiff &lt;key1&gt; &lt;key2&gt;\n-- 集合之间的交集\nsinter &lt;key1&gt; &lt;key2&gt;\n-- 求并集\nsunion &lt;key1&gt; &lt;key2&gt;\n-- 将集合之间的差集存到目标集合中\nsdiffstore 目标 &lt;key1&gt; &lt;key2&gt;\n-- 同上\nsinterstore 目标 &lt;key1&gt; &lt;key2&gt;\n-- 同上\nsunionstore 目标 &lt;key1&gt; &lt;key2&gt;</code></pre>\n\n<p>移动指定值到另一个集合中：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">smove &lt;key&gt; 目标 value </code></pre>\n\n<p>移除操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 随机移除一个幸运儿\nspop &lt;key&gt;\n-- 移除指定\nsrem &lt;key&gt; &lt;value&gt;...</code></pre>\n\n<p>那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。</p>\n<p>我们可以添加一个带分数的值：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">zadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]...</code></pre>\n\n<p>同样的：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 查询有多少个值\nzcard &lt;key&gt;\n-- 移除\nzrem &lt;key&gt; &lt;value&gt;...\n-- 获取区间内的所有\nzrange &lt;key&gt; start stop</code></pre>\n\n<p>由于所有的值都有一个分数，我们也可以根据分数段来获取：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 通过分数段查看\nzrangebyscore &lt;key&gt; start stop [withscores] [limit]\n-- 统计分数段内的数量\nzcount &lt;key&gt;  start stop\n-- 根据分数获取指定值的排名\nzrank &lt;key&gt; &lt;value&gt;</code></pre>\n\n<p><a href=\"https://www.jianshu.com/p/32b9fe8c20e1\">https://www.jianshu.com/p/32b9fe8c20e1</a></p>\n<p>有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。</p>\n<hr>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。</p>\n<p>这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。</p>\n<p>持久化的实现方式有两种方案：一种是直接保存当前<strong>已经存储的数据</strong>，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的<strong>所有过程</strong>，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。</p>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><p>RDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">save\n-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存\nbgsave</code></pre>\n\n<p>执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">shutdown</code></pre>\n\n<p>重启后可以看到数据依然存在。</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqqe2.com%2Fjava%2Fzb_users%2Fupload%2F2020%2F04%2F202004281588086055367603.png&refer=http%3A%2F%2Fqqe2.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644843952&t=ec4cd6eb2c6d47a10aff5b9f264d2f16\" alt=\"点击查看图片来源\"></p>\n<p>虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。</p>\n<p>我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">save 300 10 # 300秒（5分钟）内有10个写入\nsave 60 10000 # 60秒（1分钟）内有10000个写入</code></pre>\n\n<p>配置的save使用的都是bgsave后台执行。</p>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><p>虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。</p>\n<p>而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。</p>\n<p><img src=\"https://qqe2.com/java/zb_users/upload/2020/04/202004281588086068660716.png\" alt=\"rdb和aof区别\"></p>\n<p>但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：</p>\n<ul>\n<li>always：每次执行写操作都会保存一次</li>\n<li>everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据</li>\n<li>no：看系统心情保存</li>\n</ul>\n<p>可以在配置文件中配置：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"># 注意得改成也是\nappendonly yes\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no</code></pre>\n\n<p>重启服务器后，可以看到服务器目录下多了一个<code>appendonly.aof</code>文件，存储的就是我们执行的命令。</p>\n<p> AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。</p>\n<p>Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lpush test 666\nlpush test 777\nlpush test 888</code></pre>\n\n<p>实际上用一条语句也可以实现：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lpush test 666 777 888</code></pre>\n\n<p>正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。</p>\n<p>我们可以输入命令来手动执行重写操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">bgrewriteaof</code></pre>\n\n<p>或是在配置文件中配置自动重写：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 百分比计算，这里不多介绍\nauto-aof-rewrite-percentage 100\n# 当达到这个大小时，触发自动重写\nauto-aof-rewrite-min-size 64mb</code></pre>\n\n<p>至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结：</p>\n<ul>\n<li>AOF：<ul>\n<li>优点：存储速度快、消耗资源少、支持实时存储</li>\n<li>缺点：加载速度慢、数据体积大</li>\n</ul>\n</li>\n<li>RDB：<ul>\n<li>优点：加载速度快、数据体积小</li>\n<li>缺点：存储速度慢大量消耗资源、会发生数据丢失</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"事务和锁机制\"><a href=\"#事务和锁机制\" class=\"headerlink\" title=\"事务和锁机制\"></a>事务和锁机制</h2><p>和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。</p>\n<p>我们可以使用命令来直接开启事务：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">multi</code></pre>\n\n<p>当我们输入完所有要执行的命令时，可以使用命令来立即执行事务：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">exec</code></pre>\n\n<p>我们也可以中途取消事务：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">discard</code></pre>\n\n<p>实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。</p>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</p>\n<p>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？</p>\n<ul>\n<li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。</li>\n<li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。</li>\n</ul>\n<p>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">watch</code></pre>\n\n<p>我们可以开两个客户端进行测试。</p>\n<p>取消监视可以使用：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">unwatch</code></pre>\n\n<p>至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。</p>\n<hr>\n<h2 id=\"使用Java与Redis交互\"><a href=\"#使用Java与Redis交互\" class=\"headerlink\" title=\"使用Java与Redis交互\"></a>使用Java与Redis交互</h2><p>既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？</p>\n<p>这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;</code></pre>\n\n<h3 id=\"基本操作-1\"><a href=\"#基本操作-1\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><p>我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;创建Jedis对象\n    Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;, 6379);\n  \t\n  \t&#x2F;&#x2F;使用之后关闭连接\n  \tjedis.close();\n&#125;</code></pre>\n\n<p>通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F;直接使用try-with-resouse，省去close\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.set(&quot;test&quot;, &quot;lbwnb&quot;);   &#x2F;&#x2F;等同于 set test lbwnb 命令\n        System.out.println(jedis.get(&quot;test&quot;));  &#x2F;&#x2F;等同于 get test 命令\n    &#125;\n&#125;</code></pre>\n\n<p>Hash类型的数据也是这样：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.hset(&quot;hhh&quot;, &quot;name&quot;, &quot;sxc&quot;);   &#x2F;&#x2F;等同于 hset hhh name sxc\n        jedis.hset(&quot;hhh&quot;, &quot;sex&quot;, &quot;19&quot;);    &#x2F;&#x2F;等同于 hset hhh age 19\n        jedis.hgetAll(&quot;hhh&quot;).forEach((k, v) -&gt; System.out.println(k+&quot;: &quot;+v));\n    &#125;\n&#125;</code></pre>\n\n<p>我们接着来看看列表操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.lpush(&quot;mylist&quot;, &quot;111&quot;, &quot;222&quot;, &quot;333&quot;);  &#x2F;&#x2F;等同于 lpush mylist 111 222 333 命令\n        jedis.lrange(&quot;mylist&quot;, 0, -1)\n                .forEach(System.out::println);    &#x2F;&#x2F;等同于 lrange mylist 0 -1\n    &#125;\n&#125;</code></pre>\n\n<p>实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。</p>\n<h3 id=\"SpringBoot整合Redis\"><a href=\"#SpringBoot整合Redis\" class=\"headerlink\" title=\"SpringBoot整合Redis\"></a>SpringBoot整合Redis</h3><p>我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  redis:\n  \t#Redis服务器地址\n    host: 192.168.10.3\n    #端口\n    port: 6379\n    #使用几号数据库\n    database: 0</code></pre>\n\n<p>starter已经给我们提供了两个默认的模板类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration(\n    proxyBeanMethods &#x3D; false\n)\n@ConditionalOnClass(&#123;RedisOperations.class&#125;)\n@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)\n@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)\npublic class RedisAutoConfiguration &#123;\n    public RedisAutoConfiguration() &#123;\n    &#125;\n\n    @Bean\n    @ConditionalOnMissingBean(\n        name &#x3D; &#123;&quot;redisTemplate&quot;&#125;\n    )\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n\n    @Bean\n    @ConditionalOnMissingBean\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        return new StringRedisTemplate(redisConnectionFactory);\n    &#125;\n&#125;</code></pre>\n\n<p>那么如何去使用这两个模板类呢？我们可以直接注入<code>StringRedisTemplate</code>来使用模板：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n    @Autowired\n    StringRedisTemplate template;\n\n    @Test\n    void contextLoads() &#123;\n        ValueOperations&lt;String, String&gt; operations &#x3D; template.opsForValue();\n        operations.set(&quot;c&quot;, &quot;xxxxx&quot;);   &#x2F;&#x2F;设置值\n        System.out.println(operations.get(&quot;c&quot;));   &#x2F;&#x2F;获取值\n      \t\n        template.delete(&quot;c&quot;);    &#x2F;&#x2F;删除键\n        System.out.println(template.hasKey(&quot;c&quot;));   &#x2F;&#x2F;判断是否包含键\n    &#125;\n\n&#125;</code></pre>\n\n<p>实际上所有的值的操作都被封装到了<code>ValueOperations</code>对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。</p>\n<p>我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class RedisService &#123;\n\n    @Resource\n    StringRedisTemplate template;\n\n    @PostConstruct\n    public void init()&#123;\n        template.setEnableTransactionSupport(true);   &#x2F;&#x2F;需要开启事务\n    &#125;\n\n    @Transactional    &#x2F;&#x2F;需要添加此注解\n    public void test()&#123;\n        template.multi();\n        template.opsForValue().set(&quot;d&quot;, &quot;xxxxx&quot;);\n        template.exec();\n    &#125;\n&#125;</code></pre>\n\n<p>我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\nvoid contextLoad2() &#123;\n    &#x2F;&#x2F;注意Student需要实现序列化接口才能存入Redis\n    template.opsForValue().set(&quot;student&quot;, new Student());\n    System.out.println(template.opsForValue().get(&quot;student&quot;));\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"使用Redis做缓存\"><a href=\"#使用Redis做缓存\" class=\"headerlink\" title=\"使用Redis做缓存\"></a>使用Redis做缓存</h2><p>我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。</p>\n<h3 id=\"Mybatis二级缓存\"><a href=\"#Mybatis二级缓存\" class=\"headerlink\" title=\"Mybatis二级缓存\"></a>Mybatis二级缓存</h3><p>还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5afd7713f9a97615dc3a0b1d3bc7db27.png\" alt=\"img\"></p>\n<p>我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;实现Mybatis的Cache接口\npublic class RedisMybatisCache implements Cache &#123;\n\n    private final String id;\n    private static RedisTemplate&lt;Object, Object&gt; template;\n\n   \t&#x2F;&#x2F;注意构造方法必须带一个String类型的参数接收id\n    public RedisMybatisCache(String id)&#123;\n        this.id &#x3D; id;\n    &#125;\n\n  \t&#x2F;&#x2F;初始化时通过配置类将RedisTemplate给过来\n    public static void setTemplate(RedisTemplate&lt;Object, Object&gt; template) &#123;\n        RedisMybatisCache.template &#x3D; template;\n    &#125;\n\n    @Override\n    public String getId() &#123;\n        return id;\n    &#125;\n\n    @Override\n    public void putObject(Object o, Object o1) &#123;\n      \t&#x2F;&#x2F;这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间\n        template.opsForValue().set(o, o1, 60, TimeUnit.SECONDS);\n    &#125;\n\n    @Override\n    public Object getObject(Object o) &#123;\n      \t&#x2F;&#x2F;这里根据Key直接从Redis数据库中获取值即可\n        return template.opsForValue().get(o);\n    &#125;\n\n    @Override\n    public Object removeObject(Object o) &#123;\n      \t&#x2F;&#x2F;根据Key删除\n        return template.delete(o);\n    &#125;\n\n    @Override\n    public void clear() &#123;\n      \t&#x2F;&#x2F;由于template中没封装清除操作，只能通过connection来执行\n\t\t\t\ttemplate.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;\n          \t&#x2F;&#x2F;通过connection对象执行清空操作\n            connection.flushDb();\n            return null;\n        &#125;);\n    &#125;\n\n    @Override\n    public int getSize() &#123;\n      \t&#x2F;&#x2F;这里也是使用connection对象来获取当前的Key数量\n        return template.execute(RedisServerCommands::dbSize).intValue();\n    &#125;\n&#125;</code></pre>\n\n<p>缓存类编写完成后，我们接着来编写配置类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MainConfiguration &#123;\n    @Resource\n    RedisTemplate&lt;Object, Object&gt; template;\n\n    @PostConstruct\n    public void init()&#123;\n      \t&#x2F;&#x2F;把RedisTemplate给到RedisMybatisCache\n        RedisMybatisCache.setTemplate(template);\n    &#125;\n&#125;</code></pre>\n\n<p>最后我们在Mapper上启用此缓存即可：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;只需要修改缓存实现类implementation为我们的RedisMybatisCache即可\n@CacheNamespace(implementation &#x3D; RedisMybatisCache.class)\n@Mapper\npublic interface MainMapper &#123;\n\n    @Select(&quot;select name from student where sid &#x3D; 1&quot;)\n    String getSid();\n&#125;</code></pre>\n\n<p>最后我们提供一个测试用例来查看当前的二级缓存是否生效：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n\n    @Resource\n    MainMapper mapper;\n\n    @Test\n    void contextLoads() &#123;\n        System.out.println(mapper.getSid());\n        System.out.println(mapper.getSid());\n        System.out.println(mapper.getSid());\n    &#125;\n\n&#125;</code></pre>\n\n<p>手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。</p>\n<h3 id=\"Token持久化存储\"><a href=\"#Token持久化存储\" class=\"headerlink\" title=\"Token持久化存储\"></a>Token持久化存储</h3><p>我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;实现PersistentTokenRepository接口\n@Component\npublic class RedisTokenRepository implements PersistentTokenRepository &#123;\n  \t&#x2F;&#x2F;Key名称前缀，用于区分\n    private final static String REMEMBER_ME_KEY &#x3D; &quot;spring:security:rememberMe:&quot;;\n    @Resource\n    RedisTemplate&lt;Object, Object&gt; template;\n\n    @Override\n    public void createNewToken(PersistentRememberMeToken token) &#123;\n      \t&#x2F;&#x2F;这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除\n        template.opsForValue().set(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), token.getSeries());\n        template.expire(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), 1, TimeUnit.DAYS);\n        this.setToken(token);\n    &#125;\n\n  \t&#x2F;&#x2F;先获取，然后修改创建一个新的，再放入\n    @Override\n    public void updateToken(String series, String tokenValue, Date lastUsed) &#123;\n        PersistentRememberMeToken token &#x3D; this.getToken(series);\n        if(token !&#x3D; null)\n           this.setToken(new PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed));\n    &#125;\n\n    @Override\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) &#123;\n        return this.getToken(seriesId);\n    &#125;\n\n  \t&#x2F;&#x2F;通过username找seriesId直接删除这两个\n    @Override\n    public void removeUserTokens(String username) &#123;\n        String series &#x3D; (String) template.opsForValue().get(REMEMBER_ME_KEY+&quot;username:&quot;+username);\n        template.delete(REMEMBER_ME_KEY+series);\n        template.delete(REMEMBER_ME_KEY+&quot;username:&quot;+username);\n    &#125;\n\n  \n  \t&#x2F;&#x2F;由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作\n    private PersistentRememberMeToken getToken(String series)&#123;\n        Map&lt;Object, Object&gt; map &#x3D; template.opsForHash().entries(REMEMBER_ME_KEY+series);\n        if(map.isEmpty()) return null;\n        return new PersistentRememberMeToken(\n                (String) map.get(&quot;username&quot;),\n                (String) map.get(&quot;series&quot;),\n                (String) map.get(&quot;tokenValue&quot;),\n                new Date(Long.parseLong((String) map.get(&quot;date&quot;))));\n    &#125;\n\n    private void setToken(PersistentRememberMeToken token)&#123;\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;username&quot;, token.getUsername());\n        map.put(&quot;series&quot;, token.getSeries());\n        map.put(&quot;tokenValue&quot;, token.getTokenValue());\n        map.put(&quot;date&quot;, &quot;&quot;+token.getDate().getTime());\n        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);\n        template.expire(REMEMBER_ME_KEY+token.getSeries(), 1, TimeUnit.DAYS);\n    &#125;\n&#125;</code></pre>\n\n<p>接着把验证Service实现了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class AuthService implements UserDetailsService &#123;\n\n    @Resource\n    UserMapper mapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        Account account &#x3D; mapper.getAccountByUsername(username);\n        if(account &#x3D;&#x3D; null) throw new UsernameNotFoundException(&quot;&quot;);\n        return User\n                .withUsername(username)\n                .password(account.getPassword())\n                .roles(account.getRole())\n                .build();\n    &#125;\n&#125;</code></pre>\n\n<p>Mapper也安排上：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic class Account implements Serializable &#123;\n    int id;\n    String username;\n    String password;\n    String role;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@CacheNamespace(implementation &#x3D; MybatisRedisCache.class)\n@Mapper\npublic interface UserMapper &#123;\n\n    @Select(&quot;select * from users where username &#x3D; #&#123;username&#125;&quot;)\n    Account getAccountByUsername(String username);\n&#125;</code></pre>\n\n<p>最后配置文件配一波：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            .authorizeRequests()\n            .anyRequest().authenticated()\n            .and()\n            .formLogin()\n            .and()\n            .rememberMe()\n            .tokenRepository(repository);\n&#125;\n\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth\n            .userDetailsService(service)\n            .passwordEncoder(new BCryptPasswordEncoder());\n&#125;</code></pre>\n\n<p>OK，启动服务器验证一下吧。</p>\n<hr>\n<h2 id=\"三大缓存问题\"><a href=\"#三大缓存问题\" class=\"headerlink\" title=\"三大缓存问题\"></a>三大缓存问题</h2><p><strong>注意：</strong>这部分内容作为选学内容。</p>\n<p>虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p><img src=\"https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1004.png?x-oss-process=style/shuiyin\" alt=\"img\"></p>\n<p>当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>\n<p>这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？</p>\n<p>这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的）</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201903%2F20190321142642446276.png&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644902390&t=4f0440b0357965ead1fa34fb27513927\" alt=\"点击查看图片来源\"></p>\n<p>使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。</p>\n<p>布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。</p>\n<p>接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。</p>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p><img src=\"https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1005.png?x-oss-process=style/shuiyin\" alt=\"img\"></p>\n<p>某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。</p>\n<p>这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p><img src=\"https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1006.png?x-oss-process=style/shuiyin\" alt=\"img\"></p>\n<p>当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。</p>\n<p>解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。</p>\n","text":" Redis数据库灵魂拷问：不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？ 在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"20 mins."},"categories":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/categories/SpringBoot笔记.json"}],"tags":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/tags/SpringBoot笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redis%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">Redis数据库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NoSQL%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\">NoSQL概论</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redis%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">Redis安装和部署</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">基本操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">数据操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">数据类型介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash\"><span class=\"toc-text\">Hash</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Set%E5%92%8CSortedSet\"><span class=\"toc-text\">Set和SortedSet</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RDB\"><span class=\"toc-text\">RDB</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AOF\"><span class=\"toc-text\">AOF</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">事务和锁机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%81\"><span class=\"toc-text\">锁</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Java%E4%B8%8ERedis%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">使用Java与Redis交互</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SpringBoot%E6%95%B4%E5%90%88Redis\"><span class=\"toc-text\">SpringBoot整合Redis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">使用Redis做缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Mybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">Mybatis二级缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Token%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">Token持久化存储</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">三大缓存问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">缓存穿透</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">缓存击穿</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">缓存雪崩</span></a></li></ol></li></ol></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot笔记（四）","uid":"1c189d12d9b261f21a36bc9b6f4c2deb","slug":"SpringBoot笔记（四）","date":"2022-03-05T14:39:01.865Z","updated":"2022-03-05T14:40:01.692Z","comments":true,"path":"api/articles/SpringBoot笔记（四）.json","keywords":null,"cover":[],"text":"SpringBoot其他框架通过了解其他的SpringBoot框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能。 邮件发送：Mail我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/categories/SpringBoot笔记.json"}],"tags":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/tags/SpringBoot笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"SpringBoot笔记（二）","uid":"8a03b6cf044356a33316079da4b482e4","slug":"SpringBoot笔记（二）","date":"2022-03-05T14:38:53.811Z","updated":"2022-03-05T14:39:43.063Z","comments":true,"path":"api/articles/SpringBoot笔记（二）.json","keywords":null,"cover":[],"text":"Git版本控制注意：开始学习之前，确保自己的网络可以畅通的连接Github：https://github.com，这个是一个国外网站，连起来特别卡，至于用什么方式实现流畅访问，懂的都懂。 其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/categories/SpringBoot笔记.json"}],"tags":[{"name":"SpringBoot笔记","slug":"SpringBoot笔记","count":5,"path":"api/tags/SpringBoot笔记.json"}],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}