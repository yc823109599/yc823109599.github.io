{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"JavaSE笔记（六）","date":"2022-03-09T03:42:06.895Z","updated":"2022-02-18T04:06:50.000Z","comments":true,"path":"api/articles/JavaSE笔记（六）.json","keywords":null,"cover":[],"content":"<h1 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h1><p><strong>注意：</strong>本章节会涉及到 <strong>操作系统</strong> 相关知识。</p>\n<p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p>\n<p><img src=\"https://img0.baidu.com/it/u=2613039280,4140201323&fm=26&fmt=auto\" alt=\"img\"></p>\n<p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhiphotos.baidu.com%2Fdoc%2Fpic%2Fitem%2Faec379310a55b3193e6caaf24aa98226cefc179b.jpg&refer=http%3A%2F%2Fhiphotos.baidu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637499744&t=1df3c2095bc9a8cbe8cd9d0974644b7c\" alt=\"img\"></p>\n<p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.51cto.com%2Fwyfs02%2FM00%2F84%2F3A%2FwKiom1eIqY7il2J7AAAyvcssSjs721.gif&refer=http%3A%2F%2Fs2.51cto.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637474421&t=aef9a39ea3a09d6d67e8d4b769036446\" alt=\"img\"></p>\n<p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p>\n<p>在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ThreadMXBean bean &#x3D; ManagementFactory.getThreadMXBean();\n    long[] ids &#x3D; bean.getAllThreadIds();\n    ThreadInfo[] infos &#x3D; bean.getThreadInfo(ids);\n    for (ThreadInfo info : infos) &#123;\n        System.out.println(info.getThreadName());\n    &#125;\n&#125;</code></pre>\n\n<p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p>\n<hr>\n<h2 id=\"线程的创建和启动\"><a href=\"#线程的创建和启动\" class=\"headerlink\" title=\"线程的创建和启动\"></a>线程的创建和启动</h2><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface Runnable &#123;\n    &#x2F;**\n     * When an object implementing interface &lt;code&gt;Runnable&lt;&#x2F;code&gt; is used\n     * to create a thread, starting the thread causes the object&#39;s\n     * &lt;code&gt;run&lt;&#x2F;code&gt; method to be called in that separately executing\n     * thread.\n     * &lt;p&gt;\n     * The general contract of the method &lt;code&gt;run&lt;&#x2F;code&gt; is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     *&#x2F;\n    public abstract void run();\n&#125;</code></pre>\n\n<p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;    &#x2F;&#x2F;直接编写逻辑\n        System.out.println(&quot;我是另一个线程！&quot;);\n    &#125;);\n    t.start();   &#x2F;&#x2F;调用此方法来开始执行此线程\n&#125;</code></pre>\n\n<p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;我是线程：&quot;+Thread.currentThread().getName());\n        System.out.println(&quot;我正在计算 0-10000 之间所有数的和...&quot;);\n        int sum &#x3D; 0;\n        for (int i &#x3D; 0; i &lt;&#x3D; 10000; i++) &#123;\n            sum +&#x3D; i;\n        &#125;\n        System.out.println(&quot;结果：&quot;+sum);\n    &#125;);\n    t.start();\n    System.out.println(&quot;我是主线程！&quot;);\n&#125;</code></pre>\n\n<p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;我是一号线程：&quot;+i);\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;我是二号线程：&quot;+i);\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;</code></pre>\n\n<p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p>\n<p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2019%2F09%2F3AfuQrV.png&refer=http%3A%2F%2Fwww.liuhaihua.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637477978&t=d986b270854b3d7c54f816f9103084bc\" alt=\"img\"></p>\n<p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    System.out.println(&quot;l&quot;);\n    Thread.sleep(1000);    &#x2F;&#x2F;休眠时间，以毫秒为单位，1000ms &#x3D; 1s\n    System.out.println(&quot;b&quot;);\n    Thread.sleep(1000);\n    System.out.println(&quot;w&quot;);\n    Thread.sleep(1000);\n    System.out.println(&quot;nb!&quot;);\n&#125;</code></pre>\n\n<p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        Thread me &#x3D; Thread.currentThread();   &#x2F;&#x2F;获取当前线程对象\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;打印:&quot;+i);\n            if(i &#x3D;&#x3D; 20) me.stop();  &#x2F;&#x2F;此方法会直接终止此线程\n        &#125;\n    &#125;);\n    t.start();\n&#125;</code></pre>\n\n<p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p>\n<p><strong>思考</strong>：猜猜以下程序输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;</code></pre>\n\n<p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p>\n<hr>\n<h2 id=\"线程的休眠和中断\"><a href=\"#线程的休眠和中断\" class=\"headerlink\" title=\"线程的休眠和中断\"></a>线程的休眠和中断</h2><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p>\n<ul>\n<li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li>\n<li>当线程进入休眠 &#x2F; 阻塞(如等待IO请求) &#x2F; 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li>\n<li>当线程出现异常或错误 &#x2F; 被<code>stop()</code> 方法强行停止 &#x2F; 所有代码执行结束时，会使得线程的运行终止。</li>\n</ul>\n<p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        try &#123;\n            System.out.println(&quot;l&quot;);\n            Thread.sleep(1000);   &#x2F;&#x2F;sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）\n            System.out.println(&quot;b&quot;);    &#x2F;&#x2F;调用sleep后，线程会直接进入到等待状态，直到时间结束\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;);\n    t.start();\n&#125;</code></pre>\n\n<p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        try &#123;\n            Thread.sleep(10000);  &#x2F;&#x2F;休眠10秒\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        while (true)&#123;   &#x2F;&#x2F;无限循环\n            if(Thread.currentThread().isInterrupted())&#123;   &#x2F;&#x2F;判断是否存在中断标志\n                break;   &#x2F;&#x2F;响应中断\n            &#125;\n        &#125;\n        System.out.println(&quot;线程被中断了！&quot;);\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        while (true)&#123;\n            if(Thread.currentThread().isInterrupted())&#123;   &#x2F;&#x2F;判断是否存在中断标志\n                System.out.println(&quot;发现中断信号，复位，继续运行...&quot;);\n                Thread.interrupted();  &#x2F;&#x2F;复位中断标记（返回值是当前是否有中断标记，这里不用管）\n            &#125;\n        &#125;\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        Thread.currentThread().suspend();   &#x2F;&#x2F;暂停此线程\n        System.out.println(&quot;线程继续运行！&quot;);\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.resume();   &#x2F;&#x2F;恢复此线程\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<p>虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。</p>\n<hr>\n<h2 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h2><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p>\n<ul>\n<li>MIN_PRIORITY   最低优先级</li>\n<li>MAX_PRIORITY   最高优先级</li>\n<li>NOM_PRIORITY  常规优先级</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n    &#125;);\n    t.start();\n    t.setPriority(Thread.MIN_PRIORITY);  &#x2F;&#x2F;通过使用setPriority方法来设定优先级\n&#125;</code></pre>\n\n<p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p>\n<h2 id=\"线程的礼让和加入\"><a href=\"#线程的礼让和加入\" class=\"headerlink\" title=\"线程的礼让和加入\"></a>线程的礼让和加入</h2><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程1开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            if(i % 5 &#x3D;&#x3D; 0) &#123;\n                System.out.println(&quot;让位！&quot;);\n                Thread.yield();\n            &#125;\n            System.out.println(&quot;1打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;</code></pre>\n\n<p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p>\n<p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程1开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;1打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n            if(i &#x3D;&#x3D; 10)&#123;\n                try &#123;\n                    System.out.println(&quot;线程1加入到此线程！&quot;);\n                    t1.join();    &#x2F;&#x2F;在i&#x3D;&#x3D;10时，让线程1加入，先完成线程1的内容，在继续当前内容\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;</code></pre>\n\n<p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(Thread.currentThread().getName()+&quot;开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n            if(i &#x3D;&#x3D; 10)&#123;\n                try &#123;\n                    System.out.println(&quot;线程1加入到此线程！&quot;);\n                    t1.join();    &#x2F;&#x2F;在i&#x3D;&#x3D;10时，让线程1加入，先完成线程1的内容，在继续当前内容\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;</code></pre>\n\n<p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p>\n<hr>\n<h2 id=\"线程锁和线程同步\"><a href=\"#线程锁和线程同步\" class=\"headerlink\" title=\"线程锁和线程同步\"></a>线程锁和线程同步</h2><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvlambda.com%2Fimg%3Furl%3Dhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2F2LlmEpiamhyq7hTfsoWa1GMIQlOtRuD8SScvIeB3KD7w4OoGu8wx13lBjMJLhYgYqTHND48X05m901TIEicGg49w%2F640%3Fwx_fmt%3Dpng&refer=http%3A%2F%2Fvlambda.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637562962&t=830ccc4dbe09f2699660bfcc9a292c63\" alt=\"img\"></p>\n<p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读&#x2F;写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多处理器高速缓存机制：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBb1fa2c9cd0784fb19f0d8ebeb8e00976?method=download&shareKey=8d48a5816e60b026adfa21e6735b5e31\" alt=\"img\"></p>\n<p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p>\n<p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p>\n<h3 id=\"悬念破案\"><a href=\"#悬念破案\" class=\"headerlink\" title=\"悬念破案\"></a>悬念破案</h3><p>我们再来回顾一下之前留给大家的悬念：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;</code></pre>\n\n<p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F3154ff892af3cb3373a3b6b82b501a1d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637565388&t=20091d33bae457edc36af7718ef1325b\" alt=\"img\"></p>\n<p>那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行）</p>\n<h3 id=\"线程锁\"><a href=\"#线程锁\" class=\"headerlink\" title=\"线程锁\"></a>线程锁</h3><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (Main.class)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (Main.class)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;</code></pre>\n\n<p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p>\n<p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法）</p>\n<p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Main main1 &#x3D; new Main();\n    Main main2 &#x3D; new Main();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (main1)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (main2)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;</code></pre>\n\n<p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p>\n<p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static int value &#x3D; 0;\n\nprivate static synchronized void add()&#123;\n    value++;\n&#125;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) add();\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) add();\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;</code></pre>\n\n<p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！</p>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9852c978350cc5e8641ba778619351bb_b.png&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637568214&t=7740dd98b8e1c4a3bfbd94a30e7f9ff8\" alt=\"img\"></p>\n<p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    Object o1 &#x3D; new Object();\n    Object o2 &#x3D; new Object();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            try &#123;\n                Thread.sleep(1000);\n                synchronized (o2)&#123;\n                    System.out.println(&quot;线程1&quot;);\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o2)&#123;\n            try &#123;\n                Thread.sleep(1000);\n                synchronized (o1)&#123;\n                    System.out.println(&quot;线程2&quot;);\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;</code></pre>\n\n<p>那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">nagocoler@NagodeMacBook-Pro ~ % jps\n51592 Launcher\n51690 Jps\n14955 \n51693 Main\nnagocoler@NagodeMacBook-Pro ~ % jstack 51693\n...\nJava stack information for the threads listed above:\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;Thread-1&quot;:\n\tat com.test.Main.lambda$main$1(Main.java:46)\n\t- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)\n\t- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)\n\tat com.test.Main$$Lambda$2&#x2F;1867750575.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n&quot;Thread-0&quot;:\n\tat com.test.Main.lambda$main$0(Main.java:34)\n\t- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)\n\t- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)\n\tat com.test.Main$$Lambda$1&#x2F;396873410.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n\nFound 1 deadlock.</code></pre>\n\n<p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。</p>\n<p>不推荐使用 <code>suspend() </code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p>\n<h3 id=\"wait和notify方法\"><a href=\"#wait和notify方法\" class=\"headerlink\" title=\"wait和notify方法\"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    Object o1 &#x3D; new Object();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            try &#123;\n                System.out.println(&quot;开始等待&quot;);\n                o1.wait();     &#x2F;&#x2F;进入等待状态并释放锁\n                System.out.println(&quot;等待结束！&quot;);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            System.out.println(&quot;开始唤醒！&quot;);\n            o1.notify();     &#x2F;&#x2F;唤醒处于等待状态的线程\n          \tfor (int i &#x3D; 0; i &lt; 50; i++) &#123;\n               \tSystem.out.println(i);   \n            &#125;\n          \t&#x2F;&#x2F;唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\n        &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t2.start();\n&#125;</code></pre>\n\n<p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p>\n<p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p>\n<h3 id=\"ThreadLocal的使用\"><a href=\"#ThreadLocal的使用\" class=\"headerlink\" title=\"ThreadLocal的使用\"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png\" alt=\"img\"></p>\n<p>我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();  &#x2F;&#x2F;注意这是一个泛型类，存储类型为我们要存放的变量类型\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;lbwnb&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;变量值已设定！&quot;);\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);    &#x2F;&#x2F;间隔三秒\n    t2.start();\n&#125;</code></pre>\n\n<p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();  &#x2F;&#x2F;注意这是一个泛型类，存储类型为我们要存放的变量类型\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;lbwnb&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;线程1变量值已设定！&quot;);\n        try &#123;\n            Thread.sleep(2000);    &#x2F;&#x2F;间隔2秒\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;线程1读取变量值：&quot;);\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;yyds&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;线程2变量值已设定！&quot;);\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);    &#x2F;&#x2F;间隔1秒\n    t2.start();\n&#125;</code></pre>\n\n<p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p>\n<p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n       local.set(&quot;lbwnb&quot;);\n        new Thread(() -&gt; &#123;\n            System.out.println(local.get());\n        &#125;).start();\n    &#125;);\n    t.start();\n&#125;</code></pre>\n\n<p>我们可以使用InheritableThreadLocal来解决：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new InheritableThreadLocal&lt;&gt;();\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n       local.set(&quot;lbwnb&quot;);\n        new Thread(() -&gt; &#123;\n            System.out.println(local.get());\n        &#125;).start();\n    &#125;);\n    t.start();\n&#125;</code></pre>\n\n<p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p>\n<hr>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    new TimerTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   &#x2F;&#x2F;创建并启动此定时任务\n&#125;\n\nstatic class TimerTask&#123;\n    Runnable task;\n    long time;\n\n    public TimerTask(Runnable runnable, long time)&#123;\n        this.task &#x3D; runnable;\n        this.time &#x3D; time;\n    &#125;\n\n    public void start()&#123;\n        new Thread(() -&gt; &#123;\n            try &#123;\n                Thread.sleep(time);\n                task.run();   &#x2F;&#x2F;休眠后再运行\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;</code></pre>\n\n<p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    new TimerLoopTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   &#x2F;&#x2F;创建并启动此定时任务\n&#125;\n\nstatic class TimerLoopTask&#123;\n    Runnable task;\n    long loopTime;\n\n    public TimerLoopTask(Runnable runnable, long loopTime)&#123;\n        this.task &#x3D; runnable;\n        this.loopTime &#x3D; loopTime;\n    &#125;\n\n    public void start()&#123;\n        new Thread(() -&gt; &#123;\n            try &#123;\n                while (true)&#123;   &#x2F;&#x2F;无限循环执行\n                    Thread.sleep(loopTime);\n                    task.run();   &#x2F;&#x2F;休眠后再运行\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;</code></pre>\n\n<p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p>\n<p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Timer timer &#x3D; new Timer();    &#x2F;&#x2F;创建定时器对象\n    timer.schedule(new TimerTask() &#123;   &#x2F;&#x2F;注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName());    &#x2F;&#x2F;打印当前线程名称\n        &#125;\n    &#125;, 1000);    &#x2F;&#x2F;执行一个延时任务\n&#125;</code></pre>\n\n<p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Timer &#123;\n    &#x2F;**\n     * The timer task queue.  This data structure is shared with the timer\n     * thread.  The timer produces tasks, via its various schedule calls,\n     * and the timer thread consumes, executing timer tasks as appropriate,\n     * and removing them from the queue when they&#39;re obsolete.\n     *&#x2F;\n    private final TaskQueue queue &#x3D; new TaskQueue();\n\n    &#x2F;**\n     * The timer thread.\n     *&#x2F;\n    private final TimerThread thread &#x3D; new TimerThread(queue);\n  \n\t\t...\n&#125;</code></pre>\n\n<p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Timer(String name) &#123;\n    thread.setName(name);\n    thread.start();\n&#125;</code></pre>\n\n<p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void run() &#123;\n    try &#123;\n        mainLoop();\n    &#125; finally &#123;\n        &#x2F;&#x2F; Someone killed this Thread, behave as if Timer cancelled\n        synchronized(queue) &#123;\n            newTasksMayBeScheduled &#x3D; false;\n            queue.clear();  &#x2F;&#x2F; Eliminate obsolete references\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;**\n * The main timer loop.  (See class comment.)\n *&#x2F;\nprivate void mainLoop() &#123;\n  try &#123;\n       TimerTask task;\n       boolean taskFired;\n       synchronized(queue) &#123;\n         \t&#x2F;&#x2F; Wait for queue to become non-empty\n          while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   &#x2F;&#x2F;当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。\n                queue.wait();\n          if (queue.isEmpty())\n             break;    &#x2F;&#x2F;当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程\n                      ...\n&#125;</code></pre>\n\n<p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void cancel() &#123;\n    synchronized(queue) &#123;\n        thread.newTasksMayBeScheduled &#x3D; false;\n        queue.clear();\n        queue.notify();  &#x2F;&#x2F;唤醒wait使得工作线程结束\n    &#125;\n&#125;</code></pre>\n\n<p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Timer timer &#x3D; new Timer();\n    timer.schedule(new TimerTask() &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName());\n            timer.cancel();  &#x2F;&#x2F;结束\n        &#125;\n    &#125;, 1000);\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h2><p>不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException&#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        while (true)&#123;\n            try &#123;\n                System.out.println(&quot;程序正常运行中...&quot;);\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    t.setDaemon(true);   &#x2F;&#x2F;设置为守护线程（必须在开始之前，中途是不允许转换的）\n    t.start();\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        Thread.sleep(1000);\n    &#125;\n&#125;</code></pre>\n\n<p>在守护线程中产生的新线程也是守护的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException&#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        Thread it &#x3D; new Thread(() -&gt; &#123;\n            while (true)&#123;\n                try &#123;\n                    System.out.println(&quot;程序正常运行中...&quot;);\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;);\n        it.start();\n    &#125;);\n    t.setDaemon(true);   &#x2F;&#x2F;设置为守护线程（必须在开始之前，中途是不允许转换的）\n    t.start();\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        Thread.sleep(1000);\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"再谈集合类并行方法\"><a href=\"#再谈集合类并行方法\" class=\"headerlink\" title=\"再谈集合类并行方法\"></a>再谈集合类并行方法</h2><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">default Stream&lt;E&gt; parallelStream() &#123;\n    return StreamSupport.stream(spliterator(), true);\n&#125;</code></pre>\n\n<p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));\n    list\n            .parallelStream()    &#x2F;&#x2F;获得并行流\n            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+i));\n&#125;</code></pre>\n\n<p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));\n    list\n            .parallelStream()    &#x2F;&#x2F;获得并行流\n            .forEachOrdered(System.out::println);\n&#125;</code></pre>\n\n<p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;;\n    Arrays.parallelSort(arr);   &#x2F;&#x2F;使用多线程进行并行排序，效率更高\n    System.out.println(Arrays.toString(arr));\n&#125;</code></pre>\n\n<p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;;\n    Arrays.parallelSetAll(arr, i -&gt; &#123;\n        System.out.println(Thread.currentThread().getName());\n        return arr[i];\n    &#125;);\n    System.out.println(Arrays.toString(arr));\n&#125;</code></pre>\n\n<p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p>\n<hr>\n<h2 id=\"Java多线程编程实战\"><a href=\"#Java多线程编程实战\" class=\"headerlink\" title=\"Java多线程编程实战\"></a>Java多线程编程实战</h2><p>这是整个教程最后一个编程实战内容了，下一章节为<code>反射</code>一般开发者使用比较少，属于选学内容，不编排编程实战课程。</p>\n<h3 id=\"生产者与消费者\"><a href=\"#生产者与消费者\" class=\"headerlink\" title=\"生产者与消费者\"></a>生产者与消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p>\n<p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p>\n","text":"Java多线程注意：本章节会涉及到 操作系统 相关知识。 在了解多线程之前，让我们回顾一下操作系统中提到的进程概念： 进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">Java多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">线程的创建和启动</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%E5%92%8C%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">线程的休眠和中断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">线程的优先级</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A4%BC%E8%AE%A9%E5%92%8C%E5%8A%A0%E5%85%A5\"><span class=\"toc-text\">线程的礼让和加入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%94%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">线程锁和线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%82%AC%E5%BF%B5%E7%A0%B4%E6%A1%88\"><span class=\"toc-text\">悬念破案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E9%94%81\"><span class=\"toc-text\">线程锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">死锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">wait和notify方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">ThreadLocal的使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">定时器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">守护线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%B0%88%E9%9B%86%E5%90%88%E7%B1%BB%E5%B9%B6%E8%A1%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">再谈集合类并行方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">Java多线程编程实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">生产者与消费者</span></a></li></ol></li></ol></li></ol>","author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"JavaSE笔记（七）","date":"2022-03-09T03:42:26.687Z","updated":"2022-02-18T04:06:56.000Z","comments":true,"path":"api/articles/JavaSE笔记（七）.json","keywords":null,"cover":[],"text":"Java反射和注解注意：本章节涉及到JVM相关底层原理，难度会有一些大。 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"JavaSE笔记（五）","date":"2022-03-09T03:42:02.632Z","updated":"2022-02-18T04:06:50.000Z","comments":true,"path":"api/articles/JavaSE笔记（五）.json","keywords":null,"cover":[],"text":"Java I&#x2F;O注意：这块会涉及到操作系统和计算机组成原理相关内容。 I&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[],"author":{"name":"YangChao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个不太懂开发的程序猿","socials":{"github":"https://github.com/yc823109599","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}