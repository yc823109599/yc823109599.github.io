[{"id":"a1aa3e42f0d68308fa7b7cefd9f5a9a0","title":"JavaSE笔记（七）","content":"Java反射和注解注意：本章节涉及到JVM相关底层原理，难度会有一些大。\n反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。\n简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！\nJava类加载机制在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：\n\n在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！\n思考：既然说和与加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，那么JVM会加载这个类吗？\npackage java.lang;\n\npublic class String &#123;    &#x2F;&#x2F;JDK提供的String类也是\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;我姓🐴，我叫🐴nb&quot;);\n    &#125;\n&#125;\n\n我们发现，会出现以下报错：\n错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)\n\n但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的双亲委派机制在保护Java程序的正常运行：\n\n实际上我们的类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到main方法了！\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Main.class.getClassLoader());   &#x2F;&#x2F;查看当前类的类加载器\n        System.out.println(Main.class.getClassLoader().getParent());  &#x2F;&#x2F;父加载器\n        System.out.println(Main.class.getClassLoader().getParent().getParent());  &#x2F;&#x2F;爷爷加载器\n        System.out.println(String.class.getClassLoader());   &#x2F;&#x2F;String类的加载器\n    &#125;\n&#125;\n\n由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。\nClass对象通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：\npublic static void main(String[] args) throws ClassNotFoundException &#123;\n    Class&lt;String&gt; clazz &#x3D; String.class;   &#x2F;&#x2F;使用class关键字，通过类名获取\n    Class&lt;?&gt; clazz2 &#x3D; Class.forName(&quot;java.lang.String&quot;);   &#x2F;&#x2F;使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;\n    Class&lt;?&gt; clazz3 &#x3D; new String(&quot;cpdd&quot;).getClass();  &#x2F;&#x2F;通过实例对象获取\n&#125;\n\n注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了?通配符作为返回值，但是实际上都和第一个返回的是同一个对象：\nClass&lt;String&gt; clazz &#x3D; String.class;   &#x2F;&#x2F;使用class关键字，通过类名获取\nClass&lt;?&gt; clazz2 &#x3D; Class.forName(&quot;java.lang.String&quot;);   &#x2F;&#x2F;使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;\nClass&lt;?&gt; clazz3 &#x3D; new String(&quot;cpdd&quot;).getClass();\n\nSystem.out.println(clazz &#x3D;&#x3D; clazz2);\nSystem.out.println(clazz &#x3D;&#x3D; clazz3);\n\n通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：\npublic static void main(String[] args) &#123;\n    Class&lt;?&gt; clazz &#x3D; int.class;   &#x2F;&#x2F;基本数据类型有Class对象吗？\n    System.out.println(clazz);\n&#125;\n\n迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：\n&#x2F;**\n * The &#123;@code Class&#125; instance representing the primitive type\n * &#123;@code int&#125;.\n *\n * @since   JDK1.1\n *&#x2F;\n@SuppressWarnings(&quot;unchecked&quot;)\npublic static final Class&lt;Integer&gt;  TYPE &#x3D; (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);\n\n&#x2F;*\n * Return the Virtual Machine&#39;s Class object for the named\n * primitive type\n *&#x2F;\nstatic native Class&lt;?&gt; getPrimitiveClass(String name);   &#x2F;&#x2F;C++实现，并非Java定义\n\n每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。\npublic static void main(String[] args) &#123;\n    Class&lt;?&gt; clazz &#x3D; int.class;\n    System.out.println(Integer.TYPE &#x3D;&#x3D; int.class);\n&#125;\n\n通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？\npublic static void main(String[] args) &#123;\n    System.out.println(Integer.TYPE &#x3D;&#x3D; Integer.class);\n&#125;\n\n我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：\npublic static void main(String[] args) &#123;\n    Class&lt;String[]&gt; clazz &#x3D; String[].class;\n    System.out.println(clazz.getName());  &#x2F;&#x2F;获取类名称（得到的是包名+类名的完整名称）\n    System.out.println(clazz.getSimpleName());\n    System.out.println(clazz.getTypeName());\n    System.out.println(clazz.getClassLoader());   &#x2F;&#x2F;获取它的类加载器\n    System.out.println(clazz.cast(new Integer(&quot;10&quot;)));   &#x2F;&#x2F;强制类型转换\n&#125;\n\n再谈instanceof正常情况下，我们使用instanceof进行类型比较：\npublic static void main(String[] args) &#123;\n    String str &#x3D; &quot;&quot;;\n    System.out.println(str instanceof String);\n&#125;\n\n它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：\npublic static void main(String[] args) &#123;\n    String str &#x3D; &quot;&quot;;\n    System.out.println(str.getClass() &#x3D;&#x3D; String.class);   &#x2F;&#x2F;直接判断是否为这个类型\n&#125;\n\n如果需要判断是否为子类或是接口&#x2F;抽象类的实现，我们可以使用asSubClass()方法：\npublic static void main(String[] args) &#123;\n    Integer i &#x3D; 10;\n    i.getClass().asSubclass(Number.class);   &#x2F;&#x2F;当Integer不是Number的子类时，会产生异常\n&#125;\n\n获取父类信息通过getSuperclass()方法，我们可以获取到父类的Class对象：\npublic static void main(String[] args) &#123;\n    Integer i &#x3D; 10;\n    System.out.println(i.getClass().getSuperclass());\n&#125;\n\n也可以通过getGenericSuperclass()获取父类的原始类型的Type：\npublic static void main(String[] args) &#123;\n    Integer i &#x3D; 10;\n    Type type &#x3D; i.getClass().getGenericSuperclass();\n    System.out.println(type);\n    System.out.println(type instanceof Class);\n&#125;\n\n我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。\n同理，我们也可以像上面这样获取父接口：\npublic static void main(String[] args) &#123;\n    Integer i &#x3D; 10;\n    for (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;\n        System.out.println(anInterface.getName());\n    &#125;\n  \n  \tfor (Type genericInterface : i.getClass().getGenericInterfaces()) &#123;\n        System.out.println(genericInterface.getTypeName());\n    &#125;\n&#125;\n\n\n创建类对象既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    Student student &#x3D; clazz.newInstance();\n    student.test();\n&#125;\n\nstatic class Student&#123;\n    public void test()&#123;\n        System.out.println(&quot;萨日朗&quot;);\n    &#125;\n&#125;\n\n通过使用newInstance()方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    Student student &#x3D; clazz.newInstance();\n    student.test();\n&#125;\n\nstatic class Student&#123;\n\n    public Student(String text)&#123;\n        \n    &#125;\n\n    public void test()&#123;\n        System.out.println(&quot;萨日朗&quot;);\n    &#125;\n&#125;\n\n当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为newInstance()只适用于默认无参构造。\npublic static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    Student student &#x3D; clazz.newInstance();\n    student.test();\n&#125;\n\nstatic class Student&#123;\n\n    private Student()&#123;&#125;\n\n    public void test()&#123;\n        System.out.println(&quot;萨日朗&quot;);\n    &#125;\n&#125;\n\n当默认无参构造的权限不是public时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用newInstance()方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    Student student &#x3D; clazz.getConstructor(String.class).newInstance(&quot;what&#39;s up&quot;);\n    student.test();\n&#125;\n\nstatic class Student&#123;\n\n    public Student(String str)&#123;&#125;\n\n    public void test()&#123;\n        System.out.println(&quot;萨日朗&quot;);\n    &#125;\n&#125;\n\n通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用getConstructor()方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    Student student &#x3D; clazz.getConstructor(String.class).newInstance(&quot;what&#39;s up&quot;);\n    student.test();\n&#125;\n\nstatic class Student&#123;\n\n    private Student(String str)&#123;&#125;\n\n    public void test()&#123;\n        System.out.println(&quot;萨日朗&quot;);\n    &#125;\n&#125;\n\n我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？\nClass&lt;Student&gt; clazz &#x3D; Student.class;\nConstructor&lt;Student&gt; constructor &#x3D; clazz.getDeclaredConstructor(String.class);\nconstructor.setAccessible(true);   &#x2F;&#x2F;修改访问权限\nStudent student &#x3D; constructor.newInstance(&quot;what&#39;s up&quot;);\nstudent.test();\n\n使用getDeclaredConstructor()方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）\n\n调用类的方法我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：\npackage com.test;\n\npublic class Student &#123;\n    public void test(String str)&#123;\n        System.out.println(&quot;萨日朗&quot;+str);\n    &#125;\n&#125;\n\n这次我们通过forName(String)来找到这个类并创建一个新的对象：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.test.Student&quot;);\n    Object instance &#x3D; clazz.newInstance();   &#x2F;&#x2F;创建出学生对象\n    Method method &#x3D; clazz.getMethod(&quot;test&quot;, String.class);   &#x2F;&#x2F;通过方法名和形参类型获取类中的方法\n    \n    method.invoke(instance, &quot;what&#39;s up&quot;);   &#x2F;&#x2F;通过Method对象的invoke方法来调用方法\n&#125;\n\n通过调用getMethod()方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的invoke()方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。\n我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。\n同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将test()方法的权限修饰符改为private：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.test.Student&quot;);\n    Object instance &#x3D; clazz.newInstance();   &#x2F;&#x2F;创建出学生对象\n    Method method &#x3D; clazz.getDeclaredMethod(&quot;test&quot;, String.class);   &#x2F;&#x2F;通过方法名和形参类型获取类中的方法\n    method.setAccessible(true);\n\n    method.invoke(instance, &quot;what&#39;s up&quot;);   &#x2F;&#x2F;通过Method对象的invoke方法来调用方法\n&#125;\n\nMethod和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.test.Student&quot;);\n    Method method &#x3D; clazz.getDeclaredMethod(&quot;test&quot;, String.class);   &#x2F;&#x2F;通过方法名和形参类型获取类中的方法\n    \n    System.out.println(method.getName());   &#x2F;&#x2F;获取方法名称\n    System.out.println(method.getReturnType());   &#x2F;&#x2F;获取返回值类型\n&#125;\n\n当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：\nMethod method &#x3D; clazz.getDeclaredMethod(&quot;test&quot;, String[].class);\n\n反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。\n\n修改类的属性我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过getField()方法来获取一个类定义的指定字段：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.test.Student&quot;);\n    Object instance &#x3D; clazz.newInstance();\n\n    Field field &#x3D; clazz.getField(&quot;i&quot;);   &#x2F;&#x2F;获取类的成员字段i\n    field.set(instance, 100);   &#x2F;&#x2F;将类实例instance的成员字段i设置为100\n\n    Method method &#x3D; clazz.getMethod(&quot;test&quot;);\n    method.invoke(instance);\n&#125;\n\n在得到Field之后，我们就可以直接通过set()方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.test.Student&quot;);\n    Object instance &#x3D; clazz.newInstance();\n\n    Field field &#x3D; clazz.getDeclaredField(&quot;i&quot;);   &#x2F;&#x2F;获取类的成员字段i\n    field.setAccessible(true);\n    field.set(instance, 100);   &#x2F;&#x2F;将类实例instance的成员字段i设置为100\n\n    Method method &#x3D; clazz.getMethod(&quot;test&quot;);\n    method.invoke(instance);\n&#125;\n\n现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段i前面添加final关键字，我们再来看看效果：\nprivate final int i &#x3D; 10;\n\n这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    Integer i &#x3D; 10;\n\n    Field field &#x3D; Integer.class.getDeclaredField(&quot;value&quot;);\n\n    Field modifiersField &#x3D; Field.class.getDeclaredField(&quot;modifiers&quot;);  &#x2F;&#x2F;这里要获取Field类的modifiers字段进行修改\n    modifiersField.setAccessible(true);\n    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  &#x2F;&#x2F;去除final标记\n\n    field.setAccessible(true);\n    field.set(i, 100);   &#x2F;&#x2F;强行设置值\n\n    System.out.println(i);\n&#125;\n\n我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：\npublic static void main(String[] args) throws ReflectiveOperationException &#123;\n    List&lt;String&gt; i &#x3D; new ArrayList&lt;&gt;();\n\n    Field field &#x3D; ArrayList.class.getDeclaredField(&quot;size&quot;);\n    field.setAccessible(true);\n    field.set(i, 10);\n\n    i.add(&quot;测试&quot;);   &#x2F;&#x2F;只添加一个元素\n    System.out.println(i.size());  &#x2F;&#x2F;大小直接变成11\n    i.remove(10);   &#x2F;&#x2F;瞎移除都不带报错的，淦\n&#125;\n\n实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！\n再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！\n\n自定义ClassLoader加载类我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：\npackage com.test;\n\npublic class Test &#123;\n    public String text;\n\n    public void test(String str)&#123;\n        System.out.println(text+&quot; &gt; 我是测试方法！&quot;+str);\n    &#125;\n&#125;\n\n通过javac命令，手动编译一个.class文件：\nnagocoler@NagodeMacBook-Pro HelloWorld % javac src&#x2F;main&#x2F;java&#x2F;com&#x2F;test&#x2F;Test.java\n\n编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自己的来让它支持：\n&#x2F;&#x2F;定义一个自己的ClassLoader\nstatic class MyClassLoader extends ClassLoader&#123;\n    public Class&lt;?&gt; defineClass(String name, byte[] b)&#123;\n        return defineClass(name, b, 0, b.length);   &#x2F;&#x2F;调用protected方法，支持载入外部class文件\n    &#125;\n&#125;\n\npublic static void main(String[] args) throws IOException &#123;\n    MyClassLoader classLoader &#x3D; new MyClassLoader();\n    FileInputStream stream &#x3D; new FileInputStream(&quot;Test.class&quot;);\n    byte[] bytes &#x3D; new byte[stream.available()];\n    stream.read(bytes);\n    Class&lt;?&gt; clazz &#x3D; classLoader.defineClass(&quot;com.test.Test&quot;, bytes);   &#x2F;&#x2F;类名必须和我们定义的保持一致\n    System.out.println(clazz.getName());   &#x2F;&#x2F;成功加载外部class文件\n&#125;\n\n现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：\ntry &#123;\n    Object obj &#x3D; clazz.newInstance();\n    Method method &#x3D; clazz.getMethod(&quot;test&quot;, String.class);   &#x2F;&#x2F;获取我们定义的test(String str)方法\n    method.invoke(obj, &quot;哥们这瓜多少钱一斤？&quot;);\n&#125;catch (Exception e)&#123;\n    e.printStackTrace();\n&#125;\n\n我们来试试看修改成员字段之后，再来调用此方法：\ntry &#123;\n    Object obj &#x3D; clazz.newInstance();\n    Field field &#x3D; clazz.getField(&quot;text&quot;);   &#x2F;&#x2F;获取成员变量 String text;\n    field.set(obj, &quot;华强&quot;);\n    Method method &#x3D; clazz.getMethod(&quot;test&quot;, String.class);   &#x2F;&#x2F;获取我们定义的test(String str)方法\n    method.invoke(obj, &quot;哥们这瓜多少钱一斤？&quot;);\n&#125;catch (Exception e)&#123;\n    e.printStackTrace();\n&#125;\n\n通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。\n\n注解其实我们在之前就接触到注解了，比如@Override表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。\n注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。\n预设注解JDK预设了以下注解，作用于代码：\n\n@Override - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。\n@SuppressWarnings - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）\n@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。\n@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\n\n元注解元注解是作用于注解上的注解，用于我们编写自定义的注解：\n\n@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\n@Documented - 标记这些注解是否包含在用户文档中。\n@Target - 标记这个注解应该是哪种 Java 成员。\n@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\n@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。\n\n看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看@Override是如何定义的：\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n该注解由@Target限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。@Retention表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个@Retention和1-n个@Target。\n既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test &#123;\n&#125;\n\n这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：\n@Test\npublic class Main &#123;\n    @Test\n    public static void main(String[] args) &#123;\n        \n    &#125;\n&#125;\n\n这样，一个最简单的注解就被我们创建了。\n注解的使用我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test &#123;\n    String value();\n&#125;\n\n默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test &#123;\n    String test();\n&#125;\n\npublic class Main &#123;\n    @Test(test &#x3D; &quot;&quot;)\n    public static void main(String[] args) &#123;\n\n    &#125;\n&#125;\n\n我们也可以使用default关键字来为这些属性指定默认值：\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test &#123;\n    String value() default &quot;都看到这里了，给个三连吧！&quot;;\n&#125;\n\n当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test &#123;\n    String[] value();\n&#125;\n\n当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：\n@Test(&quot;关注点了吗&quot;)\npublic static void main(String[] args) &#123;\n\t\n&#125;\n\npublic class Main &#123;\n    @Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)   &#x2F;&#x2F;多个值时就使用花括号括起来\n    public static void main(String[] args) &#123;\n\n    &#125;\n&#125;\n\n反射获取注解既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：\npublic static void main(String[] args) &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    for (Annotation annotation : clazz.getAnnotations()) &#123;\n        System.out.println(annotation.annotationType());   &#x2F;&#x2F;获取类型\n        System.out.println(annotation instanceof Test);   &#x2F;&#x2F;直接判断是否为Test\n        Test test &#x3D; (Test) annotation;\n        System.out.println(test.value());   &#x2F;&#x2F;获取我们在注解中写入的内容\n    &#125;\n&#125;\n\n通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：\npublic static void main(String[] args) throws NoSuchMethodException &#123;\n    Class&lt;Student&gt; clazz &#x3D; Student.class;\n    for (Annotation annotation : clazz.getMethod(&quot;test&quot;).getAnnotations()) &#123;\n        System.out.println(annotation.annotationType());   &#x2F;&#x2F;获取类型\n        System.out.println(annotation instanceof Test);   &#x2F;&#x2F;直接判断是否为Test\n        Test test &#x3D; (Test) annotation;\n        System.out.println(test.value());   &#x2F;&#x2F;获取我们在注解中写入的内容\n    &#125;\n&#125;\n\n无论是方法、类、还是字段，都可以使用getAnnotations()方法（还有几个同名的）来快速获取我们标记的注解。\n所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段你们还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，就能感受到注解带来的魅力了。\n","slug":"JavaSE笔记（七）","date":"2022-03-09T03:42:26.687Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"546513fbd12f522410dcfae3c5802bbd","title":"JavaSE笔记（六）","content":"Java多线程注意：本章节会涉及到 操作系统 相关知识。\n在了解多线程之前，让我们回顾一下操作系统中提到的进程概念：\n\n进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过时间片轮转调度算法，来实现多个进程的同时运行。\n\n在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？\n\n后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。\n在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行main()方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法同时在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：\npublic static void main(String[] args) &#123;\n    ThreadMXBean bean &#x3D; ManagementFactory.getThreadMXBean();\n    long[] ids &#x3D; bean.getAllThreadIds();\n    ThreadInfo[] infos &#x3D; bean.getThreadInfo(ids);\n    for (ThreadInfo info : infos) &#123;\n        System.out.println(info.getThreadName());\n    &#125;\n&#125;\n\n关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。\n\n线程的创建和启动通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：\n@FunctionalInterface\npublic interface Runnable &#123;\n    &#x2F;**\n     * When an object implementing interface &lt;code&gt;Runnable&lt;&#x2F;code&gt; is used\n     * to create a thread, starting the thread causes the object&#39;s\n     * &lt;code&gt;run&lt;&#x2F;code&gt; method to be called in that separately executing\n     * thread.\n     * &lt;p&gt;\n     * The general contract of the method &lt;code&gt;run&lt;&#x2F;code&gt; is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     *&#x2F;\n    public abstract void run();\n&#125;\n\n创建好后，通过调用start()方法来运行此线程：\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;    &#x2F;&#x2F;直接编写逻辑\n        System.out.println(&quot;我是另一个线程！&quot;);\n    &#125;);\n    t.start();   &#x2F;&#x2F;调用此方法来开始执行此线程\n&#125;\n\n可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;我是线程：&quot;+Thread.currentThread().getName());\n        System.out.println(&quot;我正在计算 0-10000 之间所有数的和...&quot;);\n        int sum &#x3D; 0;\n        for (int i &#x3D; 0; i &lt;&#x3D; 10000; i++) &#123;\n            sum +&#x3D; i;\n        &#125;\n        System.out.println(&quot;结果：&quot;+sum);\n    &#125;);\n    t.start();\n    System.out.println(&quot;我是主线程！&quot;);\n&#125;\n\n我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：\npublic static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;我是一号线程：&quot;+i);\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;我是二号线程：&quot;+i);\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;\n\n我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！\n注意：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！\n\n实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用sleep()方法来让当前线程休眠一段时间：\npublic static void main(String[] args) throws InterruptedException &#123;\n    System.out.println(&quot;l&quot;);\n    Thread.sleep(1000);    &#x2F;&#x2F;休眠时间，以毫秒为单位，1000ms &#x3D; 1s\n    System.out.println(&quot;b&quot;);\n    Thread.sleep(1000);\n    System.out.println(&quot;w&quot;);\n    Thread.sleep(1000);\n    System.out.println(&quot;nb!&quot;);\n&#125;\n\n我们也可以使用stop()方法来强行终止此线程：\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        Thread me &#x3D; Thread.currentThread();   &#x2F;&#x2F;获取当前线程对象\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;打印:&quot;+i);\n            if(i &#x3D;&#x3D; 20) me.stop();  &#x2F;&#x2F;此方法会直接终止此线程\n        &#125;\n    &#125;);\n    t.start();\n&#125;\n\n虽然stop()方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。\n思考：猜猜以下程序输出结果：\nprivate static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;\n\n我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。\n\n线程的休眠和中断我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：\n\n当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。\n当线程进入休眠 &#x2F; 阻塞(如等待IO请求) &#x2F; 手动调用wait()方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。\n当线程出现异常或错误 &#x2F; 被stop() 方法强行停止 &#x2F; 所有代码执行结束时，会使得线程的运行终止。\n\n而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        try &#123;\n            System.out.println(&quot;l&quot;);\n            Thread.sleep(1000);   &#x2F;&#x2F;sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）\n            System.out.println(&quot;b&quot;);    &#x2F;&#x2F;调用sleep后，线程会直接进入到等待状态，直到时间结束\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;);\n    t.start();\n&#125;\n\n通过调用sleep()方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        try &#123;\n            Thread.sleep(10000);  &#x2F;&#x2F;休眠10秒\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n我们发现，每一个Thread对象中，都有一个interrupt()方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的stop()方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        while (true)&#123;   &#x2F;&#x2F;无限循环\n            if(Thread.currentThread().isInterrupted())&#123;   &#x2F;&#x2F;判断是否存在中断标志\n                break;   &#x2F;&#x2F;响应中断\n            &#125;\n        &#125;\n        System.out.println(&quot;线程被中断了！&quot;);\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n通过isInterrupted()可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        while (true)&#123;\n            if(Thread.currentThread().isInterrupted())&#123;   &#x2F;&#x2F;判断是否存在中断标志\n                System.out.println(&quot;发现中断信号，复位，继续运行...&quot;);\n                Thread.interrupted();  &#x2F;&#x2F;复位中断标记（返回值是当前是否有中断标记，这里不用管）\n            &#125;\n        &#125;\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.interrupt();   &#x2F;&#x2F;调用t的interrupt方法\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n        Thread.currentThread().suspend();   &#x2F;&#x2F;暂停此线程\n        System.out.println(&quot;线程继续运行！&quot;);\n    &#125;);\n    t.start();\n    try &#123;\n        Thread.sleep(3000);   &#x2F;&#x2F;休眠3秒，一定比线程t先醒来\n        t.resume();   &#x2F;&#x2F;恢复此线程\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。\n\n线程的优先级实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：\n\nMIN_PRIORITY   最低优先级\nMAX_PRIORITY   最高优先级\nNOM_PRIORITY  常规优先级\n\npublic static void main(String[] args) &#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程开始运行！&quot;);\n    &#125;);\n    t.start();\n    t.setPriority(Thread.MIN_PRIORITY);  &#x2F;&#x2F;通过使用setPriority方法来设定优先级\n&#125;\n\n优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！\n线程的礼让和加入我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用yield()方法来将当前资源让位给其他同优先级线程：\npublic static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程1开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            if(i % 5 &#x3D;&#x3D; 0) &#123;\n                System.out.println(&quot;让位！&quot;);\n                Thread.yield();\n            &#125;\n            System.out.println(&quot;1打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;\n\n观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。\n当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用join()方法来实现线程的加入：\npublic static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程1开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;1打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n            if(i &#x3D;&#x3D; 10)&#123;\n                try &#123;\n                    System.out.println(&quot;线程1加入到此线程！&quot;);\n                    t1.join();    &#x2F;&#x2F;在i&#x3D;&#x3D;10时，让线程1加入，先完成线程1的内容，在继续当前内容\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;\n\n我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：\npublic static void main(String[] args) &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(Thread.currentThread().getName()+&quot;开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;打印：&quot;+i);\n        &#125;\n        System.out.println(&quot;线程1结束！&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(&quot;线程2开始运行！&quot;);\n        for (int i &#x3D; 0; i &lt; 50; i++) &#123;\n            System.out.println(&quot;2打印：&quot;+i);\n            if(i &#x3D;&#x3D; 10)&#123;\n                try &#123;\n                    System.out.println(&quot;线程1加入到此线程！&quot;);\n                    t1.join();    &#x2F;&#x2F;在i&#x3D;&#x3D;10时，让线程1加入，先完成线程1的内容，在继续当前内容\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;\n\n实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。\n\n线程锁和线程同步在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：\n\n线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读&#x2F;写共享变量的副本。它类似于我们在计算机组成原理中学习的多处理器高速缓存机制：\n\n高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。\n实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！\n悬念破案我们再来回顾一下之前留给大家的悬念：\nprivate static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) value++;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;\n\n实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！\n\n那么要去解决这样的问题，我们就必须采取某种同步机制，来限制不同线程对于共享变量的访问！我们希望的是保证共享变量value自增操作的原子性（原子性是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，包括其他线程，要么就都不执行）\n线程锁通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：\nprivate static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (Main.class)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (Main.class)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;\n\n我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！\n当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容。（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面有机会我们还会讲到乐观锁，如CAS算法）\n那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？\nprivate static int value &#x3D; 0;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Main main1 &#x3D; new Main();\n    Main main2 &#x3D; new Main();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (main1)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n            synchronized (main2)&#123;\n                value++;\n            &#125;\n        &#125;\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;\n\n当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。\nsynchronized关键字也可以作用于方法上，调用此方法时也会获取锁：\nprivate static int value &#x3D; 0;\n\nprivate static synchronized void add()&#123;\n    value++;\n&#125;\n\npublic static void main(String[] args) throws InterruptedException &#123;\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) add();\n        System.out.println(&quot;线程1完成&quot;);\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 10000; i++) add();\n        System.out.println(&quot;线程2完成&quot;);\n    &#125;);\n    t1.start();\n    t2.start();\n    Thread.sleep(1000);  &#x2F;&#x2F;主线程停止1秒，保证两个线程执行完成\n    System.out.println(value);\n&#125;\n\n我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了！\n死锁其实死锁的概念在操作系统中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：\n\n我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：\npublic static void main(String[] args) throws InterruptedException &#123;\n    Object o1 &#x3D; new Object();\n    Object o2 &#x3D; new Object();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            try &#123;\n                Thread.sleep(1000);\n                synchronized (o2)&#123;\n                    System.out.println(&quot;线程1&quot;);\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o2)&#123;\n            try &#123;\n                Thread.sleep(1000);\n                synchronized (o1)&#123;\n                    System.out.println(&quot;线程2&quot;);\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    t1.start();\n    t2.start();\n&#125;\n\n那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：\nnagocoler@NagodeMacBook-Pro ~ % jps\n51592 Launcher\n51690 Jps\n14955 \n51693 Main\nnagocoler@NagodeMacBook-Pro ~ % jstack 51693\n...\nJava stack information for the threads listed above:\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;Thread-1&quot;:\n\tat com.test.Main.lambda$main$1(Main.java:46)\n\t- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)\n\t- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)\n\tat com.test.Main$$Lambda$2&#x2F;1867750575.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n&quot;Thread-0&quot;:\n\tat com.test.Main.lambda$main$0(Main.java:34)\n\t- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)\n\t- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)\n\tat com.test.Main$$Lambda$1&#x2F;396873410.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n\nFound 1 deadlock.\n\njstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息。\n不推荐使用 suspend() 去挂起线程的原因，是因为suspend()在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行resume()方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果resume()操作出现在suspend()之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。\nwait和notify方法其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是wait()、notify()以及notifyAll()，他们其实是需要配合synchronized来使用的，只有在同步代码块中才能使用这些方法，我们来看看他们的作用是什么：\npublic static void main(String[] args) throws InterruptedException &#123;\n    Object o1 &#x3D; new Object();\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            try &#123;\n                System.out.println(&quot;开始等待&quot;);\n                o1.wait();     &#x2F;&#x2F;进入等待状态并释放锁\n                System.out.println(&quot;等待结束！&quot;);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        synchronized (o1)&#123;\n            System.out.println(&quot;开始唤醒！&quot;);\n            o1.notify();     &#x2F;&#x2F;唤醒处于等待状态的线程\n          \tfor (int i &#x3D; 0; i &lt; 50; i++) &#123;\n               \tSystem.out.println(i);   \n            &#125;\n          \t&#x2F;&#x2F;唤醒后依然需要等待这里的锁释放之前等待的线程才能继续\n        &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t2.start();\n&#125;\n\n我们可以发现，对象的wait()方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的notify()方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！\nnotifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用wait()后处于等待的线程，而后者是看运气随机选择一个。\nThreadLocal的使用既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？\n\n我们可以是ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的变量访问到ThreadLocal对象时，都只能获取到自己线程所属的变量。\npublic static void main(String[] args) throws InterruptedException &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();  &#x2F;&#x2F;注意这是一个泛型类，存储类型为我们要存放的变量类型\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;lbwnb&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;变量值已设定！&quot;);\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);    &#x2F;&#x2F;间隔三秒\n    t2.start();\n&#125;\n\n上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：\npublic static void main(String[] args) throws InterruptedException &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();  &#x2F;&#x2F;注意这是一个泛型类，存储类型为我们要存放的变量类型\n    Thread t1 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;lbwnb&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;线程1变量值已设定！&quot;);\n        try &#123;\n            Thread.sleep(2000);    &#x2F;&#x2F;间隔2秒\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;线程1读取变量值：&quot;);\n        System.out.println(local.get());   &#x2F;&#x2F;尝试获取ThreadLocal中存放的变量\n    &#125;);\n    Thread t2 &#x3D; new Thread(() -&gt; &#123;\n        local.set(&quot;yyds&quot;);   &#x2F;&#x2F;将变量的值给予ThreadLocal\n        System.out.println(&quot;线程2变量值已设定！&quot;);\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);    &#x2F;&#x2F;间隔1秒\n    t2.start();\n&#125;\n\n我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。\n我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：\npublic static void main(String[] args) &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new ThreadLocal&lt;&gt;();\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n       local.set(&quot;lbwnb&quot;);\n        new Thread(() -&gt; &#123;\n            System.out.println(local.get());\n        &#125;).start();\n    &#125;);\n    t.start();\n&#125;\n\n我们可以使用InheritableThreadLocal来解决：\npublic static void main(String[] args) &#123;\n    ThreadLocal&lt;String&gt; local &#x3D; new InheritableThreadLocal&lt;&gt;();\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n       local.set(&quot;lbwnb&quot;);\n        new Thread(() -&gt; &#123;\n            System.out.println(local.get());\n        &#125;).start();\n    &#125;);\n    t.start();\n&#125;\n\n在InheritableThreadLocal存放的内容，会自动向子线程传递。\n\n定时器我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用Thread.sleep()来实现：\npublic static void main(String[] args) &#123;\n    new TimerTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   &#x2F;&#x2F;创建并启动此定时任务\n&#125;\n\nstatic class TimerTask&#123;\n    Runnable task;\n    long time;\n\n    public TimerTask(Runnable runnable, long time)&#123;\n        this.task &#x3D; runnable;\n        this.time &#x3D; time;\n    &#125;\n\n    public void start()&#123;\n        new Thread(() -&gt; &#123;\n            try &#123;\n                Thread.sleep(time);\n                task.run();   &#x2F;&#x2F;休眠后再运行\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？\npublic static void main(String[] args) &#123;\n    new TimerLoopTask(() -&gt; System.out.println(&quot;我是定时任务！&quot;), 3000).start();   &#x2F;&#x2F;创建并启动此定时任务\n&#125;\n\nstatic class TimerLoopTask&#123;\n    Runnable task;\n    long loopTime;\n\n    public TimerLoopTask(Runnable runnable, long loopTime)&#123;\n        this.task &#x3D; runnable;\n        this.loopTime &#x3D; loopTime;\n    &#125;\n\n    public void start()&#123;\n        new Thread(() -&gt; &#123;\n            try &#123;\n                while (true)&#123;   &#x2F;&#x2F;无限循环执行\n                    Thread.sleep(loopTime);\n                    task.run();   &#x2F;&#x2F;休眠后再运行\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;).start();\n    &#125;\n&#125;\n\n现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。\n但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：\npublic static void main(String[] args) &#123;\n    Timer timer &#x3D; new Timer();    &#x2F;&#x2F;创建定时器对象\n    timer.schedule(new TimerTask() &#123;   &#x2F;&#x2F;注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName());    &#x2F;&#x2F;打印当前线程名称\n        &#125;\n    &#125;, 1000);    &#x2F;&#x2F;执行一个延时任务\n&#125;\n\n我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：\npublic class Timer &#123;\n    &#x2F;**\n     * The timer task queue.  This data structure is shared with the timer\n     * thread.  The timer produces tasks, via its various schedule calls,\n     * and the timer thread consumes, executing timer tasks as appropriate,\n     * and removing them from the queue when they&#39;re obsolete.\n     *&#x2F;\n    private final TaskQueue queue &#x3D; new TaskQueue();\n\n    &#x2F;**\n     * The timer thread.\n     *&#x2F;\n    private final TimerThread thread &#x3D; new TimerThread(queue);\n  \n\t\t...\n&#125;\n\nTimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：\npublic Timer(String name) &#123;\n    thread.setName(name);\n    thread.start();\n&#125;\n\n而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：\npublic void run() &#123;\n    try &#123;\n        mainLoop();\n    &#125; finally &#123;\n        &#x2F;&#x2F; Someone killed this Thread, behave as if Timer cancelled\n        synchronized(queue) &#123;\n            newTasksMayBeScheduled &#x3D; false;\n            queue.clear();  &#x2F;&#x2F; Eliminate obsolete references\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;**\n * The main timer loop.  (See class comment.)\n *&#x2F;\nprivate void mainLoop() &#123;\n  try &#123;\n       TimerTask task;\n       boolean taskFired;\n       synchronized(queue) &#123;\n         \t&#x2F;&#x2F; Wait for queue to become non-empty\n          while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   &#x2F;&#x2F;当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。\n                queue.wait();\n          if (queue.isEmpty())\n             break;    &#x2F;&#x2F;当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程\n                      ...\n&#125;\n\nnewTasksMayBeScheduled实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用cancel()方法来关闭它的工作线程：\npublic void cancel() &#123;\n    synchronized(queue) &#123;\n        thread.newTasksMayBeScheduled &#x3D; false;\n        queue.clear();\n        queue.notify();  &#x2F;&#x2F;唤醒wait使得工作线程结束\n    &#125;\n&#125;\n\n因此，我们可以在使用完成后，调用Timer的cancel()方法以正常退出我们的程序：\npublic static void main(String[] args) &#123;\n    Timer timer &#x3D; new Timer();\n    timer.schedule(new TimerTask() &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(Thread.currentThread().getName());\n            timer.cancel();  &#x2F;&#x2F;结束\n        &#125;\n    &#125;, 1000);\n&#125;\n\n\n守护线程不要把守护进程和守护线程相提并论！守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程是自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：\npublic static void main(String[] args) throws InterruptedException&#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        while (true)&#123;\n            try &#123;\n                System.out.println(&quot;程序正常运行中...&quot;);\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    t.setDaemon(true);   &#x2F;&#x2F;设置为守护线程（必须在开始之前，中途是不允许转换的）\n    t.start();\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        Thread.sleep(1000);\n    &#125;\n&#125;\n\n在守护线程中产生的新线程也是守护的：\npublic static void main(String[] args) throws InterruptedException&#123;\n    Thread t &#x3D; new Thread(() -&gt; &#123;\n        Thread it &#x3D; new Thread(() -&gt; &#123;\n            while (true)&#123;\n                try &#123;\n                    System.out.println(&quot;程序正常运行中...&quot;);\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;);\n        it.start();\n    &#125;);\n    t.setDaemon(true);   &#x2F;&#x2F;设置为守护线程（必须在开始之前，中途是不允许转换的）\n    t.start();\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        Thread.sleep(1000);\n    &#125;\n&#125;\n\n\n再谈集合类并行方法其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：\ndefault Stream&lt;E&gt; parallelStream() &#123;\n    return StreamSupport.stream(spliterator(), true);\n&#125;\n\n并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));\n    list\n            .parallelStream()    &#x2F;&#x2F;获得并行流\n            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+&quot; -&gt; &quot;+i));\n&#125;\n\n我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用forEachOrdered()方法来使用单线程维持原本的顺序：\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 4, 5, 2, 9, 3, 6, 0));\n    list\n            .parallelStream()    &#x2F;&#x2F;获得并行流\n            .forEachOrdered(System.out::println);\n&#125;\n\n我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：\npublic static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;;\n    Arrays.parallelSort(arr);   &#x2F;&#x2F;使用多线程进行并行排序，效率更高\n    System.out.println(Arrays.toString(arr));\n&#125;\n\n更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！\npublic static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 4, 5, 2, 9, 3, 6, 0&#125;;\n    Arrays.parallelSetAll(arr, i -&gt; &#123;\n        System.out.println(Thread.currentThread().getName());\n        return arr[i];\n    &#125;);\n    System.out.println(Arrays.toString(arr));\n&#125;\n\n通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！\n\nJava多线程编程实战这是整个教程最后一个编程实战内容了，下一章节为反射一般开发者使用比较少，属于选学内容，不编排编程实战课程。\n生产者与消费者所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。\n通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。\n","slug":"JavaSE笔记（六）","date":"2022-03-09T03:42:06.895Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"3d7015538194631f51f4f8a71af09913","title":"JavaSE笔记（五）","content":"Java I&#x2F;O注意：这块会涉及到操作系统和计算机组成原理相关内容。\nI&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I&#x2F;O设备。\n我们可以大致看一下整个计算机的总线结构：\n\n常见的I&#x2F;O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。\n而我们在程序中，想要读取这些外部连接的I&#x2F;O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows&#x2F;Linux&#x2F;MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取&#x2F;写入请求。从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。\nJDK提供了一套用于IO操作的框架，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成。而这类IO就是我们所说的BIO，\n字节流一次读取一个字节，也就是一个byte的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个char的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。\n文件流要学习和使用IO，首先就要从最易于理解的读取文件开始说起。\n文件字节流首先介绍一下FileInputStream，通过它来获取文件的输入流。\npublic static void main(String[] args) &#123;\n    try &#123;\n        FileInputStream inputStream &#x3D; new FileInputStream(&quot;路径&quot;);\n        &#x2F;&#x2F;路径支持相对路径和绝对路径\n    &#125; catch (FileNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n相对路径是在当前运行的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用/或是\\\\，但是不能写为\\因为它是转义字符！\n在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用！\npublic static void main(String[] args) &#123;\n    FileInputStream inputStream &#x3D; null;    &#x2F;&#x2F;定义可以先放在try外部\n    try &#123;\n        inputStream &#x3D; new FileInputStream(&quot;路径&quot;);\n    &#125; catch (FileNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;    &#x2F;&#x2F;建议在finally中进行，因为这个是任何情况都必须要执行的！\n            if(inputStream !&#x3D; null) inputStream.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）\npublic static void main(String[] args) &#123;\n\n    &#x2F;&#x2F;注意，这种语法只支持实现了AutoCloseable接口的类！\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;路径&quot;)) &#123;   &#x2F;&#x2F;直接在try()中定义要在完成之后释放的资源\n\n    &#125; catch (IOException e) &#123;   &#x2F;&#x2F;这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的\n        e.printStackTrace();\n    &#125;\n    &#x2F;&#x2F;无需再编写finally语句块，因为在最后自动帮我们调用了close()\n&#125;\n\n之后为了方便，我们都使用此语法进行教学。\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：a\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        &#x2F;&#x2F;使用read()方法进行字符读取\n        System.out.println((char) inputStream.read());  &#x2F;&#x2F;读取一个字节的数据（英文字母只占1字节，中文占2字节）\n        System.out.println(inputStream.read());   &#x2F;&#x2F;唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个！我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        int tmp;\n        while ((tmp &#x3D; inputStream.read()) !&#x3D; -1)&#123;   &#x2F;&#x2F;通过while循环来一次性读完内容\n            System.out.println((char)tmp);\n        &#125;\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n使用方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I&#x2F;O操作时，这个方法只能进行一个预估也可以说是暂时能一次性读取的数量）\ntry(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n    System.out.println(inputStream.available());  &#x2F;&#x2F;查看剩余数量\n&#125;catch (IOException e)&#123;\n    e.printStackTrace();\n&#125;\n\n当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放。\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        byte[] bytes &#x3D; new byte[inputStream.available()];   &#x2F;&#x2F;我们可以提前准备好合适容量的byte数组来存放\n        System.out.println(inputStream.read(bytes));   &#x2F;&#x2F;一次性读取全部内容（返回值是读取的字节数）\n        System.out.println(new String(bytes));   &#x2F;&#x2F;通过String(byte[])构造方法得到字符串\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n也可以控制要读取数量：\nSystem.out.println(inputStream.read(bytes, 1, 2));   &#x2F;&#x2F;第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数\n\n注意：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1\n通过skip()方法可以跳过指定数量的字节：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;test.txt：abcd\n    try(FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;\n        System.out.println(inputStream.skip(1));\n        System.out.println((char) inputStream.read());   &#x2F;&#x2F;跳过了一个字节\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n注意：FileInputStream是不支持reset()的，虽然有这个方法，但是这里先不提及。\n既然有输入流，那么文件输出流也是必不可少的：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;输出流也需要在最后调用close()方法，并且同样支持try-with-resource\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;)) &#123;\n        &#x2F;&#x2F;注意：若此文件不存在，会直接创建这个文件！\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n输出流没有read()操作而是write()操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：\npublic static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;)) &#123;\n        outputStream.write(&#39;c&#39;);   &#x2F;&#x2F;同read一样，可以直接写入内容\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes());   &#x2F;&#x2F;也可以直接写入byte[]\n      \toutputStream.write(&quot;lbwnb&quot;.getBytes(), 0, 1);  &#x2F;&#x2F;同上输入流\n      \toutputStream.flush();  &#x2F;&#x2F;建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：\npublic static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;, true)) &#123;\n        outputStream.write(&quot;lb&quot;.getBytes());   &#x2F;&#x2F;现在只会进行追加写入，而不是直接替换原文件内容\n        outputStream.flush();\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n利用输入流和输出流，就可以轻松实现文件的拷贝了：\npublic static void main(String[] args) &#123;\n    try(FileOutputStream outputStream &#x3D; new FileOutputStream(&quot;output.txt&quot;);\n        FileInputStream inputStream &#x3D; new FileInputStream(&quot;test.txt&quot;)) &#123;   &#x2F;&#x2F;可以写入多个\n        byte[] bytes &#x3D; new byte[10];    &#x2F;&#x2F;使用长度为10的byte[]做传输媒介\n        int tmp;   &#x2F;&#x2F;存储本地读取字节数\n        while ((tmp &#x3D; inputStream.read(bytes)) !&#x3D; -1)&#123;   &#x2F;&#x2F;直到读取完成为止\n            outputStream.write(bytes, 0, tmp);    &#x2F;&#x2F;写入对应长度的数据到输出流\n        &#125;\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n文件字符流字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：\npublic static void main(String[] args) &#123;\n    try(FileReader reader &#x3D; new FileReader(&quot;test.txt&quot;))&#123;\n      \treader.skip(1);   &#x2F;&#x2F;现在跳过的是一个字符\n        System.out.println((char) reader.read());   &#x2F;&#x2F;现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n同理，字符流只支持char[]类型作为存储：\npublic static void main(String[] args) &#123;\n    try(FileReader reader &#x3D; new FileReader(&quot;test.txt&quot;))&#123;\n        char[] str &#x3D; new char[10];\n        reader.read(str);\n        System.out.println(str);   &#x2F;&#x2F;直接读取到char[]中\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n既然有了Reader肯定也有Writer：\npublic static void main(String[] args) &#123;\n    try(FileWriter writer &#x3D; new FileWriter(&quot;output.txt&quot;))&#123;\n      \twriter.getEncoding();   &#x2F;&#x2F;支持获取编码（不同的文本文件可能会有不同的编码类型）\n       writer.write(&#39;牛&#39;);\n       writer.append(&#39;牛&#39;);   &#x2F;&#x2F;其实功能和write一样\n      \twriter.flush();   &#x2F;&#x2F;刷新\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n我们发现不仅有write()方法，还有一个append()方法，但是实际上他们效果是一样的，看源码：\n&#x2F;**\n * Appends the specified character to this writer.\n *\n * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;&#x2F;tt&gt;\n * behaves in exactly the same way as the invocation\n *\n * &lt;pre&gt;\n *     out.write(c) &lt;&#x2F;pre&gt;\n *\n * @param  c\n *         The 16-bit character to append\n *\n * @return  This writer\n *\n * @throws  IOException\n *          If an I&#x2F;O error occurs\n *\n * @since 1.5\n *&#x2F;\npublic Writer append(char c) throws IOException &#123;\n    write(c);\n    return this;\n&#125;\n\nappend支持像StringBuilder那样的链式调用，返回的是Writer对象本身。\n练习：尝试一下用Reader和Writer来拷贝纯文本文件\nFile类File类专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。\npublic static void main(String[] args) &#123;\n    File file &#x3D; new File(&quot;test.txt&quot;);   &#x2F;&#x2F;直接创建文件对象，可以是相对路径，也可以是绝对路径\n    System.out.println(file.exists());   &#x2F;&#x2F;此文件是否存在\n    System.out.println(file.length());   &#x2F;&#x2F;获取文件的大小\n    System.out.println(file.isDirectory());   &#x2F;&#x2F;是否为一个文件夹\n    System.out.println(file.canRead());   &#x2F;&#x2F;是否可读\n    System.out.println(file.canWrite());   &#x2F;&#x2F;是否可写\n    System.out.println(file.canExecute());   &#x2F;&#x2F;是否可执行\n&#125;\n\n通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：\nFile file &#x3D; new File(&quot;&#x2F;&quot;);\nSystem.out.println(Arrays.toString(file.list()));   &#x2F;&#x2F;快速获取文件夹下的文件名称列表\nfor (File f : file.listFiles())&#123;   &#x2F;&#x2F;所有子文件的File对象\n    System.out.println(f.getAbsolutePath());   &#x2F;&#x2F;获取文件的绝对路径\n&#125;\n\n如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：\nFile file &#x3D; new File(&quot;test.txt&quot;);\ntry (FileInputStream inputStream &#x3D; new FileInputStream(file))&#123;   &#x2F;&#x2F;直接做参数\n    System.out.println(inputStream.available());\n&#125;catch (IOException e)&#123;\n    e.printStackTrace();\n&#125;\n\n练习：尝试拷贝文件夹下的所有文件到另一个文件夹\n\n缓冲流虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I&#x2F;O设备去获取数据，由于外部I&#x2F;O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。\n\n缓冲字节流要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：\npublic static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;   &#x2F;&#x2F;传入FileInputStream\n        System.out.println((char) bufferedInputStream.read());   &#x2F;&#x2F;操作和原来的流是一样的\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n实际上进行I&#x2F;O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为装饰者模式\npublic void close() throws IOException &#123;\n    byte[] buffer;\n    while ( (buffer &#x3D; buf) !&#x3D; null) &#123;\n        if (bufUpdater.compareAndSet(this, buffer, null)) &#123;  &#x2F;&#x2F;CAS无锁算法，并发会用到，暂时不管\n            InputStream input &#x3D; in;\n            in &#x3D; null;\n            if (input !&#x3D; null)\n                input.close();\n            return;\n        &#125;\n        &#x2F;&#x2F; Else retry in case a new buf was CASed in fill()\n    &#125;\n&#125;\n\n实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。\n我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：\n&#x2F;**\n * The internal buffer array where the data is stored. When necessary,\n * it may be replaced by another array of\n * a different size.\n *&#x2F;\nprotected volatile byte buf[];\n\nI&#x2F;O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持reset()和mark()操作，首先我们来看看mark()方法的介绍：\n&#x2F;**\n * Marks the current position in this input stream. A subsequent\n * call to the &lt;code&gt;reset&lt;&#x2F;code&gt; method repositions this stream at\n * the last marked position so that subsequent reads re-read the same bytes.\n * &lt;p&gt;\n * The &lt;code&gt;readlimit&lt;&#x2F;code&gt; argument tells this input stream to\n * allow that many bytes to be read before the mark position gets\n * invalidated.\n * &lt;p&gt;\n * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;&#x2F;code&gt;.\n *\n * @param   readlimit   the maximum limit of bytes that can be read before\n *                      the mark position becomes invalid.\n * @see     java.io.FilterInputStream#in\n * @see     java.io.FilterInputStream#reset()\n *&#x2F;\npublic synchronized void mark(int readlimit) &#123;\n    in.mark(readlimit);\n&#125;\n\n当调用mark()之后，输入流会以某种方式保留之后读取的readlimit数量的内容，当读取的内容数量超过readlimit则之后的内容不会被保留，当调用reset()之后，会使得当前的读取位置回到mark()调用时的位置。\npublic static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;\n        bufferedInputStream.mark(1);   &#x2F;&#x2F;只保留之后的1个字符\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n        bufferedInputStream.reset();   &#x2F;&#x2F;回到mark时的位置\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实mark()后保存的读取内容是取readlimit和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由readlimit确定。因此我们限制一下缓冲区大小，再来观察一下结果：\npublic static void main(String[] args) &#123;\n    try (BufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;test.txt&quot;), 1))&#123;  &#x2F;&#x2F;将缓冲区大小设置为1\n        bufferedInputStream.mark(1);   &#x2F;&#x2F;只保留之后的1个字符\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());   &#x2F;&#x2F;已经超过了readlimit，继续读取会导致mark失效\n        bufferedInputStream.reset();   &#x2F;&#x2F;mark已经失效，无法reset()\n        System.out.println((char) bufferedInputStream.read());\n        System.out.println((char) bufferedInputStream.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：\npublic static void main(String[] args) &#123;\n    try (BufferedOutputStream outputStream &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;\n        outputStream.write(&quot;lbwnb&quot;.getBytes());\n        outputStream.flush();\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n操作和FileOutputStream一致，这里就不多做介绍了。\n缓冲字符流缓存字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：\npublic static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n使用和reader也是一样的，内部也包含一个缓存数组：\nprivate char cb[];\n\n相比Reader更方便的是，它支持按行读取：\npublic static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        System.out.println(reader.readLine());   &#x2F;&#x2F;按行读取\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：\npublic static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        reader\n                .lines()\n                .limit(2)\n                .distinct()\n                .sorted()\n                .forEach(System.out::println);\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n它同样也支持mark()和reset()操作：\npublic static void main(String[] args) &#123;\n    try (BufferedReader reader &#x3D; new BufferedReader(new FileReader(&quot;test.txt&quot;)))&#123;\n        reader.mark(1);\n        System.out.println((char) reader.read());\n        reader.reset();\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nBufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：\npublic static void main(String[] args) &#123;\n    try (BufferedWriter reader &#x3D; new BufferedWriter(new FileWriter(&quot;output.txt&quot;)))&#123;\n        reader.newLine();   &#x2F;&#x2F;使用newLine进行换行\n        reader.write(&quot;汉堡做滴彳亍不彳亍&quot;);   &#x2F;&#x2F;可以直接写入一个字符串\n      \treader.flush();   &#x2F;&#x2F;清空缓冲区\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n\n转换流有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？\npublic static void main(String[] args) &#123;\n    try(OutputStreamWriter writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;test.txt&quot;)))&#123;  &#x2F;&#x2F;虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入\n        writer.write(&quot;lbwnb&quot;);   &#x2F;&#x2F;以操作Writer的样子写入OutputStream\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：\npublic static void main(String[] args) &#123;\n    try(InputStreamReader reader &#x3D; new InputStreamReader(new FileInputStream(&quot;test.txt&quot;)))&#123;  &#x2F;&#x2F;虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取\n        System.out.println((char) reader.read());\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nInputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。\n\n打印流打印流其实我们从一开始就在使用了，比如System.out就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\npublic final static PrintStream out &#x3D; null;\n\n可以看到System.out也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：\npublic static void main(String[] args) &#123;\n    try(PrintStream stream &#x3D; new PrintStream(new FileOutputStream(&quot;test.txt&quot;)))&#123;\n        stream.println(&quot;lbwnb&quot;);   &#x2F;&#x2F;其实System.out就是一个PrintStream\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n我们平时使用的println方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的toString()方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。\n\n因此实际上内部还包含这两个内容：\n&#x2F;**\n * Track both the text- and character-output streams, so that their buffers\n * can be flushed without flushing the entire stream.\n *&#x2F;\nprivate BufferedWriter textOut;\nprivate OutputStreamWriter charOut;\n\n与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。\n\n数据流数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：\npublic static void main(String[] args) &#123;\n    try (DataInputStream dataInputStream &#x3D; new DataInputStream(new FileInputStream(&quot;test.txt&quot;)))&#123;\n        System.out.println(dataInputStream.readBoolean());   &#x2F;&#x2F;直接将数据读取为任意基本数据类型\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n用于写入基本数据类型：\npublic static void main(String[] args) &#123;\n    try (DataOutputStream dataOutputStream &#x3D; new DataOutputStream(new FileOutputStream(&quot;output.txt&quot;)))&#123;\n        dataOutputStream.writeBoolean(false);\n    &#125;catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。\n对象流既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。\npublic static void main(String[] args) &#123;\n    try (ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));\n         ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;\n        People people &#x3D; new People(&quot;lbw&quot;);\n        outputStream.writeObject(people);\n      \toutputStream.flush();\n        people &#x3D; (People) inputStream.readObject();\n        System.out.println(people.name);\n    &#125;catch (IOException | ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nstatic class People implements Serializable&#123;   &#x2F;&#x2F;必须实现Serializable接口才能被序列化\n    String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：\nstatic class People implements Serializable&#123;\n    private static final long serialVersionUID &#x3D; 123456;   &#x2F;&#x2F;在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。\n\n    String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n当发生版本不匹配时，会无法反序列化为对象：\njava.io.InvalidClassException: com.test.Main$People; local class incompatible: stream classdesc serialVersionUID &#x3D; 123456, local class serialVersionUID &#x3D; 1234567\n\tat java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699)\n\tat java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2003)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1850)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2160)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1667)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:503)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:461)\n\tat com.test.Main.main(Main.java:27)\n\n如果我们不希望某些属性参与到序列化中进行保存，我们可以添加transient关键字：\npublic static void main(String[] args) &#123;\n    try (ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;output.txt&quot;));\n         ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;output.txt&quot;)))&#123;\n        People people &#x3D; new People(&quot;lbw&quot;);\n        outputStream.writeObject(people);\n        outputStream.flush();\n        people &#x3D; (People) inputStream.readObject();\n        System.out.println(people.name);  &#x2F;&#x2F;虽然能得到对象，但是name属性并没有保存，因此为null\n    &#125;catch (IOException | ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\nstatic class People implements Serializable&#123;\n    private static final long serialVersionUID &#x3D; 1234567;\n\n    transient String name;\n\n    public People(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。\n\nJava I&#x2F;O编程实战图书管理系统要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。\n","slug":"JavaSE笔记（五）","date":"2022-03-09T03:42:02.632Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"57463bbf531fd357a773ee081e3f2258","title":"JavaSE笔记（四）","content":"Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。\n走进泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？\npublic class Score &#123;\n    String name;\n    String id;\n    Object score;  &#x2F;&#x2F;因为Object是所有类型的父类，因此既可以存放Integer也能存放String\n\n  \tpublic Score(String name, String id, Object score) &#123;\n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        this.score &#x3D; score;\n    &#125;\n&#125;\n\n以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：\npublic static void main(String[] args) &#123;\n\n    Score score &#x3D; new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);  &#x2F;&#x2F;是String类型的\n\n    &#x2F;&#x2F;....\n\n    Integer number &#x3D; (Integer) score.score;  &#x2F;&#x2F;获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错\n&#125;\n\n&#x2F;&#x2F;运行时出现异常！\nException in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.Main.main(Main.java:14)\n\n使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法）\n为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。\npublic class Score&lt;T&gt; &#123;   &#x2F;&#x2F;将Score转变为泛型类&lt;T&gt;\n    String name;\n    String id;\n    T score;  &#x2F;&#x2F;T为泛型，根据用户提供的类型自动变成对应类型\n\n    public Score(String name, String id, T score) &#123;   &#x2F;&#x2F;提供的score类型即为T代表的类型\n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        this.score &#x3D; score;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;直接确定Score的类型是字符串类型的成绩\n    Score&lt;String&gt; score &#x3D; new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);\n\n    Integer i &#x3D; score.score;  &#x2F;&#x2F;编译不通过，因为成员变量score类型被定为String！\n&#125;\n\n泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！\n泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全）\n&#x2F;&#x2F;反编译后的代码\npublic static void main(String[] args) &#123;\n        Score score &#x3D; new Score(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);\n        String i &#x3D; (String)score.score;   &#x2F;&#x2F;其实依然会变为强制类型转换，但是这是由编译器帮我们完成的\n    &#125;\n\n像这样在编译后泛型的内容消失转变为Object的情况称为类型擦除（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。\n综上，泛型其实就是一种类型参数，用于指定类型。\n泛型的使用泛型类上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是类型的英文单词首字母，当然也可以添加数字和其他的字符。\npublic class Score&lt;T&gt; &#123;   &#x2F;&#x2F;将Score转变为泛型类&lt;T&gt;\n    String name;\n    String id;\n    T score;  &#x2F;&#x2F;T为泛型，根据用户提供的类型自动变成对应类型\n\n    public Score(String name, String id, T score) &#123;   &#x2F;&#x2F;提供的score类型即为T代表的类型\n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        this.score &#x3D; score;\n    &#125;\n&#125;\n\n在一个普通类型中定义泛型，泛型T称为参数化类型，在定义泛型类的引用时，需要明确指出类型：\nScore&lt;String&gt; score &#x3D; new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);\n\n此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型：\nInteger i &#x3D; score.score;   &#x2F;&#x2F;编译不通过，因为成员变量score明确为String类型\n\n注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用：\nstatic T score;   &#x2F;&#x2F;错误，不能在静态成员上定义\n\n由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。\n泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！\nScore&lt;double&gt; score &#x3D; new Score&lt;double&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 90.5);  &#x2F;&#x2F;编译不通过\n\n那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。\n类的泛型方法泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可：\npublic T getScore() &#123;    &#x2F;&#x2F;若方法的返回值类型为泛型，那么编译器会自动进行推断\n  return score;\n&#125;\n\npublic void setScore(T score) &#123;   &#x2F;&#x2F;若方法的形式参数为泛型，那么实参只能是定义时的类型\n  this.score &#x3D; score;\n&#125;\n\nScore&lt;String&gt; score &#x3D; new Score&lt;String&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, &quot;优秀&quot;);\nscore.setScore(10);   &#x2F;&#x2F;编译不通过，因为只接受String类型\n\n同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型）\n自定义泛型方法那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义：\npublic static &lt;E&gt; void test(E e)&#123;   &#x2F;&#x2F;在方法定义前声明泛型\n  System.out.println(e);\n&#125;\n\n同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定：\npublic &lt;E&gt; void test(E e)&#123;\n  System.out.println(e);\n&#125;\n\n其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。\n注意一定要区分类定义的泛型和方法前定义的泛型！\n泛型引用可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型：\nScore&lt;Integer&gt; score;  &#x2F;&#x2F;声明泛型为Integer类型\n\n如果不希望指定类型，或是希望此引用类型可以引用任意泛型的Score类对象，可以使用?通配符，来表示自动匹配任意的可用类型：\nScore&lt;?&gt; score;   &#x2F;&#x2F;score可以引用任意的Score类型对象了！\n\n那么使用通配符之后，得到的泛型成员变量会是什么类型呢？\nObject o &#x3D; score.getScore();   &#x2F;&#x2F;只能变为Object\n\n因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。\n在学习了泛型的界限后，我们还会继续了解通配符的使用。\n泛型的界限现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：\npublic class Score&lt;T extends Number&gt; &#123;   &#x2F;&#x2F;设定泛型上界，必须是Number的子类\n    private final String name;\n    private final String id;\n    private T score;\n\n    public Score(String name, String id, T score) &#123;\n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        this.score &#x3D; score;\n    &#125;\n\n    public T getScore() &#123;\n        return score;\n    &#125;\n&#125;\n\n通过extends关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。\n同样的，泛型通配符也支持泛型的界限：\nScore&lt;? extends Number&gt; score;  &#x2F;&#x2F;限定为匹配Number及其子类的类型\n\n同理，既然泛型有上限，那么也有下限：\nScore&lt;? super Integer&gt; score;   &#x2F;&#x2F;限定为匹配Integer及其父类\n\n通过super关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。\n图解如下：\n\n\n那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？\nScore&lt;? extends Number&gt; score &#x3D; new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);\nNumber o &#x3D; score.getScore();    &#x2F;&#x2F;得到的结果为上界类型\n\n也就是说，一旦我们指定了上界后，编译器就将范围从原始类型Object提升到我们指定的上界Number，但是依然无法明确具体类型。思考：那如果定义下限呢？\n那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢：\n&#x2F;&#x2F;使用javap -l 进行反编译\npublic class com.test.Score&lt;T extends java.lang.Number&gt; &#123;\n  public com.test.Score(java.lang.String, java.lang.String, T);\n    LineNumberTable:\n      line 8: 0\n      line 9: 4\n      line 10: 9\n      line 11: 14\n      line 12: 19\n    LocalVariableTable:\n      Start  Length  Slot  Name   Signature\n          0      20     0  this   Lcom&#x2F;test&#x2F;Score;\n          0      20     1  name   Ljava&#x2F;lang&#x2F;String;\n          0      20     2    id   Ljava&#x2F;lang&#x2F;String;\n          0      20     3 score   Ljava&#x2F;lang&#x2F;Number;   &#x2F;&#x2F;可以看到score的类型直接被编译为Number类\n\n  public T getScore();\n    LineNumberTable:\n      line 15: 0\n    LocalVariableTable:\n      Start  Length  Slot  Name   Signature\n          0       5     0  this   Lcom&#x2F;test&#x2F;Score;\n&#125;\n\n\n因此，一旦确立上限后，编译器会自动将类型提升到上限类型。\n钻石运算符我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码：\nScore&lt;Integer&gt; score &#x3D; new Score&lt;Integer&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);  &#x2F;&#x2F;1.7之前\n\nScore&lt;Integer&gt; score &#x3D; new Score&lt;&gt;(&quot;数据结构与算法基础&quot;, &quot;EP074512&quot;, 10);  &#x2F;&#x2F;1.7之后\n\n泛型与多态泛型不仅仅可以可以定义在类上，同时也能定义在接口上：\npublic interface ScoreInterface&lt;T&gt; &#123;\n    T getScore();\n    void setScore(T t);\n&#125;\n\n当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。\npublic class Score&lt;T&gt; implements ScoreInterface&lt;T&gt;&#123;   &#x2F;&#x2F;将Score转变为泛型类&lt;T&gt;\n    private final String name;\n    private final String id;\n    private T score;\n\n    public Score(String name, String id, T score) &#123; \n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        this.score &#x3D; score;\n    &#125;\n\n    public T getScore() &#123;\n        return score;\n    &#125;\n\n    @Override\n    public void setScore(T score) &#123;\n        this.score &#x3D; score;\n    &#125;\n&#125;\n\npublic class StringScore implements ScoreInterface&lt;String&gt;&#123;   &#x2F;&#x2F;在实现时明确类型\n\n    @Override\n    public String getScore() &#123;\n        return null;\n    &#125;\n\n    @Override\n    public void setScore(String s) &#123;\n\n    &#125;\n&#125;\n\n抽象类同理，这里就不多做演示了。\n多态类型擦除思考一个问题，既然继承后明确了泛型类型，那么为什么@Override不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？\nclass A&lt;T&gt;&#123;\n    private T t;\n    public T get()&#123;\n        return t;\n    &#125;\n    public void set(T t)&#123;\n        this.t&#x3D;t;\n    &#125;\n&#125;\n\nclass B extends A&lt;Number&gt;&#123;\n    private Number n;\n\n    @Override\n    public Number get()&#123;   &#x2F;&#x2F;这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！\n        return t;\n    &#125;\n\n    @Override\n    public void set(Number t)&#123;\n        this.t&#x3D;t;\n    &#125;\n&#125;\n\n通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写：\n@Override\npublic Object get()&#123;\n  return this.get();&#x2F;&#x2F;调用返回Number的那个方法\n&#125;\n\n@Override\npublic void set(Object t )&#123;\n  this.set((Number)t ); &#x2F;&#x2F;调用参数是Number的那个方法\n&#125;\n\n\n数据结构基础警告！本章最难的部分！\n学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。\n在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。\n通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！\n线性表线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。\n顺序表将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构，而以这种方式实现的线性表，我们称为顺序表。\n同样的，表中的每一个个体都被称为元素，元素左边的元素（上一个元素），称为前驱，同理，右边的元素（后一个元素）称为后驱。\n\n我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。\n目标：以数组为底层，编写以下抽象类的具体实现\n&#x2F;**\n * 线性表抽象类\n * @param &lt;E&gt; 存储的元素(Element)类型\n *&#x2F;\npublic abstract class AbstractList&lt;E&gt; &#123;\n    &#x2F;**\n     * 获取表的长度\n     * @return 顺序表的长度\n     *&#x2F;\n    public abstract int size();\n\n    &#x2F;**\n     * 添加一个元素\n     * @param e 元素\n     * @param index 要添加的位置(索引)\n     *&#x2F;\n    public abstract void add(E e, int index);\n\n    &#x2F;**\n     * 移除指定位置的元素\n     * @param index 位置\n     * @return 移除的元素\n     *&#x2F;\n    public abstract E remove(int index);\n\n    &#x2F;**\n     * 获取指定位置的元素\n     * @param index 位置\n     * @return 元素\n     *&#x2F;\n    public abstract E get(int index);\n&#125;\n\n链表数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构\n实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象）\n\n利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！\n比较：顺序表和链表的优异？\n顺序表优缺点：\n\n访问速度快，随机访问性能高\n插入和删除的效率低下，极端情况下需要变更整个表\n不易扩充，需要复制并重新创建数组\n\n链表优缺点：\n\n插入和删除效率高，只需要改变连接点的指向即可\n动态扩充容量，无需担心容量问题\n访问元素需要依次寻找，随机访问元素效率低下\n\n链表只能指向后面，能不能指向前面呢？双向链表！\n\n栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！\n栈栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。\n\n向栈中插入一个元素时，称为入栈（压栈），移除栈顶元素称为出栈，我们需要尝试实现以下抽象类型：\n&#x2F;**\n * 抽象类型栈，待实现\n * @param &lt;E&gt; 元素类型\n *&#x2F;\npublic abstract class AbstractStack&lt;E&gt; &#123;\n\n    &#x2F;**\n     * 出栈操作\n     * @return 栈顶元素\n     *&#x2F;\n    public abstract E pop();\n\n    &#x2F;**\n     * 入栈操作\n     * @param e 元素\n     *&#x2F;\n    public abstract void push(E e);\n&#125;\n\n其实，我们的JVM在处理方法调用时，也是一个栈操作：\n\n所以说，如果玩不好递归，就会像这样：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        go();\n    &#125;\n\n    private static void go()&#123;\n        go();\n    &#125;\n&#125;\n\nException in thread &quot;main&quot; java.lang.StackOverflowError\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n\tat com.test.Main.go(Main.java:13)\n  ...\n\n栈的深度是有限制的，如果达到限制，将会出现StackOverflowError错误（注意是错误！说明是JVM出现了问题）\n队列队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。\n\n所以我们要实现以下内容：\n\n&#x2F;**\n *\n * @param &lt;E&gt;\n *&#x2F;\npublic abstract class AbstractQueue&lt;E&gt; &#123;\n\n    &#x2F;**\n     * 进队操作\n     * @param e 元素\n     *&#x2F;\n    public abstract void offer(E e);\n\n    &#x2F;**\n     * 出队操作\n     * @return 元素\n     *&#x2F;\n    public abstract E poll();\n&#125;\n\n\n\n二叉树本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。\n树我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。\n\n一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为根结点，而结点拥有的子节点数量称为度，每向下一级称为一个层次，树中出现的最大层次称为树的深度(高度)。\n二叉树二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右）\n\n数学性质：\n\n在二叉树的第i层上最多有2^(i-1) 个节点。\n二叉树中如果深度为k，那么最多有2^k-1个节点。\n\n设计一个二叉树结点类：\npublic class TreeNode&lt;E&gt; &#123;\n    public E e;   &#x2F;&#x2F;当前结点数据\n    public TreeNode&lt;E&gt; left;   &#x2F;&#x2F;左子树\n    public TreeNode&lt;E&gt; right;   &#x2F;&#x2F;右子树\n&#125;\n\n二叉树的遍历顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式：\n\n前序遍历：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF\n中序遍历：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF\n后序遍历：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA\n\n满二叉树和完全二叉树满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。\n\n其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。\n快速查找我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？\n哈希表通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！\n不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做hashcode()的方法？而这个方法呢，就是为了更好地支持哈希表的实现。hashcode()默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。\n哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样：\n\n数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。\n&#x2F;&#x2F;假设hash表长度为16，hash算法为：\nprivate int hash(int hashcode)&#123;\n  return hashcode % 16;\n&#125;\n\n设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为hash碰撞，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。\n当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲）\n二叉排序树我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样：\n\n不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为二叉排序树。利用二分搜索的思想，我们就可以快速查找某个节点！\n平衡二叉树在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样：\n\n显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。\n现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况：\n\n左左失衡\n\n右右失衡\n\n左右失衡\n\n右左失衡\n通过以上四种情况的处理，最终得到维护平衡二叉树的算法。\n红黑树红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！\n\n红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n我们来看看一个节点，是如何插入到红黑树中的：\n基本的 插入规则和平衡二叉树一样，但是在插入后：\n\n将新插入的节点标记为红色\n如果 X 是根结点(root)，则标记为黑色\n如果 X 的 parent 不是黑色，同时 X 也不是 root:\n\n\n3.1 如果 X 的 uncle (叔叔) 是红色\n\n\n3.1.1 将 parent 和 uncle 标记为黑色\n3.1.2 将 grand parent (祖父) 标记为红色\n3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3\n\n\n3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理\n\n\n3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)\n3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)\n3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子)\n3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子)\n其实这种情况下处理就和我们的平衡二叉树一样了\n\n\n\n\n认识集合类集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。\n集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。\n集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。\n\n数组与集合相同之处：\n\n它们都是容器，都能够容纳一组元素。\n\n不同之处：\n\n数组的大小是固定的，集合的大小是可变的。\n数组可以存放基本数据类型，但集合只能存放对象。\n数组存放的类型只能是一种，但集合可以有不同种类的元素。\n\n集合根接口Collection本接口中定义了全部的集合基本操作，我们可以在源码中看看。\n我们再来看看List和Set以及Queue接口。\n集合类的使用List列表首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。\n先看看ArrayList的源码！\n基本操作List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();  &#x2F;&#x2F;默认长度的列表\nList&lt;String&gt; listInit &#x3D; new ArrayList&lt;&gt;(100);  &#x2F;&#x2F;初始长度为100的列表\n\n向列表中添加元素：\nList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(&quot;lbwnb&quot;);\nlist.add(&quot;yyds&quot;);\nlist.contains(&quot;yyds&quot;); &#x2F;&#x2F;是否包含某个元素\nSystem.out.println(list);\n\n移除元素：\npublic static void main(String[] args) &#123;\n    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(&quot;lbwnb&quot;);\n    list.add(&quot;yyds&quot;);\n    list.remove(0);   &#x2F;&#x2F;按下标移除元素\n    list.remove(&quot;yyds&quot;);    &#x2F;&#x2F;移除指定元素\n    System.out.println(list);\n&#125;\n\n也支持批量操作：\npublic static void main(String[] args) &#123;\n    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.addAll(new ArrayList&lt;&gt;());   &#x2F;&#x2F;在尾部批量添加元素\n    list.removeAll(new ArrayList&lt;&gt;());   &#x2F;&#x2F;批量移除元素（只有给定集合中存在的元素才会被移除）\n    list.retainAll(new ArrayList&lt;&gt;());   &#x2F;&#x2F;只保留某些元素\n    System.out.println(list);\n&#125;\n\n我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。\n其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表：\nprivate static class Node&lt;E&gt; &#123;\n    E item;\n    Node&lt;E&gt; next;\n    Node&lt;E&gt; prev;\n\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item &#x3D; element;\n        this.next &#x3D; next;\n        this.prev &#x3D; prev;\n    &#125;\n&#125;\n\n当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。\npublic static void main(String[] args) &#123;\n    LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    list.offer(&quot;A&quot;);   &#x2F;&#x2F;入队\n    System.out.println(list.poll());  &#x2F;&#x2F;出队\n    list.push(&quot;A&quot;);\n    list.push(&quot;B&quot;);    &#x2F;&#x2F;进栈\n    list.push(&quot;C&quot;);\n    System.out.println(list.pop());\n    System.out.println(list.pop());    &#x2F;&#x2F;出栈\n    System.out.println(list.pop());\n&#125;\n\n利用代码块来快速添加内容前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List\nList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;()&#123;&#123;    &#x2F;&#x2F;初始化时添加\n  this.add(&quot;A&quot;);\n  this.add(&quot;B&quot;);\n&#125;&#125;;\n\n如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。\n集合的排序List&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;()&#123;   &#x2F;&#x2F;Java9才支持匿名内部类使用钻石运算符\n    &#123;\n        this.add(10);\n        this.add(2);\n        this.add(5);\n        this.add(8);\n    &#125;\n&#125;;\nlist.sort((a, b) -&gt; &#123;    &#x2F;&#x2F;排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现\n  return a - b;    &#x2F;&#x2F;返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换\n&#125;);\nSystem.out.println(list);\n\n迭代器集合的遍历所有的集合类，都支持foreach循环！\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;()&#123;   &#x2F;&#x2F;Java9才支持匿名内部类使用钻石运算符\n        &#123;\n            this.add(10);\n            this.add(2);\n            this.add(5);\n            this.add(8);\n        &#125;\n    &#125;;\n    for (Integer integer : list) &#123;\n        System.out.println(integer);\n    &#125;\n&#125;\n\n当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现：\nlist.forEach(i -&gt; &#123;\n    System.out.println(i);\n&#125;);\n\n从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。\nlist.replaceAll((i) -&gt; &#123;\n  if(i &#x3D;&#x3D; 2) return 3;   &#x2F;&#x2F;将所有的2替换为3\n  else return i;   &#x2F;&#x2F;不是2就不变\n&#125;);\nSystem.out.println(list);\n\nIterable和Iterator接口我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。\n由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。\n我们先来看看迭代器里面方法：\npublic interface Iterator&lt;E&gt; &#123;\n  &#x2F;&#x2F;...\n&#125;\n\n每个集合类都有自己的迭代器，通过iterator()方法来获取：\nIterator&lt;Integer&gt; iterator &#x3D; list.iterator();   &#x2F;&#x2F;生成一个新的迭代器\nwhile (iterator.hasNext())&#123;    &#x2F;&#x2F;判断是否还有下一个元素\n  Integer i &#x3D; iterator.next();     &#x2F;&#x2F;获取下一个元素（获取一个少一个）\n  System.out.println(i);\n&#125;\n\n迭代器生成后，默认指向第一个元素，每次调用next()方法，都会将指针后移，当指针移动到最后一个元素之后，调用hasNext()将会返回false，迭代器是一次性的，用完即止，如果需要再次使用，需要调用iterator()方法。\nListIterator&lt;Integer&gt; iterator &#x3D; list.listIterator();   &#x2F;&#x2F;List还有一个更好地迭代器实现ListIterator\n\nListIterator是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。\n\nSet集合我们之前已经看过Set接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。\nSet集合特点：\n\n不允许出现重复元素\n不支持随机访问（不允许通过下标访问）\n\n首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论）\npublic static void main(String[] args) &#123;\n    HashSet&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;();\n    set.add(120);    &#x2F;&#x2F;支持插入元素，但是不支持指定位置插入\n    set.add(13);\n    set.add(11);\n    for (Integer integer : set) &#123;\n      System.out.println(integer);\n    &#125;\n&#125;\n\n运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用哈希表来实现的，实际的存放顺序是由Hash算法决定的。\n那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet：\npublic static void main(String[] args) &#123;\n    LinkedHashSet&lt;Integer&gt; set &#x3D; new LinkedHashSet&lt;&gt;();  &#x2F;&#x2F;会自动保存我们的插入顺序\n    set.add(120);\n    set.add(13);\n    set.add(11);\n    for (Integer integer : set) &#123;\n        System.out.println(integer);\n    &#125;\n&#125;\n\nLinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。\n还有一种Set叫做TreeSet，它会在元素插入时进行排序：\npublic static void main(String[] args) &#123;\n    TreeSet&lt;Integer&gt; set &#x3D; new TreeSet&lt;&gt;();\n    set.add(1);\n    set.add(3);\n    set.add(2);\n    System.out.println(set);\n&#125;\n\n可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：\npublic static void main(String[] args) &#123;\n    TreeSet&lt;Integer&gt; set &#x3D; new TreeSet&lt;&gt;((a, b) -&gt; b - a);   &#x2F;&#x2F;在创建对象时指定规则即可\n    set.add(1);\n    set.add(3);\n    set.add(2);\n    System.out.println(set);\n&#125;\n\n现在的结果就是我们自定义的排序规则了。\n虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。\n\nMap映射什么是映射我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。\n\nMap接口Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。\n我们先来看看Map接口中定义了哪些操作。\nHashMap和LinkedHashMapHashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样：\n\n哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。\n而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构：\n&#x2F;**\n * The table, initialized on first use, and resized as\n * necessary. When allocated, length is always a power of two.\n * (We also tolerate length zero in some operations to allow\n * bootstrapping mechanics that are currently not needed.)\n *&#x2F;\ntransient Node&lt;K,V&gt;[] table;\n\n这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！\n&#x2F;**\n * The default initial capacity - MUST be a power of two.\n *&#x2F;\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n\n我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。\n我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？\n&#x2F;**\n * The load factor for the hash table.\n *\n * @serial\n *&#x2F;\nfinal float loadFactor;\n\n我们还发现HashMap源码中有这样一个变量，也就是负载因子，那么它是干嘛的呢？\n负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是0.75\n&#x2F;**\n * The load factor used when none specified in constructor.\n *&#x2F;\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n\n那么负载因子是怎么控制扩容的呢？0.75的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。\n但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。\n\n当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。\n&#x2F;**\n * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn\n * extends Node) so can be used as extension of either regular or\n * linked node.\n *&#x2F;\nstatic final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;\n\n除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。\n&#x2F;**\n * HashMap.Node subclass for normal LinkedHashMap entries.\n *&#x2F;\nstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n    Entry&lt;K,V&gt; before, after;\n    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        super(hash, key, value, next);\n    &#125;\n&#125;\n\nLinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。\npublic static void main(String[] args) &#123;\n    LinkedHashMap&lt;Integer, String&gt; map &#x3D; new LinkedHashMap&lt;&gt;(16, 0.75f, true);  &#x2F;&#x2F;以访问顺序\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.put(3, &quot;C&quot;);\n    map.get(2);\n    System.out.println(map);\n&#125;\n\n观察结果，我们发现，刚访问的结果被排到了最后一位。\nTreeMapTreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样：\n&#x2F;**\n * The comparator used to maintain order in this tree map, or\n * null if it uses the natural ordering of its keys.\n *\n * @serial\n *&#x2F;\nprivate final Comparator&lt;? super K&gt; comparator;\n\nprivate transient Entry&lt;K,V&gt; root;\n\n&#x2F;**\n* Node in the Tree.  Doubles as a means to pass key-value pairs back to\n* user (see Map.Entry).\n*&#x2F;\n\nstatic final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n\n我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。\nMap的使用我们首先来看看Map的一些基本操作：\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.put(3, &quot;C&quot;);\n    System.out.println(map.get(1));    &#x2F;&#x2F;获取Key为1的值\n    System.out.println(map.getOrDefault(0, &quot;K&quot;));  &#x2F;&#x2F;不存在就返回K\n   \tmap.remove(1);   &#x2F;&#x2F;移除这个Key的键值对\n&#125;\n\n由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用：\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.put(3, &quot;C&quot;);\n    map.forEach((k, v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));\n  \n  \tfor (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   &#x2F;&#x2F;也可以获取所有的Entry来foreach\n      int key &#x3D; entry.getKey();\n      String value &#x3D; entry.getValue();\n      System.out.println(key+&quot; -&gt; &quot;+value);\n    &#125;\n&#125;\n\n我们也可以单独获取所有的值或者是键：\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.put(3, &quot;C&quot;);\n    System.out.println(map.keySet());   &#x2F;&#x2F;直接获取所有的key\n    System.out.println(map.values());   &#x2F;&#x2F;直接获取所有的值\n&#125;\n\n再谈Set原理通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！\n&#x2F;&#x2F; Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT &#x3D; new Object();\n\n我们发现，在添加元素时，其实添加的是一个键为我们插入的元素，而值就是PRESENT常量：\n&#x2F;**\n * Adds the specified element to this set if it is not already present.\n * More formally, adds the specified element &lt;tt&gt;e&lt;&#x2F;tt&gt; to this set if\n * this set contains no element &lt;tt&gt;e2&lt;&#x2F;tt&gt; such that\n * &lt;tt&gt;(e&#x3D;&#x3D;null&amp;nbsp;?&amp;nbsp;e2&#x3D;&#x3D;null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;&#x2F;tt&gt;.\n * If this set already contains the element, the call leaves the set\n * unchanged and returns &lt;tt&gt;false&lt;&#x2F;tt&gt;.\n *\n * @param e element to be added to this set\n * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this set did not already contain the specified\n * element\n *&#x2F;\npublic boolean add(E e) &#123;\n    return map.put(e, PRESENT)&#x3D;&#x3D;null;\n&#125;\n\n观察其他的方法，也几乎都是在用HashMap做事，所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！\n再来看TreeSet，实际上用的就是我们的TreeMap：\n&#x2F;**\n * The backing map.\n *&#x2F;\nprivate transient NavigableMap&lt;E,Object&gt; m;\n\n同理，这里就不多做阐述了。\nJDK1.8新增方法使用最后，我们再来看看JDK1.8中集合类新增的一些操作（之前没有提及的）首先来看看compute方法：\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.compute(1, (k, v) -&gt; &#123;   &#x2F;&#x2F;compute会将指定Key的值进行重新计算，若Key不存在，v会返回null\n        return v+&quot;M&quot;;     &#x2F;&#x2F;这里返回原来的value+M\n    &#125;);\n  \tmap.computeIfPresent(1, (k, v) -&gt; &#123;   &#x2F;&#x2F;当Key存在时存在则计算并赋予新的值\n      return v+&quot;M&quot;;     &#x2F;&#x2F;这里返回原来的value+M\n    &#125;);\n    System.out.println(map);\n&#125;\n\n也可以使用computeIfAbsent，当不存在Key时，计算并将键值对放入Map\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();\n    map.put(1, &quot;A&quot;);\n    map.put(2, &quot;B&quot;);\n    map.computeIfAbsent(0, (k) -&gt; &#123;   &#x2F;&#x2F;若不存在则计算并插入新的值\n        return &quot;M&quot;;     &#x2F;&#x2F;这里返回M\n    &#125;);\n    System.out.println(map);\n&#125;\n\nmerge方法用于处理数据：\npublic static void main(String[] args) &#123;\n    List&lt;Student&gt; students &#x3D; Arrays.asList(\n            new Student(&quot;yoni&quot;, &quot;English&quot;, 80),\n            new Student(&quot;yoni&quot;, &quot;Chiness&quot;, 98),\n            new Student(&quot;yoni&quot;, &quot;Math&quot;, 95),\n            new Student(&quot;taohai.wang&quot;, &quot;English&quot;, 50),\n            new Student(&quot;taohai.wang&quot;, &quot;Chiness&quot;, 72),\n            new Student(&quot;taohai.wang&quot;, &quot;Math&quot;, 41),\n            new Student(&quot;Seely&quot;, &quot;English&quot;, 88),\n            new Student(&quot;Seely&quot;, &quot;Chiness&quot;, 89),\n            new Student(&quot;Seely&quot;, &quot;Math&quot;, 92)\n    );\n    Map&lt;String, Integer&gt; scoreMap &#x3D; new HashMap&lt;&gt;();\n    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));\n    scoreMap.forEach((k, v) -&gt; System.out.println(&quot;key:&quot; + k + &quot;总分&quot; + &quot;value:&quot; + v));\n&#125;\n\nstatic class Student &#123;\n    private final String name;\n    private final String type;\n    private final int score;\n\n    public Student(String name, String type, int score) &#123;\n        this.name &#x3D; name;\n        this.type &#x3D; type;\n        this.score &#x3D; score;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public int getScore() &#123;\n        return score;\n    &#125;\n\n    public String getType() &#123;\n        return type;\n    &#125;\n&#125;\n\n\n集合的嵌套既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？\npublic static void main(String[] args) &#123;\n    Map&lt;String, List&lt;Integer&gt;&gt; map &#x3D; new HashMap&lt;&gt;();   &#x2F;&#x2F;每一个映射都是 字符串&lt;-&gt;列表\n    map.put(&quot;卡布奇诺今犹在&quot;, new LinkedList&lt;&gt;());\n    map.put(&quot;不见当年倒茶人&quot;, new LinkedList&lt;&gt;());\n    System.out.println(map.keySet());\n    System.out.println(map.values());\n&#125;\n\n通过Key获取到对应的值后，就是一个列表：\nmap.get(&quot;卡布奇诺今犹在&quot;).add(10);\nSystem.out.println(map.get(&quot;卡布奇诺今犹在&quot;).get(0));\n\n让套娃继续下去：\npublic static void main(String[] args) &#123;\n    Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map &#x3D; new HashMap&lt;&gt;();\n&#125;\n\n你也可以使用List来套娃别的：\npublic static void main(String[] args) &#123;\n    List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list &#x3D; new LinkedList&lt;&gt;();\n&#125;\n\n流Stream和Optional的使用Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。\n\n它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：\npublic static void main(String[] args) &#123;\n    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(&quot;A&quot;);\n    list.add(&quot;B&quot;);\n    list.add(&quot;C&quot;);\n  \n  \t&#x2F;&#x2F;移除为B的元素\n  \tIterator&lt;String&gt; iterator &#x3D; list.iterator();\n        while (iterator.hasNext())&#123;\n            if(iterator.next().equals(&quot;B&quot;)) iterator.remove();\n        &#125;\n  \n  \t&#x2F;&#x2F;Stream操作\n    list &#x3D; list     &#x2F;&#x2F;链式调用\n            .stream()    &#x2F;&#x2F;获取流\n            .filter(e -&gt; !e.equals(&quot;B&quot;))   &#x2F;&#x2F;只允许所有不是B的元素通过流水线\n            .collect(Collectors.toList());   &#x2F;&#x2F;将流水线中的元素重新收集起来，变回List\n    System.out.println(list);\n&#125;\n\n可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n  \tlist.add(3);\n\n    list &#x3D; list\n            .stream()\n      \t\t\t.distinct()   &#x2F;&#x2F;去重（使用equals判断）\n            .sorted((a, b) -&gt; b - a)    &#x2F;&#x2F;进行倒序排列\n            .map(e -&gt; e+1)    &#x2F;&#x2F;每个元素都要执行+1操作\n            .limit(2)    &#x2F;&#x2F;只放行前两个元素\n            .collect(Collectors.toList());\n\n    System.out.println(list);\n&#125;\n\n当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）\n注意：不能认为每一步是直接依次执行的！\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(3);\n\nlist &#x3D; list\n        .stream()\n        .distinct()   &#x2F;&#x2F;断点\n        .sorted((a, b) -&gt; b - a)\n        .map(e -&gt; &#123;\n            System.out.println(&quot;&gt;&gt;&gt; &quot;+e);   &#x2F;&#x2F;断点\n            return e+1;\n        &#125;)\n        .limit(2)   &#x2F;&#x2F;断点\n        .collect(Collectors.toList());\n&#x2F;&#x2F;实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！\n\n接下来，我们用一堆随机数来进行更多流操作的演示：\npublic static void main(String[] args) &#123;\n    Random random &#x3D; new Random();  &#x2F;&#x2F;Random是一个随机数工具类\n    random\n            .ints(-100, 100)   &#x2F;&#x2F;生成-100~100之间的，随机int型数字（本质上是一个IntStream）\n            .limit(10)   &#x2F;&#x2F;只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）\n            .filter(i -&gt; i &lt; 0)   &#x2F;&#x2F;只保留小于0的数字\n            .sorted()    &#x2F;&#x2F;默认从小到大排序\n            .forEach(System.out::println);   &#x2F;&#x2F;依次打印\n&#125;\n\n我们可以生成一个统计实例来帮助我们快速进行统计：\npublic static void main(String[] args) &#123;\n    Random random &#x3D; new Random();  &#x2F;&#x2F;Random是一个随机数工具类\n    IntSummaryStatistics statistics &#x3D; random\n            .ints(0, 100)\n            .limit(100)\n            .summaryStatistics();    &#x2F;&#x2F;获取语法统计实例\n    System.out.println(statistics.getMax());  &#x2F;&#x2F;快速获取最大值\n    System.out.println(statistics.getCount());  &#x2F;&#x2F;获取数量\n    System.out.println(statistics.getAverage());   &#x2F;&#x2F;获取平均值\n&#125;\n\n普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    list.add(4);\n    list.stream()\n            .mapToInt(i -&gt; i)    &#x2F;&#x2F;将每一个元素映射为Integer类型（这里因为本来就是Integer）\n            .summaryStatistics();\n&#125;\n\n我们还可以通过flat来对整个流进行进一步细分：\npublic static void main(String[] args) &#123;\n    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(&quot;A,B&quot;);\n    list.add(&quot;C,D&quot;);\n    list.add(&quot;E,F&quot;);   &#x2F;&#x2F;我们想让每一个元素通过,进行分割，变成独立的6个元素\n    list &#x3D; list\n            .stream()    &#x2F;&#x2F;生成流\n            .flatMap(e -&gt; Arrays.stream(e.split(&quot;,&quot;)))    &#x2F;&#x2F;分割字符串并生成新的流\n            .collect(Collectors.toList());   &#x2F;&#x2F;汇成新的List\n    System.out.println(list);   &#x2F;&#x2F;得到结果\n&#125;\n\n我们也可以只通过Stream来完成所有数字的和，使用reduce方法：\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    int sum &#x3D; list\n            .stream()\n            .reduce((a, b) -&gt; a + b)   &#x2F;&#x2F;计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和\n            .get();    &#x2F;&#x2F;我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值\n    System.out.println(sum);\n&#125;\n\n通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？\nOptional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。\npublic static void main(String[] args) &#123;\n    String str &#x3D; null;\n    if(str !&#x3D; null)&#123;   &#x2F;&#x2F;当str不为空时添加元素到List中\n        list.add(str);\n    &#125;\n&#125;\n\n有了Optional之后，我们就可以这样写：\npublic static void main(String[] args) &#123;\n    String str &#x3D; null;\n    Optional&lt;String&gt; optional &#x3D; Optional.ofNullable(str);   &#x2F;&#x2F;转换为Optional\n    optional.ifPresent(System.out::println);  &#x2F;&#x2F;当存在时再执行方法\n&#125;\n\n就类似于Kotlin中的：\nvar str : String? &#x3D; null\nstr?.upperCase()\n\n我们可以选择直接get或是当值为null时，获取备选值：\npublic static void main(String[] args) &#123;\n    String str &#x3D; null;\n    Optional optional &#x3D; Optional.ofNullable(str);   &#x2F;&#x2F;转换为Optional（可空）\n    System.out.println(optional.orElse(&quot;lbwnb&quot;));\n \t\t&#x2F;&#x2F; System.out.println(optional.get());   这样会直接报错\n&#125;\n\n同样的，Optional也支持过滤操作和映射操作，不过是对于单对象而言：\npublic static void main(String[] args) &#123;\n    String str &#x3D; &quot;A&quot;;\n    Optional optional &#x3D; Optional.ofNullable(str);   &#x2F;&#x2F;转换为Optional（可空）\n    System.out.println(optional.filter(s -&gt; s.equals(&quot;B&quot;)).get());   &#x2F;&#x2F;被过滤了，此时元素为null，获取时报错\n&#125;\n\npublic static void main(String[] args) &#123;\n    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    String str &#x3D; &quot;A&quot;;\n    Optional optional &#x3D; Optional.ofNullable(str);   &#x2F;&#x2F;转换为Optional（可空）\n    System.out.println(optional.map(s -&gt; s + &quot;A&quot;).get());   &#x2F;&#x2F;在尾部追加一个A\n&#125;\n\n其他操作自学了解。\nArrays和Collections的使用Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法：\n&#x2F;**\n * This class contains various methods for manipulating arrays (such as\n * sorting and searching). This class also contains a static factory\n * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键\n *\n * @author Josh Bloch\n * @author Neal Gafter\n * @author John Rose\n * @since  1.2\n *&#x2F;\npublic class Arrays &#123;\n\n由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如：\npublic static void main(String[] args) &#123;\n    int[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    Arrays.sort(array);   &#x2F;&#x2F;直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速&#x2F;归并排序）\n    System.out.println(array);  &#x2F;&#x2F;由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果\n    System.out.println(Arrays.toString(array));  &#x2F;&#x2F;我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来\n&#125;\n\npublic static void main(String[] args) &#123;\n    int[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    Arrays.sort(array);\n    System.out.println(&quot;排序后的结果：&quot;+Arrays.toString(array));\n    System.out.println(&quot;目标元素3位置为：&quot;+Arrays.binarySearch(array, 3));  &#x2F;&#x2F;二分搜素，必须是已经排序好的数组！\n&#125;\n\npublic static void main(String[] args) &#123;\n    int[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    Arrays\n            .stream(array)    &#x2F;&#x2F;将数组转换为流进行操作\n            .sorted()\n            .forEach(System.out::println);\n&#125;\n\npublic static void main(String[] args) &#123;\n    int[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    int[] array2 &#x3D; Arrays.copyOf(array, array.length);  &#x2F;&#x2F;复制一个一模一样的数组\n    System.out.println(Arrays.toString(array2));\n\n    System.out.println(Arrays.equals(array, array2));  &#x2F;&#x2F;比较两个数组是否值相同\n\n    Arrays.fill(array, 0);   &#x2F;&#x2F;将数组的所有值全部填充为指定值\n    System.out.println(Arrays.toString(array));\n\n    Arrays.setAll(array2, i -&gt; array2[i] + 2);  &#x2F;&#x2F;依次计算每一个元素（注意i是下标位置）\n    System.out.println(Arrays.toString(array2));   &#x2F;&#x2F;这里计算让每个元素值+2\n&#125;\n\n思考：当二维数组使用Arrays.equals()进行比较以及Arrays.toString()进行打印时，还会得到我们想要的结果吗？\npublic static void main(String[] args) &#123;\n    Integer[][] array &#x3D; &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;;\n    Integer[][] array2 &#x3D; &#123;&#123;1, 5&#125;, &#123;2, 4&#125;, &#123;7, 3&#125;, &#123;6&#125;&#125;;\n    System.out.println(Arrays.toString(array));    &#x2F;&#x2F;这样还会得到我们想要的结果吗？\n    System.out.println(Arrays.equals(array2, array));    &#x2F;&#x2F;这样还会得到true吗？\n\n    System.out.println(Arrays.deepToString(array));   &#x2F;&#x2F;使用deepToString就能到打印多维数组\n    System.out.println(Arrays.deepEquals(array2, array));   &#x2F;&#x2F;使用deepEquals就能比较多维数组\n&#125;\n\n那么，一开始提到的当做List进行操作呢？我们可以使用Arrays.asList()来将数组转换为一个 固定长度的List\npublic static void main(String[] args) &#123;\n    Integer[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    List&lt;Integer&gt; list &#x3D; Arrays.asList(array);   &#x2F;&#x2F;不支持基本类型数组，必须是对象类型数组\n    Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);  &#x2F;&#x2F;也可以逐个添加，因为是可变参数\n\n    list.add(1);    &#x2F;&#x2F;此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作\n    list.remove(0);   &#x2F;&#x2F;同理，也不支持移除\n\n    list.set(0, 8);   &#x2F;&#x2F;直接设置指定下标的值就可以\n    list.sort(Comparator.reverseOrder());   &#x2F;&#x2F;也可以执行排序操作\n    System.out.println(list);   &#x2F;&#x2F;也可以像List那样直接打印\n&#125;\n\n文字游戏：allows arrays to be viewed as lists，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样：\npublic static void main(String[] args) &#123;\n    Integer[] array &#x3D; &#123;1, 5, 2, 4, 7, 3, 6&#125;;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(array));\n&#125;\n\n通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。\n既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类：\npublic static void main(String[] args) &#123;\n    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n    Collections.max(list);\n    Collections.min(list);\n&#125;\n\n当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。\n\n集合类编程实战反转链表1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9  转换为 1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9\n现在有一个单链表，尝试将其所有节点倒序排列\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Node head &#x3D; new Node(1);\n        head.next &#x3D; new Node(3);\n        head.next.next &#x3D; new Node(5);\n        head.next.next.next &#x3D; new Node(7);\n        head.next.next.next.next &#x3D; new Node(9);\n\n        head &#x3D; reverse(head);\n\n        while (head !&#x3D; null)&#123;\n            System.out.println(head.value+&quot; &quot;);\n            head &#x3D; head.next;\n        &#125;\n    &#125;\n\n    public static class Node &#123;\n        public int value;\n        public Node next;\n\n        public Node(int data) &#123;\n            this.value &#x3D; data;\n        &#125;\n    &#125;\n\n    public static Node reverse(Node head) &#123;\n        &#x2F;&#x2F;在这里实现\n    &#125;\n&#125;\n\n重建二叉树现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。\n\n实现计算器实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3&#x2F;1.321，得到结果为：2.2\n字符串匹配（KMP算法）现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。\n","slug":"JavaSE笔记（四）","date":"2022-03-09T03:41:58.359Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"3acd6dd0df5d1947dcaf1fc3fec39ce8","title":"JavaSE笔记（三）","content":"Java异常机制在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？\npublic static void main(String[] args) &#123;\n    test(1, 0);   &#x2F;&#x2F;当b为0的时候，还能正常运行吗？\n&#125;\n\nprivate static int test(int a, int b)&#123;\n    return a&#x2F;b;   &#x2F;&#x2F;没有任何的判断而是直接做计算\n&#125;\n\nException in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero\n\tat com.test.Application.test(Application.java:9)\n\tat com.test.Application.main(Application.java:5)\n\n当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！\n异常我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自Exception类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！\n运行时异常异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常。所有的运行时异常都继承自RuntimeException。\n编译时异常异常的另一种类型是编译时异常，编译时异常是明确会出现的异常，在编译阶段就需要进行处理的异常（捕获异常）如果不进行处理，将无法通过编译！默认继承自Exception类的异常都是编译时异常。\nFile file &#x3D; new File(&quot;my.txt&quot;);\nfile.createNewFile();   &#x2F;&#x2F;要调用此方法，首先需要处理异常\n\n错误错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如OutOfMemoryError就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）\nint[] arr &#x3D; new int[Integer.MAX_VALUE];   &#x2F;&#x2F;能创建如此之大的数组吗？\n\n运行后得到以下内容：\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit\n\tat com.test.Main.main(Main.java:14)\n\n错误都继承自Error类，一般情况下，程序中只能处理异常，错误是很难进行处理的，Error和Execption都继承自Throwable类。当程序中出现错误或异常时又没有进行处理时，程序（当前线程）将终止运行：\nint[] arr &#x3D; new int[Integer.MAX_VALUE];\nSystem.out.println(&quot;lbwnb&quot;);  &#x2F;&#x2F;还能正常打印吗？\n\n异常的处理当程序没有按照我们想要的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息），我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：\nint[] arr &#x3D; new int[5];\narr[5] &#x3D; 1;  &#x2F;&#x2F;我们需要处理这种情况，保证后面的代码正常运行！\nSystem.out.println(&quot;lbwnb&quot;);\n\n我们可以使用try和catch语句块来处理：\nint[] arr &#x3D; new int[5];\ntry&#123;    &#x2F;&#x2F;在try块中运行代码\n     arr[5] &#x3D; 1;    &#x2F;&#x2F;当代码出现异常时，异常会被捕获，并在catch块中得到异常类型的对象\n&#125;catch (ArrayIndexOutOfBoundsException e)&#123;   &#x2F;&#x2F;捕获的异常类型\n     System.out.println(&quot;程序运行出现异常！&quot;);  &#x2F;&#x2F;出现异常时执行\n&#125;\n&#x2F;&#x2F;后面的代码会正常运行\nSystem.out.println(&quot;lbwnb&quot;);\n\n当异常被捕获后，就由我们自己进行处理（不再交给JVM处理），因此就不会导致程序终止运行。\n我们可以通过使用e.printStackTrace()来打印栈追踪信息，定位我们的异常出现位置：\njava.lang.ArrayIndexOutOfBoundsException: 5\n\tat com.test.Main.main(Main.java:7)    &#x2F;&#x2F;Main类的第7行出现问题\n程序运行出现异常！\nlbwnb\n\n运行时异常在编译时可以不用捕获，但是编译时异常必须进行处理：\nFile file &#x3D; new File(&quot;my.txt&quot;);\ntry &#123;\n  file.createNewFile();\n&#125; catch (IOException e) &#123;  &#x2F;&#x2F;捕获声明的异常类型\n  e.printStackTrace();\n&#125;\n\n可以捕获到类型不止是Exception的子类，只要是继承自Throwalbe的类，都能被捕获，也就是说，Error也能被捕获，但是不建议这样做，因为错误一般是虚拟机相关的问题，出现Error应该从问题的根源去解决。\n异常的抛出当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就需要手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：\npublic static void main(String[] args) &#123;\n        try &#123;\n            test(1, 0);\n        &#125; catch (Exception e) &#123;   &#x2F;&#x2F;捕获方法中会出现的异常\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    private static int test(int a, int b) throws Exception &#123;  &#x2F;&#x2F;声明抛出的异常类型\n        if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);  &#x2F;&#x2F;创建异常对象并抛出异常\n        return a&#x2F;b;  &#x2F;&#x2F;抛出异常会终止代码运行\n    &#125;\n\n通过throw关键字抛出异常（抛出异常后，后面的代码不再执行）当程序运行到这一行时，就会终止执行，并出现一个异常。\n如果方法中抛出了非运行时异常，但是不希望在此方法内处理，而是交给调用者来处理异常，就需要在方法定义后面显式声明抛出的异常类型！如果抛出的是运行时异常，则不需要在方法后面声明异常类型，调用时也无需捕获，但是出现异常时同样会导致程序终止（出现运行时异常同时未被捕获会默认交给JVM处理，也就是直接中止程序并在控制台打印栈追踪信息）\n如果想要调用声明编译时异常的方法，但是依然不想去处理，可以同样的在方法上声明throws来继续交给上一级处理。\npublic static void main(String[] args) throws Exception &#123;  &#x2F;&#x2F;出现异常就再往上抛，而不是在此方法内处理\n  test(1, 0);\n&#125;\n\nprivate static int test(int a, int b) throws Exception &#123;  &#x2F;&#x2F;声明抛出的异常类型\n  if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);  &#x2F;&#x2F;创建异常对象并抛出异常      \n  return a&#x2F;b;  \n&#125;\n\n当main方法都声明抛出异常时，出现异常就由JVM进行处理，也就是默认的处理方式（直接中止程序并在控制台打印栈追踪信息）\n异常只能被捕获一次，当异常捕获出现嵌套时，只会在最内层被捕获：\npublic static void main(String[] args) throws Exception &#123;\n        try&#123;\n            test(1, 0);\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;外层&quot;);\n        &#125;\n    &#125;\n\n    private static int test(int a, int b)&#123;\n        try&#123;\n            if(b &#x3D;&#x3D; 0) throw new Exception(&quot;0不能做除数！&quot;);\n        &#125;catch (Exception e)&#123;\n            System.out.println(&quot;内层&quot;);\n            return 0;\n        &#125;\n        return a&#x2F;b;\n    &#125;\n\n自定义异常JDK为我们已经提前定义了一些异常了，但是可能对我们来说不够，那么就需要自定义异常：\npublic class MyException extends Exception &#123;  &#x2F;&#x2F;直接继承即可\n    \n&#125;\n\npublic static void main(String[] args) throws MyException &#123;\n        throw new MyException();   &#x2F;&#x2F;直接使用\n    &#125;\n\n也可以使用父类的带描述的构造方法：\npublic class MyException extends Exception &#123;\n\n    public MyException(String message)&#123;\n        super(message);\n    &#125;\n&#125;\n\npublic static void main(String[] args) throws MyException &#123;\n    throw new MyException(&quot;出现了自定义的错误&quot;);\n&#125;\n\n捕获异常指定的类型，会捕获其所有子异常类型：\ntry &#123;\n  throw new MyException(&quot;出现了自定义的错误&quot;);\n&#125; catch (Exception e) &#123;    &#x2F;&#x2F;捕获父异常类型\n  System.out.println(&quot;捕获到异常&quot;);\n&#125;\n\n多重异常捕获和finally关键字当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：\ntry &#123;\n  &#x2F;&#x2F;....\n&#125; catch (NullPointerException e) &#123;\n            \n&#125; catch (IndexOutOfBoundsException e)&#123;\n\n&#125; catch (RuntimeException e)&#123;\n            \n&#125;\n\n注意，类似于if-else if的结构，父异常类型只能放在最后！\ntry &#123;\n  &#x2F;&#x2F;....\n&#125; catch (RuntimeException e)&#123;  &#x2F;&#x2F;父类型在前，会将子类的也捕获\n\n&#125; catch (NullPointerException e) &#123;   &#x2F;&#x2F;永远都不会被捕获\n\n&#125; catch (IndexOutOfBoundsException e)&#123;   &#x2F;&#x2F;永远都不会被捕获\n\n&#125;\n\n如果希望把这些异常放在一起进行处理：\ntry &#123;\n     &#x2F;&#x2F;....\n&#125; catch (NullPointerException | IndexOutOfBoundsException e) &#123;  &#x2F;&#x2F;用|隔开每种类型即可\n\n&#125;\n\n当我们希望，程序运行时，无论是否出现异常，都会在最后执行的任务，可以交给finally语句块来处理：\ntry &#123;\n    &#x2F;&#x2F;....\n&#125;catch (Exception e)&#123;\n            \n&#125;finally &#123;\n  System.out.println(&quot;lbwnb&quot;);   &#x2F;&#x2F;无论是否出现异常，都会在最后执行\n&#125;\n\ntry语句块至少要配合catch或finally中的一个：\ntry &#123;\n    int a &#x3D; 10;\n    a &#x2F;&#x3D; 0;\n&#125;finally &#123;  &#x2F;&#x2F;不捕获异常，程序会终止，但在最后依然会执行下面的内容\n    System.out.println(&quot;lbwnb&quot;); \n&#125;\n\n思考：try、catch和finally执行顺序：\nprivate static int test(int a)&#123;\n  try&#123;\n    return a;\n  &#125;catch (Exception e)&#123;\n    return 0;\n  &#125;finally &#123;\n    a &#x3D;  a + 1;\n  &#125;\n&#125;\n\nJava泛型与集合类泛型利用代码块来快速添加内容Java BIOtry-with-resourseJava 多线程Java反射详谈类加载机制Java注解","slug":"JavaSE笔记（三）","date":"2022-03-09T03:41:52.829Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"c02ca665cd1f72f1b198d0583b891337","title":"JavaSE笔记（二）","content":"Java对象和多态 （面向对象）面向对象基础面向对象程序设计(Object Oriented Programming)\n对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。\nScanner sc &#x3D; new Scanner(System.in);\nString str &#x3D; sc.nextLine();\nSystem.out.println(&quot;你输入了：&quot;+str);\nsc.close();\n\n所有的对象，都需要通过new关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！\n不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）\n对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！\n\n类的基本结构为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。\n成员变量在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过.来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！\npublic class Test &#123;\n    int age;\n    String name;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Test test &#x3D; new Test();\n    test.name &#x3D; &quot;奥利给&quot;;\n    System.out.println(test.name);\n&#125;\n\n成员变量默认带有初始值，也可以自己定义初始值。\n成员方法我们之前的学习中接触过方法(Method)吗？主方法！\npublic static void main(String[] args) &#123;\n  &#x2F;&#x2F;Body\n&#125;\n\n方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。\n方法的定义和使用在类中，我们可以定义自己的方法，格式如下：\n[返回值类型] 方法名称([参数])&#123;\n  &#x2F;&#x2F;方法体\n  return 结果;\n&#125;\n\n\n返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值\n方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！\n参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法\n方法体：方法具体要干的事情\n结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）\n\n非void方法中，return关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！\nint test(int a)&#123;\n  if(a &gt; 0)&#123;\n    &#x2F;&#x2F;缺少retrun语句！\n  &#125;else&#123;\n    return 0;\n  &#125;\n&#125;\n\nreturn也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！\nvoid main(String[] args) &#123;\n   for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n       if(i &#x3D;&#x3D; 1) return;   &#x2F;&#x2F;在循环内返回了！和break区别？\n   &#125;\n   System.out.println(&quot;淦&quot;);   &#x2F;&#x2F;还会到这里吗？\n&#125;\n\n传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！\npublic static void main(String[] args) &#123;\n    int a &#x3D; 10, b &#x3D; 20;\n  \tnew Test().swap(a, b);\n  \tSystem.out.println(&quot;a&#x3D;&quot;+a+&quot;, b&#x3D;&quot;+b);\n&#125;\n\npublic class Test&#123;\n \tvoid swap(int a, int b)&#123;  &#x2F;&#x2F;传递的仅仅是值而已！\n  \t\tint temp &#x3D; a;\n  \t\ta &#x3D; b;\n \t\t\tb &#x3D; temp;\n\t&#125; \n&#125;\n\n传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）\npublic class B&#123;\n \tString name;\n&#125;\n\npublic class A&#123;\n \tvoid test(B b)&#123;  &#x2F;&#x2F;传递的是对象的引用，而不是值\n    System.out.println(b.name);\n  &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    int a &#x3D; 10, b &#x3D; 20;\n  \tB b &#x3D; new B();\n  \tb.name &#x3D; &quot;lbw&quot;;\n  \tnew A().test(b);\n  \tSystem.out.println(&quot;a&#x3D;&quot;+a+&quot;, b&#x3D;&quot;+b);\n&#125;\n\n方法之间可以相互调用\nvoid a()&#123;\n  &#x2F;&#x2F;xxxx\n&#125;\n\nvoid b()&#123;\n  a();\n&#125;\n\n当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）\nint a()&#123;\n  return a();\n&#125;\n\n成员方法和成员变量一样，是属于对象的，只能通过对象去调用！\n\n对象设计练习\n学生应该具有以下属性：名字、年龄\n学生应该具有以下行为：学习、运动、说话\n\n\n方法的重载一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！\npublic class Test &#123;\n    int a()&#123;   &#x2F;&#x2F;原本的方法\n       return 1;\n    &#125;\n\n    int a(int i)&#123;  &#x2F;&#x2F;ok，形参不同\n        return i;\n    &#125;\n    \n    void a(byte i)&#123;  &#x2F;&#x2F;ok，返回类型和形参都不同\n        \n    &#125;\n    \n    void a()&#123;  &#x2F;&#x2F;错误，仅返回值类型名称不同不能重载\n        \n    &#125;\n&#125;\n\n现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：\npublic class Test &#123;\n    int sum(int a, int b)&#123;   &#x2F;&#x2F;只有int支持，不灵活！\n        return a+b;\n    &#125;\n    \n    double sum(double a, double b)&#123;  &#x2F;&#x2F;重写一个double类型的，就支持小数计算了\n        return a+b;\n    &#125;\n&#125;\n\n现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？\npublic class Test &#123;\n    void a(int i)&#123;\n        System.out.println(&quot;调用了int&quot;);\n    &#125;\n\n    void a(short i)&#123;\n        System.out.println(&quot;调用了short&quot;);\n    &#125;\n\n    void a(long i)&#123;\n        System.out.println(&quot;调用了long&quot;);\n    &#125;\n\n    void a(char i)&#123;\n        System.out.println(&quot;调用了char&quot;);\n    &#125;\n\n    void a(double i)&#123;\n        System.out.println(&quot;调用了double&quot;);\n    &#125;\n\n    void a(float i)&#123;\n        System.out.println(&quot;调用了float&quot;);\n    &#125;\n  \n  \tpublic static void main(String[] args) &#123;\n        Test test &#x3D; new Test();\n        test.a(1);   &#x2F;&#x2F;直接输入整数\n        test.a(1.0);  &#x2F;&#x2F;直接输入小数\n\n        short s &#x3D; 2;\n        test.a(s);  &#x2F;&#x2F;会对号入座吗？\n        test.a(1.0F);\n    &#125;\n&#125;\n\n构造方法构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。\n&#x2F;&#x2F;反编译结果\npackage com.test;\n\npublic class Test &#123;\n    public Test() &#123;    &#x2F;&#x2F;即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的\n    &#125;\n&#125;\n\n反编译其实就是把我们编译好的class文件变回Java源代码。\nTest test &#x3D; new Test();  &#x2F;&#x2F;实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的\n&#x2F;&#x2F; new + 你想要使用的构造方法\n\n这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！\n类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！\n一般最常用的就是给成员属性赋初始值：\npublic class Student &#123;\n    String name;\n    \n    Student()&#123;\n        name &#x3D; &quot;伞兵一号&quot;;\n    &#125;\n&#125;\n\n我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字\npublic class Student &#123;\n    String name;\n\n    Student(String name)&#123;   &#x2F;&#x2F;形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！\n        this.name &#x3D; name;  &#x2F;&#x2F;通过this指代当前的对象属性，this就代表当前对象\n    &#125;\n&#125;\n\n&#x2F;&#x2F;idea 右键快速生成！\n\n注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。\n在我们定义了新的有参构造之后，默认的无参构造会被覆盖！\n&#x2F;&#x2F;反编译后依然只有我们定义的有参构造！\n\n如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。\npublic class Student &#123;\n    String name;\n\n    Student()&#123;\n\n    &#125;\n\n    Student(String name)&#123;\n        this.name &#x3D; name;\n    &#125;\n&#125;\n\n成员变量的初始化始终在构造方法执行之前\npublic class Student &#123;\n    String a &#x3D; &quot;sadasa&quot;;\n\n    Student()&#123;\n        System.out.println(a);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Student s &#x3D; new Student();\n    &#125;\n&#125;\n\n静态变量和静态方法静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。\npublic class Student &#123;\n    static int a;\n&#125;\n\npublic static void main(String[] args) &#123;\n\tStudent s1 &#x3D; new Student();\n\ts1.a &#x3D; 10;\n\tStudent s2 &#x3D; new Student();\n\tSystem.out.println(s2.a);\n&#125;\n\n不推荐使用对象来调用，被标记为静态的内容，可以直接通过类名.xxx的形式访问\npublic static void main(String[] args) &#123;\n   Student.a &#x3D; 10;\n   System.out.println(Student.a);\n&#125;\n\n简述类加载机制类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：\n\n访问类的静态变量，或者为静态变量赋值\nnew 创建类的实例（隐式加载）\n调用类的静态方法\n子类初始化时\n其他的情况会在讲到反射时介绍\n\n所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。\npublic class Student &#123;\n    static int a &#x3D; test();  &#x2F;&#x2F;直接调用静态方法，只能调用静态方法\n\n    Student()&#123;\n        System.out.println(&quot;构造类对象&quot;);\n    &#125;\n\n    static int test()&#123;   &#x2F;&#x2F;静态方法刚加载时就有了\n        System.out.println(&quot;初始化变量a&quot;);\n        return 1;\n    &#125;\n&#125;\n\n思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？\npublic class Student &#123;\n    static int a &#x3D; test();\n\n    static int test()&#123;\n        return a;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        System.out.println(Student.a);\n    &#125;\n&#125;\n\n定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0\n代码块和静态代码块代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）\npublic class Student &#123;\n    &#123;\n        System.out.println(&quot;我是代码块&quot;);\n    &#125;\n\n    Student()&#123;\n        System.out.println(&quot;我是构造方法&quot;);\n    &#125;\n&#125;\n\n静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；\npublic class Student &#123;\n    static int a;\n\n    static &#123;\n        a &#x3D; 10;\n    &#125;\n    \n    public static void main(String[] args) &#123;\n        System.out.println(Student.a);\n    &#125;\n&#125;\n\nString和StringBuilder类字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)\nString的对象直接支持使用+或+=运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）\nString a &#x3D; &quot;dasdsa&quot;, b &#x3D; &quot;dasdasdsa&quot;;\nString l &#x3D; a+b;\nSystem.out.println(l);\n\n大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）\nString result&#x3D;&quot;String&quot;+&quot;and&quot;; &#x2F;&#x2F;会被优化成一句！\n\nString str1&#x3D;&quot;String&quot;;\nString str2&#x3D;&quot;and&quot;;\nString result&#x3D;str1+str2;\n&#x2F;&#x2F;变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定\n\nString str1&#x3D;&quot;String&quot;;\nString str2&#x3D;&quot;and&quot;;\nString result&#x3D;(new StringBuilder(String.valueOf(str1))).append(str2).toString();\n&#x2F;&#x2F;使用StringBuilder，会采用类似于第一种实现，显然会更快！\n\nStringBuilder也是一个类，但是它能够存储可变长度的字符串！\nStringBuilder builder &#x3D; new StringBuilder();\nbuilder\n       .append(&quot;a&quot;)\n       .append(&quot;bc&quot;)\n       .append(&quot;d&quot;);   &#x2F;&#x2F;链式调用\nString str &#x3D; builder.toString();\nSystem.out.println(str);\n\n\n包和访问控制包声明和导入包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！\npackage com.test;\n\npublic class Test&#123;\n  \n&#125;\n\n包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。\n一般包按照个人或是公司域名的规则倒过来写 顶级域名.一级域名.二级域名 com.java.xxxx\n如果需要使用其他包里面的类，那么我们需要import（类似于C&#x2F;C++中的include）\nimport com.test.Student;\n\n也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）\nimport com.test.*\n\nJava默认为我们导入了以下的包，不需要去声明\nimport java.lang.*\n\n静态导入静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。\nimport static com.test.ui.Student.test;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        test();\n    &#125;\n&#125;\n\n静态导入不会进行类的初始化！\n访问控制Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。\n![image-20210819160939950](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210819160939950.png)\n权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！\npublic class Student &#123;\n    private int a &#x3D; 10;   &#x2F;&#x2F;具有私有访问权限，只能类内部访问\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student s &#x3D; new Student();\n    System.out.println(s.a);  &#x2F;&#x2F;还可以访问吗？\n&#125;\n\n和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！\n&#x2F;&#x2F; Student.java\npublic class Student &#123;\n    \n&#125;\nclass Test&#123;   &#x2F;&#x2F;不能添加权限修饰符！只能是default\n\t\n&#125;\n\n\n数组类型假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？\n\n我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！\nint[] arr &#x3D; new int[10];  &#x2F;&#x2F;需要new关键字来创建！\nString[] arr2 &#x3D; new String[10];\n\n数组本身也是类（编程不可见，C++写的），不是基本数据类型！\nint[] arr &#x3D; new int[10];\nSystem.out.println(arr.length);   &#x2F;&#x2F;数组有成员变量！\nSystem.out.println(arr.toString());   &#x2F;&#x2F;数组有成员方法！\n\n一维数组一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：\n类型[] 变量名称 &#x3D; new 类型[数组大小];\n类型 变量名称n &#x3D; new 类型[数组大小];  &#x2F;&#x2F;支持C语言样式，但不推荐！\n\n类型[] 变量名称 &#x3D; new 类型[]&#123;...&#125;;  &#x2F;&#x2F;静态初始化（直接指定值和大小）\n类型[] 变量名称 &#x3D; &#123;...&#125;;   &#x2F;&#x2F;同上，但是只能在定义时赋值\n\n 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：\nint[] arr &#x3D; new int[10];\narr[0] &#x3D; 626;\nSystem.out.println(arr[0]);\nSystem.out.println(arr[1]);\n\n我们可以通过数组变量名称.length来获取当前数组长度：\nint[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nSystem.out.println(arr.length);  &#x2F;&#x2F;打印length成员变量的值\n\n数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！\nString[] arr &#x3D; new String[10];\nSystem.out.println(arr[10]);  &#x2F;&#x2F;出现异常！\n\n&#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11\n&#x2F;&#x2F;\tat com.test.Application.main(Application.java:7)\n\n思考：能不能直接修改length的值来实现动态扩容呢？\nint[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\narr.length &#x3D; 10;\n\n数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身\npublic static void main(String[] args) &#123;\n    int[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\n    test(arr);\n    System.out.println(arr[0]);\n&#125;\n\nprivate static void test(int[] arr)&#123;\n    arr[0] &#x3D; 2934;\n&#125;\n\n数组的遍历如果我们想要快速打印数组中的每一个元素，又怎么办呢？\n传统for循环我们很容易就联想到for循环\nint[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n   System.out.println(arr[i]);\n&#125;\n\nforeach传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？\nint[] arr &#x3D; new int[]&#123;1, 2, 3&#125;;\nfor (int i : arr) &#123;\n    System.out.println(i);\n&#125;\n\nforeach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。\n二维数组二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。\n\n&#x2F;&#x2F;三行两列\nint[][] arr &#x3D; &#123; &#123;1, 2&#125;,\n                &#123;3, 4&#125;,\n                &#123;5, 6&#125;&#125;;\nSystem.out.println(arr[2][1]);\n\n二维数组的遍历同一维数组一样，只不过需要嵌套循环！\nint[][] arr &#x3D; new int[][]&#123; &#123;1, 2&#125;,\n                           &#123;3, 4&#125;,\n                           &#123;5, 6&#125;&#125;;\nfor (int i &#x3D; 0; i &lt; 3; i++) &#123;\n     for (int j &#x3D; 0; j &lt; 2; j++) &#123;\n          System.out.println(arr[i][j]);\n     &#125;\n&#125;\n\n多维数组不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。\n可变长参数可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量\npublic static void main(String[] args) &#123;\n     test(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;);    &#x2F;&#x2F;可变长，最后都会被自动封装成一个数组\n&#125;\n    \nprivate static void test(String... test)&#123;\n     System.out.println(test[0]);    &#x2F;&#x2F;其实参数就是一个数组\n&#125;\n\n由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！\n实战：三大基本排序算法现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？\nint[] arr &#x3D; &#123;8, 5, 0, 1, 4, 9, 2, 3, 6, 7&#125;;\n\n排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：\n\n冒泡排序\n\n冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。\n\n插入排序\n\n插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！\n\n\n选择排序\n\n选择排序其实就是每次都选择当前数组中最大的数排到最前面！\n\n封装、继承和多态封装、继承和多态是面向对象编程的三大特性。\n封装封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。\n设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？\npublic class Student &#123;\n    private String name;\n    private int age;\n  \n    public Student(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;\n\n也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。\npublic void setName(String name) &#123;\n    if(name.contains(&quot;小&quot;)) return;\n    this.name &#x3D; name;\n&#125;\n\n单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！\n封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。\n封装就是通过访问权限控制来实现的。\n继承继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中非私有的成员。\n现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：\npublic class SportsStudent extends Student&#123;   &#x2F;&#x2F;通过extends关键字来继承父类\n\n    public SportsStudent(String name, int age) &#123;\n        super(name, age);   &#x2F;&#x2F;必须先通过super关键字（指代父类），实现父类的构造方法！\n    &#125;\n\n    public void exercise()&#123;\n        System.out.println(&quot;我超勇的！&quot;);\n    &#125;\n&#125;\n\npublic class ArtStudent extends Student&#123;\n\n    public ArtStudent(String name, int age) &#123;\n        super(name, age);\n    &#125;\n\n    public void art()&#123;\n        System.out.println(&quot;随手画个毕加索！&quot;);\n    &#125;\n&#125;\n\n子类具有父类的全部属性，protected可见但外部无法使用（包括private属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！\n每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用super()，如果父类使用的是默认构造方法，那么子类不用手动指明。\n所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：\npublic static void main(String[] args) &#123;\nObject obj &#x3D; new Object;\nSystem.out.println(obj.hashCode());  &#x2F;&#x2F;求对象的hashcode，默认是对象的内存地址\nSystem.out.println(obj.equals(obj));  &#x2F;&#x2F;比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 &#x3D;&#x3D;\nSystem.out.println(obj.toString());  &#x2F;&#x2F;将对象转换为字符串，默认生成对象的类名称+hashcode\n&#125;\n\n关于Object类的其他方法，我们会在Java多线程中再来提及。\n多态多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！\n方法的重写我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！\n&#x2F;&#x2F;父类中的study\npublic void study()&#123;\n    System.out.println(&quot;学习&quot;);\n&#125;\n\n&#x2F;&#x2F;子类中的study\n@Override  &#x2F;&#x2F;声明这个方法是重写的，但是可以不要，我们现阶段不接触\npublic void study()&#123;\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;\n\n再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！\npublic static void main(String[] args) &#123;\n     SportsStudent student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);\n     student.study();   &#x2F;&#x2F;输出子类定义的内容\n&#125;\n\n思考：静态方法能被重写吗？\n当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？\npublic void study()&#123;\n    super.study();\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;\n\n同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量\npublic void setTest(int test)&#123;\n    test &#x3D; 1;\n  \tthis.test &#x3D; 1;\n  \tsuper.test &#x3D; 1;\n&#125;\n\n再谈类型转换我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：\nStudent student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);  &#x2F;&#x2F;父类变量引用子类实例\nstudent.study();     &#x2F;&#x2F;得到依然是具体实现的结果，而不是当前类型的结果\n\n我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：\nStudent student &#x3D; new SportsStudent(&quot;lbw&quot;, 20);  &#x2F;&#x2F;是由SportsStudent进行实现的\n&#x2F;&#x2F;... do something...\n\nSportsStudent ps &#x3D; (SportsStudent)student;  &#x2F;&#x2F;让它变成一个具体的子类\nps.sport();  &#x2F;&#x2F;调用具体实现类的方法\n\n这样的类型转换称为向下转型。\ninstanceof关键字那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！\nprivate static void test(Student student)&#123;\n    if (student instanceof SportsStudent)&#123;\n        SportsStudent sportsStudent &#x3D; (SportsStudent) student;\n        sportsStudent.sport();\n    &#125;else if (student instanceof ArtStudent)&#123;\n        ArtStudent artStudent &#x3D; (ArtStudent) student;\n        artStudent.art();\n    &#125;\n&#125;\n\n通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！\n思考：student instanceof Student的结果是什么？\n再谈final关键字我们目前只知道final关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？\npublic final class Student &#123;   &#x2F;&#x2F;类被声明为终态，那么它还能被继承吗\n  \t\n&#125;\n\n类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？\npublic final void study()&#123;  &#x2F;&#x2F;还能重写吗\n    System.out.println(&quot;学习&quot;);\n&#125;\n\n如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！\nprivate final String name;   &#x2F;&#x2F;引用类型不允许再指向其他对象\nprivate final int age;    &#x2F;&#x2F;基本类型值不允许发生改变\n\npublic Student(String name, int age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n&#125;\n\n学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！\n抽象类类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！\npublic abstract class Student &#123;    &#x2F;&#x2F;抽象类\n\t\tpublic abstract void test();  &#x2F;&#x2F;抽象方法\n&#125;\n\n通过使用abstract关键字来表明一个类是一个抽象类，抽象类可以使用abstract关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是必须由子类实现（除非子类也是一个抽象类）！\n抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！\nStudent s &#x3D; new Student()&#123;    &#x2F;&#x2F;只能直接创建带实现的匿名内部类！\n  public void test()&#123;\n    \n  &#125;\n&#125;\n\n因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：\npublic void study()&#123;   &#x2F;&#x2F;现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！\n    System.out.println(&quot;给你看点好康的&quot;);\n&#125;\n\n接口接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）\npublic interface Eat &#123;\n\tvoid eat(); \n&#125;\n\n通过使用interface关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含public权限的抽象方法！（Java8以后可以有默认实现）我们可以通过声明default关键字来给抽象方法一个默认实现：\npublic interface Eat &#123;\n    default void eat()&#123;\n        &#x2F;&#x2F;do something...\n    &#125;\n&#125;\n\n接口中定义的变量，默认为public static final\npublic interface Eat &#123;\n    int a &#x3D; 1;\n    void eat();\n&#125;\n\n一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！\npublic class SportsStudent extends Student implements Eat, ...&#123;\n\t\t@Override\n    public void eat() &#123;\n        \n    &#125;\n&#125;\n\n类通过implements关键字来声明实现的接口！每个接口之间用逗号隔开！\n实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！\n内部类类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！\n成员内部类我们的类中可以在嵌套一个类：\npublic class Test &#123;\n    class Inner&#123;   &#x2F;&#x2F;类中定义的一个内部类\n        \n    &#125;\n&#125;\n\n成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！\npublic static void main(String[] args) &#123;\n    Test test &#x3D; new Test();\n    Test.Inner inner &#x3D; test.new Inner();   &#x2F;&#x2F;写法有那么一丝怪异，但是没毛病！\n&#125;\n\n静态内部类静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过类名.去访问:\npublic class Test &#123;\n    static class Inner&#123;\n\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Test.Inner inner &#x3D; new Test.Inner();   &#x2F;&#x2F;不用再创建外部类对象了！\n&#125;\n\n局部内部类对，你没猜错，就是和局部变量一样哒~\npublic class Test &#123;\n    public void test()&#123;\n        class Inner&#123;\n\n        &#125;\n        \n        Inner inner &#x3D; new Inner();\n    &#125;\n&#125;\n\n反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！\n匿名内部类匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：\npublic static void main(String[] args) &#123;\n        Eat eat &#x3D; new Eat() &#123;\n            @Override\n            public void eat() &#123;\n                &#x2F;&#x2F;DO something...\n            &#125;\n        &#125;;\n    &#125;\n\n我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！\nlambda表达式读作λ表达式，它其实就是我们接口匿名实现的简化，比如说：\npublic static void main(String[] args) &#123;\n        Eat eat &#x3D; new Eat() &#123;\n            @Override\n            public void eat() &#123;\n                &#x2F;&#x2F;DO something...\n            &#125;\n        &#125;;\n    &#125;\n\npublic static void main(String[] args) &#123;\n        Eat eat &#x3D; () -&gt; &#123;&#125;;   &#x2F;&#x2F;等价于上述内容\n    &#125;\n\nlambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！\n为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer\n枚举类假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：\npublic class Student &#123;\n    private final String name;\n    private final int age;\n    private String status;\n  \n  \t&#x2F;&#x2F;...\n  \n  \tpublic void setStatus(String status) &#123;\n        this.status &#x3D; status;\n    &#125;\n\n    public String getStatus() &#123;\n        return status;\n    &#125;\n&#125;\n\n但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！\n有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！\npublic enum Status &#123;\n    RUNNING, STUDY, SLEEP    &#x2F;&#x2F;直接写每个状态的名字即可，分号可以不打，但是推荐打上\n&#125;\n\n使用枚举类也非常方便，我们只需要直接访问即可\npublic class Student &#123;\n    private final String name;\n    private final int age;\n    private Status status;\n  \n \t\t&#x2F;&#x2F;...\n  \n  \tpublic void setStatus(Status status) &#123;   &#x2F;&#x2F;不再是String，而是我们指定的枚举类型\n        this.status &#x3D; status;\n    &#125;\n\n    public Status getStatus() &#123;\n        return status;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student student &#x3D; new Student(&quot;小明&quot;, 18);\n    student.setStatus(Status.RUNNING);\n    System.out.println(student.getStatus());\n&#125;\n\n枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自Enum类，我们定义的每一个状态其实就是一个public static final的Status类型成员变量！\n&#x2F;&#x2F; Compiled from &quot;Status.java&quot;\npublic final class com.test.Status extends java.lang.Enum&lt;com.test.Status&gt; &#123;\n  public static final com.test.Status RUNNING;\n  public static final com.test.Status STUDY;\n  public static final com.test.Status SLEEP;\n  public static com.test.Status[] values();\n  public static com.test.Status valueOf(java.lang.String);\n  static &#123;&#125;;\n&#125;\n\n既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法\npublic enum Status &#123;\n    RUNNING(&quot;睡觉&quot;), STUDY(&quot;学习&quot;), SLEEP(&quot;睡觉&quot;);   &#x2F;&#x2F;无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）\n\n    private final String name;    &#x2F;&#x2F;枚举的成员变量\n    Status(String name)&#123;    &#x2F;&#x2F;覆盖原有构造方法（默认private，只能内部使用！）\n        this.name &#x3D; name;\n    &#125;\n  \n  \tpublic String getName() &#123;   &#x2F;&#x2F;获取封装的成员变量\n        return name;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    Student student &#x3D; new Student(&quot;小明&quot;, 18);\n    student.setStatus(Status.RUNNING);\n    System.out.println(student.getStatus().getName());\n&#125;\n\n枚举类还自带一些继承下来的实用方法\nStatus.valueOf(&quot;&quot;)   &#x2F;&#x2F;将名称相同的字符串转换为枚举\nStatus.values()   &#x2F;&#x2F;快速获取所有的枚举\n\n基本类型包装类Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！\n我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\n\n\nbyte  -&gt;  Byte      \nboolean  -&gt;  Boolean   \nshort  -&gt;  Short    \nchar  -&gt;  Character  \nint -&gt; Integer    \nlong -&gt;  Long     \nfloat -&gt; Float      \ndouble -&gt; Double\n\n包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）\nprivate final int value;   &#x2F;&#x2F;Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作\n\npublic Integer(int value) &#123;\n    this.value &#x3D; value;\n&#125;\n\n现在我们操作的就是Integer对象而不是一个int基本类型了！\npublic static void main(String[] args) &#123;\n     Integer i &#x3D; 1;   &#x2F;&#x2F;包装类型可以直接接收对应类型的数据，并变为一个对象！\n     System.out.println(i + i);    &#x2F;&#x2F;包装类型可以直接被当做一个基本类型进行操作！\n&#125;\n\n自动装箱和拆箱那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制\nInteger i &#x3D; 1;    &#x2F;&#x2F;其实这里只是简写了而已\nInteger i &#x3D; Integer.valueOf(1);  &#x2F;&#x2F;编译后真正的样子\n\n调用valueOf来生成一个Integer对象！\npublic static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)   &#x2F;&#x2F;注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）\n       return IntegerCache.cache[i + (-IntegerCache.low)];\n  \treturn new Integer(i);   &#x2F;&#x2F;返回一个新创建好的对象\n&#125;\n\n而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：\npublic static void main(String[] args) &#123;\n    Integer i &#x3D; Integer.valueOf(1);\n    int a &#x3D; i;    &#x2F;&#x2F;简写\n    int a &#x3D; i.intValue();   &#x2F;&#x2F;编译后实际的代码\n  \n  \tlong c &#x3D; i.longValue();   &#x2F;&#x2F;其他类型也有！\n&#125;\n\n既然现在是包装类型了，那么我们还能使用==来判断两个数是否相等吗？\npublic static void main(String[] args) &#123;\n    Integer i1 &#x3D; 28914;\n    Integer i2 &#x3D; 28914;\n\n    System.out.println(i1 &#x3D;&#x3D; i2);   &#x2F;&#x2F;实际上判断是两个对象是否为同一个对象（内存地址是否相同）\n    System.out.println(i1.equals(i2));   &#x2F;&#x2F;这个才是真正的值判断！\n&#125;\n\n注意IntegerCache带来的影响！\n思考：下面这种情况结果会是什么？\npublic static void main(String[] args) &#123;\n    Integer i1 &#x3D; 28914;\n    Integer i2 &#x3D; 28914;\n\n    System.out.println(i1+1 &#x3D;&#x3D; i2+1);\n&#125;\n\n在集合类的学习中，我们还会继续用到我们的包装类型！\n\n面向对象编程实战虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：\npublic static void main(String[] args) &#123;\n    int sum &#x3D; 0;\n    for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;   &#x2F;&#x2F;for循环暴力求解，简单，但是效率似乎低了一些\n        sum +&#x3D; i;\n    &#125;\n    System.out.println(sum);\n&#125;\n\npublic static void main(String[] args) &#123;\n    System.out.println((1 + 100) * 50);  &#x2F;&#x2F;高斯求和公式，利用数学，瞬间计算结果！\n&#125;\n\n说到最后，其实数学和逻辑思维才是解决问题的最终办法！\n对象设计（面向对象、多态运用）\n设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。\n设计设计一个接口考试，只有老师和学生会考试。\n设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。\n\n二分搜索（搜索算法）现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回-1即可。\nint[] arr &#x3D; new int[]&#123;1, 4, 5, 6, 7, 10, 12, 14, 20, 22, 26&#125;;   &#x2F;&#x2F;测试用例\n\nprivate static int test(int[] arr, int target)&#123;\n    &#x2F;&#x2F;请在这里实现搜索算法\n&#125;\n\n快速排序（排序算法、递归分治）（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用分治法来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。\n快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！\n0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）给定 n 件物品，每一个物品的重量为 w[n]，每个物品的价值为 v[n]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，求装入物品的最大价值是多少?\nint[] w &#x3D; &#123;2, 3, 4, 5&#125;;\nint[] v &#x3D; &#123;3, 4, 5, 6&#125;;\nint capacity &#x3D; 8;","slug":"JavaSE笔记（二）","date":"2022-03-09T03:41:48.987Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"c77d7175e79dc8945326daf0b5bc2787","title":"JavaSE笔记（一）","content":"Java语法规范所有的Java语句必须以;结尾！\n无论是()、[]还是&#123;&#125;，所有的括号必须一一匹配！\n主方法的代码只能写在&#123;&#125;中！\nJava基础语法（面向过程）在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！\n变量和关键字变量变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：\nint a &#x3D; 10;\na &#x3D; 20;\na &#x3D; 30;\n\n我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）\n变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++–\nJava是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）\n定义一个变量的格式如下：\n[类型] [标识符(名字)] &#x3D; [初始值(可选)]\nint a &#x3D; 10;\n\n注意：标识符不能为以下内容：\n\n标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。\n大小写敏感！\n不能有空格、@、#、+、-、&#x2F; 等符号\n应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头\n不可以是 true 和 false \n不能与Java语言的关键字重名\n\n关键字包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！\n常量常量就是无法修改值的变量，常量的值，只能定义一次：\nfinal int a &#x3D; 10;\na &#x3D; 10;  &#x2F;&#x2F;报错！\n\n常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）\n这只是final关键字的第一个用法，后面还会有更多的用法。\n注释养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：\n&#x2F;&#x2F;我是单行注释\n\n&#x2F;**\n* 我是\n* 多行注释\n*&#x2F;\n\n&#x2F;&#x2F;TODO 待做标记\n\n\n基本数据类型Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。\n这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）\n计算机中的二进制表示在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。\n十进制的7 -&gt; 在二进制中为 111 &#x3D; 2^2 + 2^1 + 2^0\n现在有4个bit位，最大能够表示多大的数字呢？\n\n最小：0000 &#x3D;&gt; 0\n最大：1111 &#x3D;&gt; 2^3+2^2+2^1+2^0 &#x3D;&gt; 8 + 4 + 2 + 1 &#x3D; 15\n\n在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：\n\n最小：1111 &#x3D;&gt; -(2^2+2^1+2^0) &#x3D;&gt; -7\n最大：0111 &#x3D;&gt; +(2^2+2^1+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7\n\n现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。\n计算机中的加减法原码虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：\n1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）\n我们得创造一种更好的表示方式！于是我们引入了反码：\n反码\n正数的反码是其本身\n负数的反码是在其原码的基础上, 符号位不变，其余各个位取反\n\n经过上面的定义，我们再来进行加减法：\n1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 （直接相加，这样就简单多了！）\n思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？\n\n0既不是正数也不是负数，那么显然这样的表示依然不够合理！\n\n补码根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：\n\n正数的补码就是其本身 （不变！）\n负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)\n\n其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：\n1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 （现在无论你怎么算，也不会有-0了！）\n所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）\n以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解\n\n整数类型整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。\n在Java中，整数类型包括以下几个：\n\nbyte 字节型 （8个bit，也就是1个字节）范围：-128~+127\nshort 短整形（16个bit，也就是2个字节）范围：-32768~+32767\nint 整形（32个bit，也就是4个字节）最常用的类型！\nlong 长整形（64个bit，也就是8个字节）最后需要添加l或L\n\nlong都装不下怎么办？BigInteger！\n数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：\n0111 + 0001 &#x3D; 1000 &#x3D;&gt;  -8（你没看错，就是这样！）\n整数还能使用8进制、16进制表示：\n\n十进制为15 &#x3D; 八进制表示为017 &#x3D; 十六进制表示为 0xF &#x3D; 二进制表示 1111 (代码里面不能使用二进制！)\n\n字符类型和字符串在Java中，存在字符类型，它能够代表一个字符：\n\nchar 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535\n使用Unicode表示就是：\\u0000 ~ \\uffff\n\n字符要用单引号扩起来！比如 char c &#x3D; ‘淦’;\n字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符&#39;A&#39;的ASCII码就是数字65，所以，char类型其实可以转换为上面的整数类型。\nJava的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）\n既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）\nString就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。\n字符串用双引号括起来！比如：String str &#x3D; “一日三餐没烦恼”;\n小数类型小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：\n\nfloat 单精度浮点型 （32bit，4字节）\ndouble 双精度浮点型（64bit，8字节）\n\n思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：\n![image-20210817143234500](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210817143234500.png)\n根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：V &#x3D; (-1)^S × M × 2^E（1）(-1)^S 表示符号位，当 S&#x3D;0，V 为正数；当 S&#x3D;1，V 为负数。（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）（3）2^E 表示指数位。（用于移动小数点）\n比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。\n思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！\n布尔类型布尔类型（boolean）只有true和false两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。\n\n类型转换隐式类型转换隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：\n\nbyte→short(char)→int→long→float→double\n\n问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！\n所以，如下的代码就能够正常运行：\nbyte b &#x3D; 9;\nshort s &#x3D; b;\nint i &#x3D; s;\nlong l &#x3D; i;\nfloat f &#x3D; l;\ndouble d &#x3D; f;\nSystem.out.println(d);\n\n&#x2F;&#x2F;输出 9.0\n\n显示类型转换显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。\nint i &#x3D; 128;\nbyte b &#x3D; (byte)i;\nSystem.out.println(b);\n\n&#x2F;&#x2F;输出 -128\n\n为什么结果是-128？精度丢失了！\n\nint 类型的128表示：00000000 00000000 00000000 10000000\nbyte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 &#x3D;&gt; -128\n\n数据类型自动提升在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：\nbyte b &#x3D; 105;\nb &#x3D; b + 1;   &#x2F;&#x2F;报错！\nSystem.out.println(b);\n\n这个特性是由 Java虚拟机规范 定义的，也是为了提高运行的效率。其他的特性还有：\n\n如果一个操作数是long型，计算结果就是long型\n如果一个操作数是float型，计算结果就是float型\n如果一个操作数是double型，计算结果就是double型\n\n\n运算符赋值和算术运算符赋值运算符=是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：\nint a &#x3D; 10;\nint b &#x3D; 1 + 8;\nint c &#x3D; 5 * 5;\n\n算术运算符也就是我们在小学阶段学习的+ - * / %，分别代表加减乘除还有取余，例如：\nint a &#x3D; 2;\nint b &#x3D; 3;\nint c &#x3D; a * b;\n&#x2F;&#x2F;结果为6\n\n需要注意的是，+还可以用作字符串连接符使用：\nSystem.out.println(&quot;lbw&quot; + &quot;nb&quot;);  &#x2F;&#x2F;lbwnb\n\n当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：\nint a &#x3D; 7, b &#x3D; 15;\nSystem.out.println(&quot;lbw&quot; + a + b); &#x2F;&#x2F;lbw715\n\n算术运算符还包括++和--也就是自增和自减，以自增为例：\nint a &#x3D; 10;\na++;\nSystem.out.println(a); &#x2F;&#x2F;输出为11\n\n自增自减运算符放在变量的前后的返回值是有区别的：\nint a &#x3D; 10;\nSystem.out.println(a++);  &#x2F;&#x2F;10 （先返回值，再自增）\nSystem.out.println(a);   &#x2F;&#x2F;11\n\nint a &#x3D; 10;\nSystem.out.println(++a);  &#x2F;&#x2F;11 （先自增，再返回值）\nSystem.out.println(a);  &#x2F;&#x2F;11\n\nint a &#x3D; 10;\nint b &#x3D; 2;\nSystem.out.println(b+++a++);  &#x2F;&#x2F;猜猜看结果是多少\n\n为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括+=、-=、/=、*=、%=，和自增自减类似，先执行运算，再返回结果，同时自身改变：\nint a &#x3D; 10;\nSystem.out.println(a +&#x3D; 2);  &#x2F;&#x2F;等价于 a &#x3D; a + 2\n\n关系运算符关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：\n&gt; &lt; &#x3D;&#x3D; &#x2F;&#x2F;大于小于等于\n&gt;&#x3D; &lt;&#x3D;  !&#x3D;  &#x2F;&#x2F;大于等于，小于等于，不等于\n\n关系运算符一般只用于基本类型的比较，运算结果只能是boolean：\nint a &#x3D; 10;\nint b &#x3D; 2;\nboolean x &#x3D; a &gt; b;\nSystem.out.println(x);\n&#x2F;&#x2F;结果为 true\n\n逻辑运算符逻辑运算符两边只能是boolean类型或是关系&#x2F;逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：\n&amp;&amp; &#x2F;&#x2F;与运算，要求两边同时为true才能返回true\n|| &#x2F;&#x2F;或运算，要求两边至少要有一个为true才能返回true\n! &#x2F;&#x2F;非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转\n\n实际案例来看看：\nint a &#x3D; 10;\nint b &#x3D; 2;\nboolean x &#x3D; a &gt; b &amp;&amp; a &lt; b;  &#x2F;&#x2F;怎么可能同时满足呢\nSystem.out.println(x);   &#x2F;&#x2F;false\n\nint a &#x3D; 10;\nint b &#x3D; 2;\nboolean x &#x3D; a &gt; b || a &lt;&#x3D; b;  &#x2F;&#x2F;一定有一个满足！\nSystem.out.println(x);   &#x2F;&#x2F;true\n\nint a &#x3D; 10;\nint b &#x3D; 2;\nboolean x &#x3D; !(a &gt; b); &#x2F;&#x2F;对结果进行反转，本来应该是true\nSystem.out.println(x); &#x2F;&#x2F;false\n\n位运算符&amp; &#x2F;&#x2F;按位与，注意，返回的是运算后的同类型值，不是boolean！\n| &#x2F;&#x2F;按位或\n^ &#x2F;&#x2F;按位异或 0 ^ 0 &#x3D; 0\n~ &#x2F;&#x2F;按位非\n\n按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：\n0101 &amp; 0100 &#x3D; 0100 （只有同时为1对应位才得1）\nint a &#x3D; 7, b &#x3D; 15;\nSystem.out.println(a &amp; b); &#x2F;&#x2F;结果为7\n\n三目运算符三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：\nint a &#x3D; 7, b &#x3D; 15;\nString str &#x3D; a &gt; b ? &quot;行&quot; : &quot;不行&quot;;  &#x2F;&#x2F; 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 \nSystem.out.println(&quot;汉堡做的行不行？&quot;+str);  &#x2F;&#x2F;汉堡做的行不行？不行\n\n理解三目运算符，就很容易理解后面的if-else语句了。\n\n流程控制我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！\n选择结构选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。\nif语句就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：\nif(判断条件)&#123;\n  &#x2F;&#x2F;判断成功执行的内容\n&#125;else&#123;\n  &#x2F;&#x2F;判断失败执行的内容\n&#125;\n&#x2F;&#x2F;if的内容执行完成后，后面的内容正常执行\n\n其中，else语句不是必须的。\n现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：\nif(判断条件1)&#123;\n  &#x2F;&#x2F;判断成功执行的内容\n&#125;else if(判断条件2)&#123;\n  &#x2F;&#x2F;再次判断，如果判断成功执行的内容\n&#125;else&#123;\n  &#x2F;&#x2F;上面的都没成功，只能走这里\n&#125;\n\n同样，else语句不是必须的。\n现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：\nif(判断条件1)&#123;\n  &#x2F;&#x2F;前提是判断条件1要成功才能进来！\n  if(判断条件2)&#123;\n    &#x2F;&#x2F;判断成功执行的内容\n  &#125;else&#123;\n    &#x2F;&#x2F;判断失败执行的内容\n  &#125;\n&#125;\n\nswitch语句我们不难发现，虽然else-if能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？\nswitch(判断主体)&#123;\n  case 值1:\n    &#x2F;&#x2F;运行xxx\n    break;  &#x2F;&#x2F;break用于跳出switch语句，不添加会导致程序继续向下运行！\n  case 值2:\n    &#x2F;&#x2F;运行xxx\n    break;\n  case 值3:\n    &#x2F;&#x2F;运行xxx\n    break;\n&#125;\n\n在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！\n为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！\n循环结构小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？\nfor语句for语句是比较灵活的循环控制语句，一个for语句的定义如下：\nfor(初始条件;循环条件;更新)&#123;\n  &#x2F;&#x2F;循环执行的内容\n&#125;\n&#x2F;&#x2F;循环结束后，继续执行\n\n\n初始条件：循环开始时的条件，一般用于定义控制循环的变量。\n循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。\n更新：每轮循环结束后都会执行的内容，一般写增量表达式。\n\n初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！\nfor(int i &#x3D; 0;i &lt; 520;i++)&#123;\n  System.out.println(&quot;我爱你&quot;);\n&#125;\n\nfor(;;)&#123;\n  &#x2F;&#x2F;这里的内容将会永远地进行下去！\n&#125;\n\n增强for循环在数组时再讲解！\nwhile循环while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！\nwhile(循环条件)&#123;\n  &#x2F;&#x2F;循环执行的内容\n&#125;\n\n和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：\ndo&#123;\n  &#x2F;&#x2F;执行内容\n&#125;while(循环条件);\n\n一定会先执行do里面的内容，再做判断！\n思考：\nfor(;;)&#123;\n  \n&#125;\n\nwhile(true)&#123;\n  \n&#125;\n\n&#x2F;&#x2F;它们的性能谁更高？\n\n\n面向过程编程实战（基础+算法）打印九九乘法表简单：将九九乘法表打印到控制台。\n求1000以内的水仙花数中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 &#x3D; 1^3 + 5^3 + 3^3\n青蛙跳台阶问题困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n&#x3D;2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。\n动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推\n\n不对啊，别的教程都讲了数组、方法，怎么我们还没讲就进入面向对象了呢？\n\n数组在Java中，并非基本类型，数组是编程不可见的对象类型，学习了面向对象再来理解，会更加容易！\n方法在Java中是类具有的属性，所以，在了解了对象类型之后，再来了解方法，就更加简单了！\n\n","slug":"JavaSE笔记（一）","date":"2022-03-09T03:41:38.630Z","categories_index":"JavaSE笔记","tags_index":"JavaSE笔记","author_index":"YangChao"},{"id":"98f040fb8fb5c5ced4fb87fa4094e887","title":"JavaSSM笔记（四）","content":"MySQL高级在JavaWeb阶段，我们初步认识了MySQL数据库，包括一些基本操作，比如创建数据库、表、触发器，以及最基本的增删改查、事务等操作。而在此阶段，我们将继续深入学习MySQL，了解它的更多高级玩法，也相当于进行复习。\n函数其实函数我们在之前已经接触到一部分了，在JavaWeb阶段，我们了解了聚集函数，聚集函数一般用作统计，包括：\n\ncount([distinct]*)    统计所有的行数（distinct表示去重再统计，下同）\ncount([distinct]列名)    统计某列的值总和\nsum([distinct]列名)    求一列的和（注意必须是数字类型的）\navg([distinct]列名)    求一列的平均值（注意必须是数字类型）\nmax([distinct]列名)    求一列的最大值\nmin([distinct]列名)    求一列的最小值\n\n比如我们需要计算某个表一共有多少行：\nSELECT COUNT(*) FROM student\n\n通过使用COUNT聚集函数，就可以快速统计并得到结果，比如我们想计算某一列上所有数字的和：\nSELECT SUM(sid) FROM student\n\n通过SUM聚集函数，就可以快速计算每一列的和，实际上这些函数都是由系统提供的函数，我们可以直接使用。\n本版块我们会详细介绍各类系统函数以及如何编写自定义函数。\n系统函数系统为我们提供的函数也是非常实用的，我们将会分为几个类型进行讲解。\n字符串函数处理字符串是一个比较重要的内容，我们可以使用字符串函数来帮助我们快速处理字符串，其中常用比如用于字符串分割的函数有：\n\nsubstring(字符串, 起始位置, 结束位置)     同Java中String类的substring一致，但是注意下标是从1开始，下同\nleft(字符串, 长度)     从最左边向右截取字符串\nright(字符串, 长度)     从最右边向左截取字符串\n\n比如我们只想获取所有学生姓名的第二个字，那么可以像这样写：\nSELECT SUBSTRING(name, 2, 2) FROM student\n\n比如我们想获取所有学生姓名的第一个字，可以像这样写：\nSELECT LEFT(name, 1) FROM student\n\n我们还可以利用字符串函数来快速将所有的字母转换为大写字母或是快速转换为小写字母：\n\nupper(字符串)     字符串中的所有字母转换为大写字母\nlower(字符串)     字符串中的所有字母转换为小写字母\n\n比如我们希望将一个字符串所有字符专为大写：\nSELECT UPPER(&#39;abcdefg&#39;)\n\n我们也可以像Java中那样直接对字符串中的内容进行替换：\n\nreplace(字符串, 原文, 替换文)      同Java中String的replace效果\n\n比如现在我们希望将查询到的所有同学的名称中的小全部替换大：\nSELECT REPLACE(&#96;name&#96;, &#39;小&#39;, &#39;大&#39;) FROM student\n\n字符串也支持进行拼接，系统提供了字符串的拼接函数：\n\nconcat(字符串1, 字符串2)   连接两个字符串\n\n比如我们希望将查询到的所有同学的名称最后都添加一个子字：\nSELECT concat(name, &#39;子&#39;) FROM student\n\n最后就是计算字符串的长度：\n\nlength(字符串)    获取字符串长度（注意如果使用的是UTF-8编码格式，那么一个汉字占3字节，数字和字母占一个字节）\n\n比如我们要获取所有人名字的长度：\nSELECT LENGTH(&#96;name&#96;) FROM student\n\n日期函数MySQL提供的日期函数也非常实用，我们可以快速对日期进行操作，比如我们想要快速将日期添加N天，就可以使用：\n\ndate_add(日期, interval 增量 单位)\n\n比如我们希望让2022-1-1向后5天：\nSELECT DATE_ADD(&#39;2022-1-1&#39;,INTERVAL 5 day)\n\n同理，向前1年：\nSELECT DATE_ADD(&#39;2022-1-1&#39;,INTERVAL -1 year)\n\n单位有：year（年）、month（月）、day（日）、hour（小时）、minute（分钟）、second（秒）\n我们还可以快速计算日期的间隔天数：\n\ndatediff(日期1, 日期2)\n\n比如我们想计算2022年的2月有多少天：\nSELECT DATEDIFF(&#39;2022-3-1&#39;,&#39;2022-2-1&#39;)\n\n如果我们想快速获取当前时间的话，可以使用这些：\n\ncurdate()     当前的日期\ncurtime()     当前的时间\nnow()    当前的日期+时间\n\n此函数之前我们在编写实战项目的时候已经使用过了，这里就不演示了。我们也可以单独获取时间中的某个值：\n\nday(日期)    获取日期是几号\nmonth(日期)   获取日期是几月\nyear(日期)      获取日期是哪一年\n\n比如我们想获取今天是几号：\nSELECT DAY(NOW())\n\n数学函数数学函数比较常规，基本与Java的Math工具类一致，这里列出即可，各位可以自行尝试：\n\nabs(x)   求x的绝对值\nceiling(x)   x向上取整\nfloor(x)  x向下取整\nround(x, 精度)  x取四舍五入，遵循小数点精度 \nexp(x)   e的x次方\nrand()   0-1之间的随机数\nlog(x)    x的对数\npi()     π\npower(x, n)    x的n次方\nsqrt(x)     x的平方根\nsin(x)  cos(x)   tan(x)     三角函数（貌似没有arctan这类反函数？）\n\n类型转换函数MySQL的类型转换也分为隐式类型转换和显示类型转换，首先我们来看看隐式类型转换：\nSELECT 1+&#39;2&#39;\n\n虽然这句中既包含了数字和字符，但是字符串会被进行隐式转换（注意这里并不是按照字符的ASCII码转换，而是写的多少表示多少）所以最后得到的就是1+2的结果为3\nSELECT CONCAT(1, &#39;2&#39;)\n\n这里因为需要传入字符串类型的数据，但是我们给的是1这个数字，因此这里也会发生隐式类型转换，1会被直接转换为字符串的’1’，所以这里得到的结果是’12’\n在某些情况下，我们可能需要使用强制类型转换来将得到的数据转换成我们需要的数据类型，这时就需要用到类型转换函数了，MySQL提供了：\n\ncast(数据   as 数据类型)\n\n数据类型有以下几种：\n\nBINARY[(N)] ：二进制字符串，转换后长度小于N个字节\nCHAR[(N)] ：字符串，转换后长度小于N个字符\nDATE ：日期\nDATETIME ：日期时间\nDECIMAL[(M[,N])] ：浮点数，M为数字总位数(包括整数部分和小数部分)，N为小数点后的位数\nSIGNED [INTEGER] ：有符号整数\nTIME ：时间\nUNSIGNED [INTEGER] ：无符号整数\n\n比如我们现在需要将一个浮点数转换为一个整数：\nSELECT CAST(pi() AS SIGNED)\n\n我们还可以将字符串转换为数字，会自动进行扫描，值得注意的是一旦遇到非数字的字符，会停止扫描：\nSELECT CAST(&#39;123abc456&#39; as SIGNED)\n\n除了cast以外还有convert函数，功能比较相似，这里就不做讲解了。\n流程控制函数MySQL还为我们提供了很多的逻辑判断函数，比如：\n\nif(条件表达式, 结果1, 结果2)    与Java中的三目运算符一致 a &gt; b ? “AAA” : “BBB”\nifnull(值1, 值2)     如果值1为NULL则返回值2，否则返回值1\nnullif(值1, 值2)     如果值1与值2相等，那么返回NULL\nisnull(值)      判断值是否为NULL\n\n比如现在我们想判断：\nSELECT IF(1 &lt; 0,&#39;lbwnb&#39;,&#39;yyds&#39;)\n\n通过判断函数，我们就可以很方便地进行一些条件判断操作。\n除了IF条件判断，我们还可以使用类似Switch一样的语句完成多分支结构：\nSELECT \nCASE 2\n\tWHEN 1 THEN\n\t\t10\n\tELSE\n\t\t5\nEND;\n\n我们也可以将自定义的判断条件放入When之后，它类似于else-if：\nSELECT \nCASE\n\tWHEN 3&gt;5 THEN\n\t\t10\n\tWHEN 0&lt;1 THEN\n\t\t11\n\tELSE\n\t\t5\nEND;\n\n还有一个类似于Java中的Thread.sleep的函数，以秒为单位：\nSELECT sleep(10);\n\n有关MySQL8.0新增的窗口函数这里暂时不做介绍。\n自定义函数除了使用系统为我们提供的函数以外，我们也可以自定义函数，并使用我们自定义的函数进行数据处理，唯一比较麻烦的就是函数定义后不能修改，只能删了重新写。\n基本语法MySQL的函数与Java中的方法类似，也可以添加参数和返回值，可以通过CREATE FUNCTION创建函数：\nCREATE FUNCTION test() RETURNS INT\nBEGIN\nRETURN 666;\nEND\n\n定义函数的格式为：\n\ncreate function 函数名称([参数列表]) returns 返回值类型\nbegin 和 end 之间写函数的其他逻辑，begin和end就相当于Java中的花括号&#123;  ...  &#125;\nreturn后紧跟返回的结果\n\n添加参数也很简单，我们只需要在函数名称括号中添加即可，注意类型需要写在参数名称后面：\nCREATE FUNCTION test(i INT) RETURNS INT\nBEGIN\nRETURN i * i;\nEND\n\n我们可以在BEGIN和RETURN之间编写一些其他的逻辑，比如我们想要定义一个局部变量，并为其赋值：\nBEGIN\nDECLARE a INT;\nSET a &#x3D; 10;\nRETURN i * i * a;\nEND\n\n定义局部变量的格式为：\n\ndeclare 变量名称 变量类型 [, …]\ndeclare 变量名称 变量类型 default 默认值\n\n为变量赋值的格式为：\n\nset 变量名称 &#x3D; 值\n\n我们还可以在函数内部使用select语句，它可以直接从表中读取数据，并可以结合into关键字将查询结果赋值给变量：\nBEGIN\nDECLARE a INT;\n-- select into from 语句\nSELECT COUNT(*) INTO a FROM student;\nRETURN a;\nEND\n\n流程控制接着我们来看一下如何使用流程控制语句，其中最关键的就是IF判断语句：\nBEGIN\nDECLARE a INT DEFAULT 10;\nIF a &gt; 10 THEN\n\tRETURN 1;\nELSE\n\tRETURN 2;\nEND IF;\nEND\n\nIF分支语句的格式为：\n\nif 判断条件 then  … else if 判断条件 then …. else … end if;\n\n我们可以结合exists关键字来判断是否为NULL：\nBEGIN\nDECLARE a INT DEFAULT 0;\n-- IF EXISTS(SELECT * FROM student WHERE sid &#x3D; 100) THEN\nIF NOT EXISTS(SELECT * FROM student WHERE sid &#x3D; 100) THEN\n\tSET a &#x3D; 10;\nEND IF;\nRETURN a;\nEND\n\n我们也可以在函数中使用switch语句：\nBEGIN\nDECLARE a INT DEFAULT 10;\nCASE a\n\tWHEN 10 THEN\n\t\tRETURN 2;\n\tELSE\n\t\tRETURN 1;\nEND CASE;\nEND\n\nSWITCH分支语句的格式为：\n\ncase 变量 when 具体值或是布尔表达式 then … when * then … else … end case;\n\n与Java不同的是，它支持使用布尔表达式：\nBEGIN\nDECLARE a INT DEFAULT 10;\nCASE\n\tWHEN 1 &lt; 5 THEN\n\t\tSET a &#x3D; 5;\n\tELSE\n\t\tSET a &#x3D; 10;\nEND CASE;\nRETURN a;\nEND\n\n我们以类似于elseif的形式进行判断，其实和上面直接使用是一样的。\n我们接着来看循环语句，MySQL提供了三种循环语句，其中第一种是WHILE语句：\nBEGIN\nDECLARE a INT DEFAULT 10;\nWHILE a &lt; 11 DO\n\tSET a &#x3D; a + 1;\nEND WHILE;\nRETURN a;\nEND\n\n格式为：\n\nwhile 循环条件 do …  end while;\n\n我们接着来看第二种循环语句，LOOP循环：\nBEGIN\nDECLARE a INT DEFAULT 10;\nlp1: LOOP\n  SET a &#x3D; a - 1;\n\tIF a &#x3D; 0 THEN\n\t\tLEAVE lp1; \n\tEND IF; \nEND LOOP lp1;\nRETURN a;\nEND\n\n相比while语句，我们可以使用LEAVE精准控制结束哪个循环，有点类似于goto语句：\nBEGIN\nDECLARE a INT DEFAULT 0;\nlp1: LOOP\n  lp2: LOOP\n\tSET a &#x3D; a + 1;\n\tIF a &gt; 5 THEN\n\t\tLEAVE lp1; \n\tEND IF; \n\tEND LOOP lp2;\nEND LOOP lp1;\nRETURN a;\nEND\n\n类似于Java中的goto写法（在JavaSE阶段已经讲解过）：\npublic static void main(String[] args) &#123;\n    int a &#x3D; 0;\n    lp1: while (true)&#123;\n        lp2: while (true)&#123;\n            a++;\n            if(a &gt; 5) break lp1;\n        &#125;\n    &#125;\n    System.out.println(a);\n&#125;\n\n它的语法格式如下：\n\n循环名称 loop …(可以插入leave语句结束) end loop 循环名称;\n\n接着我们来看最后一种循环语句，repeat语句：\nBEGIN\nDECLARE a INT DEFAULT 0;\nREPEAT\n\tSET a &#x3D; a + 1;\nUNTIL a &gt; 0 END REPEAT;\nRETURN a;\nEND\n\n它类似于Java中的do-while循环语句，它会先去执行里面的内容，再进行判断，格式为：\n\nrepeat … until 结束循环条件 end repeat;\n\n全局变量某些情况下，我们可以直接在一次会话中直接定义变量并使用，这时它并不是位于函数内的，这就是全局变量，它无需预先定义，直接使用即可：\nset @x &#x3D; 10;\n\n我们可以将全局变量作为参数传递给函数：\nselect test(@x);\n\n除了我们自己定义的全部变量以外，系统默认也有很多的变量，因此我们自己定义的变量称为用户变量，系统默认变量称为系统变量。查看系统变量的命令为：\nshow GLOBAL VARIABLES\n\n\n存储过程存储过程是一个包括多条SQL语句的集合，专用于特定表的特定操作，比如我们之前实战项目中的创建用户，那么我们就需要一次性为两张表添加数据，但是如果不使用Java，而是每次都去使用SQL命令来完成，就需要手动敲两次命令，非常麻烦，因此我们可以提前将这些操作定义好，预留出需要填写数据的位置，下次输入参数直接调用即可。\n这里很容易与函数搞混淆，存储过程也是执行多条SQL语句，但是它们的出发点不一样，函数是专用于进行数据处理，并将结果返回给调用者，它更多情况下是一条SQL语句的参与者，无法直接运行，并且不涉及某个特定表：\nselect count(*) from student;\n\n而存储过程是多条SQL语句的执行者，这是它们的本质区别。\n定义存储过程与定义函数极为相似，它也可以包含参数，函数中使用的语句这里也能使用，但是它没有返回值：\nCREATE PROCEDURE lbwnb(&#96;name&#96; VARCHAR(20), pwd VARCHAR(255))\nBEGIN\n  INSERT INTO users(username, &#96;password&#96;) VALUES(&#96;name&#96;, pwd);\nEND\n\n我们可以在存储过程中编写多条SQL语句，但是注意，MySQL的存储过程不具有原子性，当出现错误时，并不会回滚之前的操作，因此需要我们自己来编写事务保证原子性。\n接着我们来看看如何执行存储过程：\nCALL lbwnb(&#39;111&#39;, &#39;2222&#39;)\n\n通过使用call来执行一个存储过程，如果存储过程有参数，那么还需要填写参数。\n比如现在我们想要实现查询用户表，如果包含用户test那么就删除用户，如果不包含，就添加用户：\nCREATE PROCEDURE &#96;lbwnb&#96;()\nBEGIN\n\tIF NOT EXISTS(SELECT * FROM users WHERE username &#x3D; &#39;test&#39;) THEN\n\t\tINSERT INTO users(username, &#96;password&#96;) VALUES(&#39;test&#39;, &#39;123456&#39;);\n\tELSE\n\t\tDELETE FROM users WHERE username &#x3D; &#39;test&#39;;\n\tEND IF;\nEND\n\n这里其实只需要一个简单的IF判断即可实现。\n那么如果我们希望遍历一个SELECT语句查询的结果呢？我们可以使用游标来完成：\nBEGIN\n\tDECLARE id INT;\n\tDECLARE &#96;name&#96; VARCHAR(10);\n\tDECLARE sex VARCHAR(5);\n\tDECLARE cur CURSOR FOR SELECT * FROM student;\n\tOPEN cur;\n\tWHILE TRUE DO\n\t\tFETCH cur INTO id, &#96;name&#96;, sex;\n\t\tSELECT id, &#96;name&#96;, sex;\n\tEND WHILE;\n\tCLOSE cur;\nEND\n\n游标的使用分为4个步骤：\n\nDECLARE 游标名称 CURSOR FOR 查询结果   -  定义游标\nOPEN cur     -   开启游标\nFETCH 游标名称 INTO 存储结果的变量    -    从顶部开始，每执行一次，向下移动，如果已经在最底部，则触发异常\nCLOSE cur    -   关闭游标\n\n我们这里利用了一个while循环来多次通过游标获取查询结果，但是最后是因为出现异常才退出的，这样会导致之后的代码就无法继续正常运行了。\n我们接着来看如何处理异常：\nBEGIN\n\tDECLARE id INT;\n\tDECLARE &#96;name&#96; VARCHAR(10);\n\tDECLARE sex VARCHAR(5);\n\tDECLARE score INT;\n\tDECLARE a INT DEFAULT 0;\n\tDECLARE cur CURSOR FOR SELECT * FROM student;\n\t-- 必须在游标定义之后编写\n\tDECLARE CONTINUE HANDLER FOR 1329 SET a &#x3D; 1;\n\tOPEN cur;\n\tWHILE a &#x3D; 0 DO\n\t\tFETCH cur INTO id, &#96;name&#96;, sex, score;\n\t\tSELECT id, &#96;name&#96;, sex, score;\n\tEND WHILE;\n\tCLOSE cur;\n\tSELECT 1;\nEND\n\n我们可以声明一个异常处理器（句柄），格式如下：\n\ndeclear (continue&#x2F;exit) handler for 异常名称(ID) 做点什么\n\n我们还可以限定存储过程的参数传递，比如我们只希望用户给我们一个参数用于接收数据，而不是值传递，我们可以将其设定为OUT类型：\nCREATE PROCEDURE &#96;lbwnb&#96;(OUT a INT)\nBEGIN\n\tSELECT a;\n\tSET a &#x3D; 100;\nEND\n\n所有的参数默认为IN类型，也就是只能作为传入参数，无法为其赋值，而这里讲参数设定为OUT类型，那么参数无法将值传入，而只能被赋值。\n如果我们既希望参数可以传入也可以被重新赋值，我们可以将其修改为INOUT类型。\n\n存储引擎存储引擎就像我们电脑中的CPU，它是整个MySQL最核心的部分，数据库中的数据如何存储，数据库能够支持哪些功能，我们的增删改查请求如何执行，都是由存储引擎来决定的。\n我们可以大致了解一下以下三种存储引擎：\n\nMyISAM：MySQL5.5之前的默认存储引擎，在插入和查询的情况下性能很高，但是它不支持事务，只能添加表级锁。\nInnoDB：MySQL5.5之后的默认存储引擎，它支持ACID事务、行级锁、外键，但是性能比不过MyISAM，更加消耗资源。\nMemory：数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。\n\n我们可以使用下面的命令来查看MySQL支持的存储引擎：\nshow engines;\n\n在创建表时，我们也可以为表指定其存储引擎。\n我们还可以在配置文件中修改默认的存储引擎，在Windows 11系统下，MySQL的配置文件默认放在C:\\ProgramData\\MySQL\\MySQL Server 5.7中，注意ProgramData是个隐藏文件夹。\n\n索引注意：本小节会涉及数据结构与算法相关知识。\n索引就好像我们书的目录，每本书都有一个目录用于我们快速定位我们想要的内容在哪一页，索引也是，通过建立索引，我们就可以根据索引来快速找到想要的一条记录，大大提高查询效率。\n本版块我们会详细介绍索引的几种类型，以及索引的底层存储原理。\n单列索引单列索引只针对于某一列数据创建索引，单列索引有以下几种类型：\n\nNORMAL：普通的索引类型，完完全全相当于一本书的目录。\nUNIQUE：唯一索引，我们之前已经用过了，一旦建立唯一索引，那么整个列中将不允许出现重复数据。每个表的主键列，都有一个特殊的唯一索引，叫做Primary Key，它不仅仅要求不允许出现重复，还要求不能为NULL，它还可以自动递增。每张表可以有多个唯一索引，但是只能有一个Primary索引。\nSPATIAL：空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON，不是很常用，这里不做介绍。\nFULLTEXT：全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用like %更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。\n\n我们来看看如何使用全文索引，首先创建一张用于测试全文索引的表：\nCREATE TABLE articles (\n  id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,\n  title VARCHAR(200),\n  body TEXT,\n  FULLTEXT (body));\n\nINSERT INTO articles VALUES\n\t(NULL,&#39;MySQL Tutorial&#39;, &#39;DBMS stands for DataBase ...&#39;),\n\t(NULL,&#39;How To Use MySQL Efficiently&#39;, &#39;After you went through a ...&#39;),\n\t(NULL,&#39;Optimising MySQL&#39;,&#39;In this tutorial we will show ...&#39;),\n\t(NULL,&#39;1001 MySQL Tricks&#39;,&#39;1. Never run mysqld as root. 2. ...&#39;),\n\t(NULL,&#39;MySQL vs. YourSQL&#39;, &#39;In the following database comparison ...&#39;),\n\t(NULL,&#39;MySQL Security&#39;, &#39;When configured properly, MySQL ...&#39;);\n\n最后我们使用全文索引进行模糊匹配：\nSELECT * FROM articles WHERE MATCH (body) AGAINST (&#39;database&#39;);\n\n注意全文索引如何定义字段的，match中就必须是哪些字段，against中定义需要模糊匹配的字符串，我们用作查找的字符串实际上是被分词之后的结果，如果进行模糊匹配的不是一个词语，那么会查找失败，但是它的效率远高于以下这种写法：\nSELECT * FROM articles WHERE body like &#39;%database%&#39;;\n\n组合索引组合索引实际上就是将多行捆绑在一起，作为一个索引，它同样支持以上几种索引类型，我们可以在Navicat中进行演示。\n注意组合索引在进行匹配时，遵循最左原则。\n我们可以使用explain语句（它可以用于分析select语句的执行计划，也就是MySQL到底是如何在执行某条select语句的）来分析查询语句到底有没有通过索引进行匹配。\nexplain select * from student where name &#x3D; &#39;小王&#39;;\n\n得到的结果如下：\n\nselect_type：查询类型，上面的就是简单查询（SIMPLE）\ntable：查询的表\ntype：MySQL决定如何查找对应的记录，效率从高到低：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all\npossible_keys：执行查询时可能会用到的索引\nkey：实际使用的索引\nkey_len：Mysql在索引里使用的字节数，字段的最大可能长度\nrows：扫描的行数\nextra：附加说明\n\n索引底层原理在了解完了索引的类型之后，我们接着来看看索引是如何实现的。\n既然我们要通过索引来快速查找内容，那么如何设计索引就是我们的重点内容，因为索引是存储在硬盘上的，跟我们之前使用的HashMap之类的不同，它们都是在内存中的，但是硬盘的读取速度远小于内存的速度，每一次IO操作都会耗费大量的时间，我们也不可能把整个磁盘上的索引全部导入内存，因此我们需要考虑尽可能多的减少IO次数，索引的实现可以依靠两种数据结构，一种是我们在JavaSE阶段已经学习过的Hash表，还有一种就是B-Tree。\n我们首先来看看哈希表，实际上就是计算Hash值来快速定位：\n\n通过对Key进行散列值计算，我们可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)，但是它也存在一定的缺陷：\n\nHash索引仅仅能满足“&#x3D;”，“in”查询条件，不能使用范围查询。 \nHash碰撞问题。\n不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。\n\n那么，既然要解决这些问题，我们还有一种方案就是使用类似于二叉树那样的数据结构来存储索引，但是这样相比使用Hash索引，会牺牲一定的读取速度。\n但是这里并没有使用二叉树，而是使用了BTree，它是专门为磁盘数据读取设计的一种度为n的查找树：\n\n树中每个结点最多含有m个孩子（m &gt;&#x3D; 2）\n\n除根结点和叶子结点外，其它每个结点至少有[ceil(m &#x2F; 2)]个孩子。\n\n若根结点不是叶子结点，则至少有2个孩子。\n\n所有叶子结点都出现在同一层。\n\n每个非终端结点中包含有n个键值信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中： \n\nKi (i&#x3D;1…n)为键值，且键值按顺序升序排序K(i-1)&lt; Ki。  \nPi为指向子树根的结点，且指针P(i)指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)。  \n键值的个数n必须满足： [ceil(m &#x2F; 2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。\n\n\n\n\n比如现在我们要对键值为10的记录进行查找，过程如下：\n\n读取根节点数据（目前进行了一次IO操作）\n根据根节点数据进行判断得到10&lt;17，因为P1指向的子树中所有值都是小于17的，所以这时我们将P1指向的节点读取（目前进行了两次IO操作）\n再次进行判断，得到8&lt;10&lt;12，因为P2指向的子树中所有的值都是小于12大于8的，所以这时读取P2指向的节点（目前进行了三次IO操作）\n成功找到。\n\n我们接着来看，虽然BTree能够很好地利用二叉查找树的思想大幅度减少查找次数，但是它的查找效率还是很低，因此它的优化版本B+Tree诞生了，它拥有更稳定的查询效率和更低的IO读取次数：\n\n我们可以发现，它和BTree有一定的区别：\n\n有n棵子树的结点中含有n个键值，BTree只有n-1个。\n所有的键值信息只在叶子节点中包含，非叶子节点仅仅保存子节点的最小（或最大）值，和指向叶子节点的指针，这样相比BTree每一个节点在硬盘中存放了更少的内容（没有键值信息了）\n所有叶子节点都有一个根据大小顺序指向下一个叶子节点的指针Q，本质上数据就是一个链表。\n\n这样，读取IO的时间相比BTree就减少了很多，并且查询任何键值信息都需要完整地走到叶子节点，保证了查询的IO读取次数一致。因此MySQL默认选择B+Tree作为索引的存储数据结构。\n这是MyISAM存储引擎下的B+Tree实现：\n\n这是InnoDB存储引擎下的B+Tree实现：\n\n\nInnoDB与MyISAM实现的不同之处：\n\n数据本身就是索引的一部分（所以这里建议主键使用自增）\n非主键索引的数据实际上存储的是对应记录的主键值（因此InnoDB必须有主键，若没有也会自动查找替代）\n\n\n锁机制在JavaSE的学习中，我们在多线程板块首次用到了锁机制，当我们对某个方法或是某个代码块加锁后，除非锁的持有者释放当前的锁，否则其他线程无法进入此方法或是代码块，我们可以利用锁机制来保证多线程之间的安全性。\n在MySQL中，就很容易出现多线程同时操作表中数据的情况，如果要避免潜在的并发问题，那么我们可以使用之前讲解的事务隔离级别来处理，而事务隔离中利用了锁机制。\n\n读未提交(Read Uncommitted)：能够读取到其他事务中未提交的内容，存在脏读问题。\n读已提交(Read Committed RC)：只能读取其他事务已经提交的内容，存在不可重复读问题。\n可重复读(Repeated Read RR)：在读取某行后不允许其他事务操作此行，直到事务结束，但是依然存在幻读问题。\n串行读(Serializable)：一个事务的开始必须等待另一个事务的完成。\n\n我们可以切换隔离级别分别演示一下：\nset session transaction isolation level read uncommitted;\n\n在RR级别下，MySQL在一定程度上解决了幻读问题：\n\n在快照读（不加锁）读情况下，mysql通过mvcc来避免幻读。\n在当前读（加锁）读情况下，mysql通过next-key来避免幻读。\n\n\n\n\n\n\n\n\n\n\n**MVCC**，全称 Multi-Version Concurrency Control ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。\n读锁和写锁从对数据的操作类型上来说，锁分为读锁和写锁：\n\n读锁：也叫共享锁，当一个事务添加了读锁后，其他的事务也可以添加读锁或是读取数据，但是不能进行写操作，只能等到所有的读锁全部释放。\n写锁：也叫排他锁，当一个事务添加了写锁后，其他事务不能读不能写也不能添加任何锁，只能等待当前事务释放锁。\n\n全局锁、表锁和行锁从锁的作用范围上划分，分为全局锁、表锁和行锁：\n\n全局锁：锁作用于全局，整个数据库的所有操作全部受到锁限制。\n表锁：锁作用于整个表，所有对表的操作都会收到锁限制。\n行锁：锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持）\n\n全局锁我们首先来看全局锁，它作用于整个数据库，我们可以使用以下命令来开启读全局锁：\nflush tables with read lock;\n\n开启后，整个数据库被上读锁，我们只能去读取数据，但是不允许进行写操作（包括更新、插入、删除等）一旦执行写操作，会被阻塞，直到锁被释放，我们可以使用以下命令来解锁：\nunlock tables;\n\n除了手动释放锁之外，当我们的会话结束后，锁也会被自动释放。\n表锁表锁作用于某一张表，也是MyISAM和InnoDB存储引擎支持的方式，我们可以使用以下命令来为表添加锁：\nlock table 表名称 read&#x2F;write;\n\n在我们为表添加写锁后，我们发现其他地方是无法访问此表的，一律都被阻塞。\n行锁表锁的作用范围太广了，如果我们仅仅只是对某一行进行操作，那么大可不必对整个表进行加锁，因此InnoDB支持了行锁，我们可以使用以下命令来对某一行进行加锁：\n-- 添加读锁（共享锁）\nselect * from ... lock in share mode;\n-- 添加写锁（排他锁）\nselect * from ... for update;\n\n使用InnoDB的情况下，在执行更新、删除、插入操作时，数据库也会自动为所涉及的行添加写锁（排他锁），直到事务提交时，才会释放锁，执行普通的查询操作时，不会添加任何锁。使用MyISAM的情况下，在执行更新、删除、插入操作时，数据库会对涉及的表添加写锁，在执行查询操作时，数据库会对涉及的表添加读锁。\n提问：当我们不使用id进行选择，行锁会发生什么变化？（行锁升级）\n记录锁、间隙锁和临键锁我们知道InnoDB支持使用行锁，但是行锁比较复杂，它可以继续分为多个类型。\n记录锁（Record Locks）记录锁, 仅仅锁住索引记录的一行，在单条索引记录上加锁。Record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加写锁，这个类似于表锁，但原理上和表锁应该是完全不同的。\n间隙锁（Gap Locks）仅仅锁住一个索引区间（开区间，不包括双端端点）。在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。比如在 1、2中，间隙锁的可能值有 (-∞, 1)，(1, 2)，(2, +∞)，间隙锁可用于防止幻读，保证索引间的不会被插入数据。\n临键锁（Next-Key Locks）Record lock + Gap lock，左开右闭区间。默认情况下，InnoDB正是使用Next-key Locks来锁定记录（如select … for update语句）它还会根据场景进行灵活变换：\n\n\n\n场景\n转换\n\n\n\n使用唯一索引进行精确匹配，但表中不存在记录\n自动转换为 Gap Locks\n\n\n使用唯一索引进行精确匹配，且表中存在记录\n自动转换为 Record Locks\n\n\n使用非唯一索引进行精确匹配\n不转换\n\n\n使用唯一索引进行范围匹配\n不转换，但是只锁上界，不锁下界\n\n\nhttps://zhuanlan.zhihu.com/p/48269420\n","slug":"JavaSSM笔记（四）","date":"2022-03-05T16:22:54.848Z","categories_index":"JavaSSM笔记","tags_index":"JavaSSM笔记","author_index":"YangChao"},{"id":"7706992de04d833db29722d37e1933b8","title":"JavaSSM笔记（三）","content":"\nSpringSecurity本章我们会一边讲解SpringSecurity框架，一边从头开始编写图书管理系统。\n  SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：\n\n认证 （用户登录）\n授权 （此用户能够做哪些事情）\n攻击防护 （防止伪造身份攻击）\n\n我们为什么需要使用更加专业的全新验证框架，还要从CSRF说起。\nCSRF跨站请求伪造攻击我们时常会在QQ上收到别人发送的钓鱼网站链接，只要你在上面登陆了你的QQ账号，那么不出意外，你的号已经在别人手中了。实际上这一类网站都属于恶意网站，专门用于盗取他人信息，执行非法操作，甚至获取他人账户中的财产，非法转账等。而这里，我们需要了解一种比较容易发生的恶意操作，从不法分子的角度去了解整个流程。\n我们在JavaWeb阶段已经了解了Session和Cookie的机制，在一开始的时候，服务端会给浏览器一个名为JSESSION的Cookie信息作为会话的唯一凭据，只要用户携带此Cookie访问我们的网站，那么我们就可以认定此会话属于哪个浏览器。因此，只要此会话的用户执行了登录操作，那么就可以随意访问个人信息等内容。\n比如现在，我们的服务器新增了一个转账的接口，用户登录之后，只需要使用POST请求携带需要转账的金额和转账人访问此接口就可以进行转账操作：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index(HttpSession session)&#123;\n    session.setAttribute(&quot;login&quot;, true);   &#x2F;&#x2F;这里就正常访问一下index表示登陆\n    return &quot;index&quot;;\n&#125;\n\n@RequestMapping(value &#x3D; &quot;&#x2F;pay&quot;, method &#x3D; RequestMethod.POST, produces &#x3D; &quot;text&#x2F;html;charset&#x3D;utf-8&quot;) &#x2F;&#x2F;这里要设置一下produces不然会乱码\n@ResponseBody\npublic String pay(String account,\n                  int amount,\n                  @SessionAttribute(&quot;login&quot;) Boolean isLogin)&#123;\n    if (isLogin) return &quot;成功转账 ￥&quot;+amount+&quot; 给：&quot;+account;\n    else return &quot;转账失败，您没有登陆！&quot;;\n&#125;\n\n那么，大家有没有想过这样一个问题，我们为了搜索学习资料时可能一不小心访问了一个恶意网站，而此网站携带了这样一段内容：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;我是(恶)学(意)习网站&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;div&gt;对不起，您还没有充值本站的学习会员，请先充值后再观看学习视频&lt;&#x2F;div&gt;\n        &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;mvc&#x2F;pay&quot; method&#x3D;&quot;post&quot;&gt;\n            &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;account&quot; value&#x3D;&quot;hacker&quot; hidden&gt;\n            &lt;input type&#x3D;&quot;number&quot; name&#x3D;&quot;amount&quot; value&#x3D;&quot;666666&quot; hidden&gt;\n            &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;点我充值会员，观看完整视频&quot;&gt;\n        &lt;&#x2F;form&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注意这个页面并不是我们官方提供的页面，而是不法分子搭建的恶意网站。我们发现此页面中有一个表单，但是表单中的两个输入框被隐藏了，而我们看到的只有一个按钮，我们不知道这是一个表单，也不知道表单会提交给那个地址，这时整个页面就非常有迷惑性了。如果我们点击此按钮，那么整个表单的数据会以POST的形式发送给我们的服务端（会携带之前登陆我们网站的Cookie信息），但是这里很明显是另一个网站跳转，通过这样的方式，恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作，当你发现上当受骗时，钱已经被转走了。\n而这种构建恶意页面，引导用户访问对应网站执行操作的方式称为：跨站请求伪造（CSRF，Cross Site Request Forgery）\n显然，我们之前编写的图书管理系统就存在这样的安全漏洞，而SpringSecurity就很好地解决了这样的问题。\n\n开发环境搭建我们依然使用之前的模板来搭建图书管理系统项目。\n导入以下依赖：\n&lt;!-- 建议为各个依赖进行分类，到后期我们的项目可能会导入很多依赖，添加注释会大幅度提高阅读效率 --&gt;\n&lt;dependencies&gt;\n    &lt;!--  Spring框架依赖  --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-security-web&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.5.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n  \t&lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-security-config&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.5.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.3.14&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;!--  持久层框架依赖  --&gt;\n\t\t&lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;8.0.27&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.0.6&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.5.7&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;5.3.14&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.zaxxer&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;HikariCP&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.4.5&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n\n    &lt;!--  其他工具框架依赖：Lombok、Slf4j  --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.18.22&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;slf4j-jdk14&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.7.32&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;!--  ServletAPI  --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.0.1&lt;&#x2F;version&gt;\n        &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;!--  JUnit依赖  --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-engine&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;\n        &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n接着创建Initializer来配置Web应用程序：\npublic class MvcInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;RootConfiguration.class&#125;;\n    &#125;\n\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;MvcConfiguration.class&#125;;\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n&#125;\n\n创建Mvc配置类：\n@ComponentScan(&quot;book.manager.controller&quot;)\n@Configuration\n@EnableWebMvc\npublic class MvcConfiguration implements WebMvcConfigurer &#123;\n\n    &#x2F;&#x2F;我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面\n    @Bean\n    public ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)&#123;\n        ThymeleafViewResolver resolver &#x3D; new ThymeleafViewResolver();\n        resolver.setOrder(1);\n        resolver.setCharacterEncoding(&quot;UTF-8&quot;);\n        resolver.setTemplateEngine(springTemplateEngine);\n        return resolver;\n    &#125;\n\n    &#x2F;&#x2F;配置模板解析器\n    @Bean\n    public SpringResourceTemplateResolver templateResolver()&#123;\n        SpringResourceTemplateResolver resolver &#x3D; new SpringResourceTemplateResolver();\n        resolver.setSuffix(&quot;.html&quot;);\n        resolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;template&#x2F;&quot;);\n        return resolver;\n    &#125;\n\n    &#x2F;&#x2F;配置模板引擎Bean\n    @Bean\n    public SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver)&#123;\n        SpringTemplateEngine engine &#x3D; new SpringTemplateEngine();\n        engine.setTemplateResolver(resolver);\n        return engine;\n    &#125;\n\n    &#x2F;&#x2F;开启静态资源处理\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n        configurer.enable();\n    &#125;\n\n    &#x2F;&#x2F;静态资源路径配置\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(&quot;&#x2F;static&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;WEB-INF&#x2F;static&#x2F;&quot;);\n    &#125;\n&#125;\n\n创建Root配置类：\n@Configuration\npublic class RootConfiguration &#123;\n\n&#125;\n\n最后创建一个专用于响应页面的Controller即可：\n&#x2F;**\n * 专用于处理页面响应的控制器\n *&#x2F;\n@Controller\npublic class PageController &#123;\n\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    public String login()&#123;\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n接着我们需要将前端页面放到对应的文件夹中，然后开启服务器并通过浏览器，成功访问。\n接着我们需要配置SpringSecurity，与Mvc一样，需要一个初始化器：\npublic class SecurityInitializer extends AbstractSecurityWebApplicationInitializer &#123;\n    &#x2F;&#x2F;不用重写任何内容\n  \t&#x2F;&#x2F;这里实际上会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的，我们之后再探讨\n&#125;\n\n接着我们需要再创建一个配置类用于配置SpringSecurity：\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n\t\t&#x2F;&#x2F;继承WebSecurityConfigurerAdapter，之后会进行配置\n&#125;\n\n接着在根容器中添加此配置文件即可：\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n    return new Class[]&#123;RootConfiguration.class, SecurityConfiguration.class&#125;;\n&#125;\n\n这样，SpringSecurity的配置就完成了，我们再次运行项目，会发现无法进入的我们的页面中，无论我们访问哪个页面，都会进入到SpringSecurity为我们提供的一个默认登录页面，之后我们会讲解如何进行配置。\n至此，项目环境搭建完成。\n\n认证直接认证既然我们的图书管理系统要求用户登录之后才能使用，所以我们首先要做的就是实现用户验证，要实现用户验证，我们需要进行一些配置：\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    BCryptPasswordEncoder encoder &#x3D; new BCryptPasswordEncoder();  &#x2F;&#x2F;这里使用SpringSecurity提供的BCryptPasswordEncoder\n    auth\n            .inMemoryAuthentication() &#x2F;&#x2F;直接验证方式，之后会讲解使用数据库验证\n            .passwordEncoder(encoder) &#x2F;&#x2F;密码加密器\n            .withUser(&quot;test&quot;)   &#x2F;&#x2F;用户名\n            .password(encoder.encode(&quot;123456&quot;))   &#x2F;&#x2F;这里需要填写加密后的密码\n            .roles(&quot;user&quot;);   &#x2F;&#x2F;用户的角色（之后讲解）\n&#125;\n\nSpringSecurity的密码校验并不是直接使用原文进行比较，而是使用加密算法将密码进行加密（更准确地说应该进行Hash处理，此过程是不可逆的，无法解密），最后将用户提供的密码以同样的方式加密后与密文进行比较。对于我们来说，用户提供的密码属于隐私信息，直接明文存储并不好，而且如果数据库内容被窃取，那么所有用户的密码将全部泄露，这是我们不希望看到的结果，我们需要一种既能隐藏用户密码也能完成认证的机制，而Hash处理就是一种很好的解决方案，通过将用户的密码进行Hash值计算，计算出来的结果无法还原为原文，如果需要验证是否与此密码一致，那么需要以同样的方式加密再比较两个Hash值是否一致，这样就很好的保证了用户密码的安全性。\n\n我们这里使用的是SpringSecurity提供的BCryptPasswordEncoder，至于加密过程，这里不做深入讲解。\n现在，我们可以尝试使用此账号登录，在登录后，就可以随意访问我们的网站内容了。\n使用数据库认证前面我们已经实现了直接认证的方式，那么如何将其连接到数据库，通过查询数据库中的内容来进行用户登录呢？\n首先我们需要将加密后的密码添加到数据库中作为用户密码：\npublic class MainTest &#123;\n\n    @Test\n    public void test()&#123;\n        BCryptPasswordEncoder encoder &#x3D; new BCryptPasswordEncoder();\n        System.out.println(encoder.encode(&quot;123456&quot;));\n    &#125;\n&#125;\n\n这里编写一个测试来完成。\n然后我们需要创建一个Service实现，实现的是UserDetailsService，它支持我们自己返回一个UserDetails对象，我们只需直接返回一个包含数据库中的用户名、密码等信息的UserDetails即可，SpringSecurity会自动进行比对。\n@Service\npublic class UserAuthService implements UserDetailsService &#123;\n\n    @Resource\n    UserMapper mapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n        String password &#x3D; mapper.getPasswordByUsername(s);  &#x2F;&#x2F;从数据库根据用户名获取密码\n        if(password &#x3D;&#x3D; null)\n            throw new UsernameNotFoundException(&quot;登录失败，用户名或密码错误！&quot;);\n        return User   &#x2F;&#x2F;这里需要返回UserDetails，SpringSecurity会根据给定的信息进行比对\n                .withUsername(s)\n                .password(password)   &#x2F;&#x2F;直接从数据库取的密码\n                .roles(&quot;user&quot;)   &#x2F;&#x2F;用户角色\n                .build();\n    &#125;\n&#125;\n\n别忘了在配置类中进行扫描，将其注册为Bean，接着我们需要编写一个Mapper用于和数据库交互：\n@Mapper\npublic interface UserMapper &#123;\n\n    @Select(&quot;select password from users where username &#x3D; #&#123;username&#125;&quot;)\n    String getPasswordByUsername(String username);\n&#125;\n\n和之前一样，配置一下Mybatis和数据源：\n@ComponentScans(&#123;\n        @ComponentScan(&quot;book.manager.service&quot;)\n&#125;)\n@MapperScan(&quot;book.manager.mapper&quot;)\n@Configuration\npublic class RootConfiguration &#123;\n    @Bean\n    public DataSource dataSource()&#123;\n        HikariDataSource dataSource &#x3D; new HikariDataSource();\n        dataSource.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;study&quot;);\n        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        dataSource.setUsername(&quot;root&quot;);\n        dataSource.setPassword(&quot;123456&quot;);\n        return dataSource;\n    &#125;\n\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactoryBean(@Autowired DataSource dataSource)&#123;\n        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();\n        bean.setDataSource(dataSource);\n        return bean;\n    &#125;\n&#125;\n\n最后再修改一下Security配置：\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth\n      .userDetailsService(service)   &#x2F;&#x2F;使用自定义的Service实现类进行验证\n      .passwordEncoder(new BCryptPasswordEncoder());   &#x2F;&#x2F;依然使用BCryptPasswordEncoder\n&#125;\n\n这样，登陆就会从数据库中进行查询。\n自定义登录界面前面我们已经了解了如何实现数据库权限验证，那么现在我们接着来看看，如何将登陆页面修改为我们自定义的样式。\n首先我们要了解一下SpringSecurity是如何进行登陆验证的，我们可以观察一下默认的登陆界面中，表单内有哪些内容：\n&lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;form class&#x3D;&quot;form-signin&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;&#x2F;book_manager&#x2F;login&quot;&gt;\n        &lt;h2 class&#x3D;&quot;form-signin-heading&quot;&gt;Please sign in&lt;&#x2F;h2&gt;\n        &lt;p&gt;\n          &lt;label for&#x3D;&quot;username&quot; class&#x3D;&quot;sr-only&quot;&gt;Username&lt;&#x2F;label&gt;\n          &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Username&quot; required&#x3D;&quot;&quot; autofocus&#x3D;&quot;&quot;&gt;\n        &lt;&#x2F;p&gt;\n        &lt;p&gt;\n          &lt;label for&#x3D;&quot;password&quot; class&#x3D;&quot;sr-only&quot;&gt;Password&lt;&#x2F;label&gt;\n          &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;Password&quot; required&#x3D;&quot;&quot;&gt;\n        &lt;&#x2F;p&gt;\n&lt;input name&#x3D;&quot;_csrf&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;83421936-b84b-44e3-be47-58bb2c14571a&quot;&gt;\n        &lt;button class&#x3D;&quot;btn btn-lg btn-primary btn-block&quot; type&#x3D;&quot;submit&quot;&gt;Sign in&lt;&#x2F;button&gt;\n      &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;\n\n我们发现，首先有一个用户名的输入框和一个密码的输入框，我们需要在其中填写用户名和密码，但是我们发现，除了这两个输入框以外，还有一个input标签，它是隐藏的，并且它存储了一串类似于Hash值的东西，名称为”_csrf”，其实看名字就知道，这玩意八成都是为了防止CSRF攻击而存在的。\n从Spring Security 4.0开始，默认情况下会启用CSRF保护，以防止CSRF攻击应用程序，Spring Security CSRF会针对PATCH，POST，PUT和DELETE方法的请求（不仅仅只是登陆请求，这里指的是任何请求路径）进行防护，而这里的登陆表单正好是一个POST类型的请求。在默认配置下，无论是否登陆，页面中只要发起了PATCH，POST，PUT和DELETE请求一定会被拒绝，并返回403错误（注意，这里是个究极大坑），需要在请求的时候加入csrfToken才行，也就是”83421936-b84b-44e3-be47-58bb2c14571a”，正是csrfToken，如果提交的是表单类型的数据，那么表单中必须包含此Token字符串，键名称为”_csrf”；如果是JSON数据格式发送的，那么就需要在请求头中包含此Token字符串。\n综上所述，我们最后提交的登陆表单，除了必须的用户名和密码，还包含了一个csrfToken字符串用于验证，防止攻击。\n因此，我们在编写自己的登陆页面时，需要添加这样一个输入框：\n&lt;input type&#x3D;&quot;text&quot; th:name&#x3D;&quot;$&#123;_csrf.getParameterName()&#125;&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; hidden&gt;\n\n隐藏即可，但是必须要有，而Token的键名称和Token字符串可以通过Thymeleaf从Model中获取，SpringSecurity会自动将Token信息添加到Model中。\n接着我们就可以将我们自己的页面替换掉默认的页面了，我们需要重写另一个方法来实现：\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            .authorizeRequests()   &#x2F;&#x2F;首先需要配置哪些请求会被拦截，哪些请求必须具有什么角色才能访问\n            .antMatchers(&quot;&#x2F;static&#x2F;**&quot;).permitAll()    &#x2F;&#x2F;静态资源，使用permitAll来运行任何人访问（注意一定要放在前面）\n            .antMatchers(&quot;&#x2F;**&quot;).hasRole(&quot;user&quot;)     &#x2F;&#x2F;所有请求必须登陆并且是user角色才可以访问（不包含上面的静态资源）\n&#125;\n\n首先我们需要配置拦截规则，也就是当用户未登录时，哪些路径可以访问，哪些路径不可以访问，如果不可以访问，那么会被自动重定向到登陆页面。\n接着我们需要配置表单登陆和登录页面：\n.formLogin()       &#x2F;&#x2F;配置Form表单登陆\n.loginPage(&quot;&#x2F;login&quot;)       &#x2F;&#x2F;登陆页面地址（GET）\n.loginProcessingUrl(&quot;&#x2F;doLogin&quot;)    &#x2F;&#x2F;form表单提交地址（POST）\n.defaultSuccessUrl(&quot;&#x2F;index&quot;)    &#x2F;&#x2F;登陆成功后跳转的页面，也可以通过Handler实现高度自定义\n.permitAll()    &#x2F;&#x2F;登陆页面也需要允许所有人访问\n\n需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为/login，登陆请求地址为/doLogin，登陆页面需要我们自己去编写Controller来实现，登陆请求提交处理由SpringSecurity提供，只需要写路径就可以了。\n@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login()&#123;\n    return &quot;login&quot;;\n&#125;\n\n配置好后，我们还需要配置一下退出登陆操作：\n.and()\n.logout()\n.logoutUrl(&quot;&#x2F;logout&quot;)    &#x2F;&#x2F;退出登陆的请求地址\n.logoutSuccessUrl(&quot;&#x2F;login&quot;);    &#x2F;&#x2F;退出后重定向的地址\n\n注意这里的退出登陆请求也必须是POST请求方式（因为开启了CSFR防护，需要添加Token），否则无法访问，这里主页面就这样写：\n&lt;body&gt;\n    &lt;form action&#x3D;&quot;logout&quot; method&#x3D;&quot;post&quot;&gt;\n        &lt;input type&#x3D;&quot;text&quot; th:name&#x3D;&quot;$&#123;_csrf.getParameterName()&#125;&quot; th:value&#x3D;&quot;$&#123;_csrf.token&#125;&quot; hidden&gt;\n        &lt;button&gt;退出登陆&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n登陆成功后，点击退出登陆按钮，就可以成功退出并回到登陆界面了。\n由于我们在学习的过程中暂时用不到CSFR防护，因此可以将其关闭，这样直接使用get请求也可以退出登陆，并且登陆请求中无需再携带Token了，推荐关闭，因为不关闭后面可能会因为没考虑CSRF防护而遇到一连串的问题：\n.and()\n.csrf().disable();\n\n这样就可以直接关闭此功能了，但是注意，这样将会导致您的Web网站存在安全漏洞。（这里为了之后省事，就关闭保护了，但是一定要记得在不关闭的情况下需要携带Token访问）\n\n授权用户登录后，可能会根据用户当前是身份进行角色划分，比如我们最常用的QQ，一个QQ群里面，有群主、管理员和普通群成员三种角色，其中群主具有最高权限，群主可以管理整个群的任何板块，并且具有解散和升级群的资格，而管理员只有群主的一部分权限，只能用于日常管理，普通群成员则只能进行最基本的聊天操作。\n对于我们来说，用户的一个操作实际上就是在访问我们提供的接口(编写的对应访问路径的Servlet），比如登陆，就需要调用/login接口，退出登陆就要调用&#x2F;logout接口，而我们之前的图书管理系统中，新增图书、删除图书，所有的操作都有着对应的Servlet来进行处理。因此，从我们开发者的角度来说，决定用户能否使用某个功能，只需要决定用户是否能够访问对应的Servlet即可。\n我们可以大致像下面这样进行划分：\n\n群主：/login、/logout、/chat、/edit、/delete、/upgrade\n管理员：/login、/logout、/chat、/edit\n普通群成员：/login、/logout、/chat\n\n也就是说，我们需要做的就是指定哪些请求可以由哪些用户发起。\nSpringSecurity为我们提供了两种授权方式：\n\n基于权限的授权：只要拥有某权限的用户，就可以访问某个路径\n基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径\n\n两者只是概念上的不同，实际上使用起来效果差不多。这里我们就先演示以角色方式来进行授权。\n基于角色的授权现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。\n首先我们需要对数据库中的角色表进行一些修改，添加一个用户角色字段，并创建一个新的用户，Test用户的角色为user，而Admin用户的角色为admin。\n接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：\nhttp\n        .authorizeRequests()\n        .antMatchers(&quot;&#x2F;static&#x2F;**&quot;).permitAll()\n  \t\t\t.antMatchers(&quot;&#x2F;index&quot;).hasAnyRole(&quot;user&quot;, &quot;admin&quot;)   &#x2F;&#x2F;index页面可以由user或admin访问\n        .anyRequest().hasRole(&quot;admin&quot;)   &#x2F;&#x2F;除了上面以外的所有内容，只能是admin访问\n\n接着我们需要稍微修改一下验证逻辑，首先创建一个实体类用于表示数据库中的用户名、密码和角色：\n@Data\npublic class AuthUser &#123;\n    String username;\n    String password;\n    String role;\n&#125;\n\n接着修改一下Mapper：\n@Mapper\npublic interface UserMapper &#123;\n\n    @Select(&quot;select * from users where username &#x3D; #&#123;username&#125;&quot;)\n    AuthUser getPasswordByUsername(String username);\n&#125;\n\n最后再修改一下Service：\n@Override\npublic UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n    AuthUser user &#x3D; mapper.getPasswordByUsername(s);\n    if(user &#x3D;&#x3D; null)\n        throw new UsernameNotFoundException(&quot;登录失败，用户名或密码错误！&quot;);\n    return User\n            .withUsername(user.getUsername())\n            .password(user.getPassword())\n            .roles(user.getRole())\n            .build();\n&#125;\n\n现在我们可以尝试登陆，接着访问一下/index和/admin两个页面。\n基于权限的授权基于权限的授权与角色类似，需要以hasAnyAuthority或hasAuthority进行判断：\n.anyRequest().hasAnyAuthority(&quot;page:index&quot;)\n\n@Override\npublic UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;\n    AuthUser user &#x3D; mapper.getPasswordByUsername(s);\n    if(user &#x3D;&#x3D; null)\n        throw new UsernameNotFoundException(&quot;登录失败，用户名或密码错误！&quot;);\n    return User\n            .withUsername(user.getUsername())\n            .password(user.getPassword())\n            .authorities(&quot;page:index&quot;)\n            .build();\n&#125;\n\n使用注解判断权限除了直接配置以外，我们还可以以注解形式直接配置，首先需要在配置类（注意这里是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：\n@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n\n接着我们可以直接在需要添加权限验证的请求映射上添加注解：\n@PreAuthorize(&quot;hasRole(&#39;user&#39;)&quot;)   &#x2F;&#x2F;判断是否为user角色，只有此角色才可以访问\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;index&quot;;\n&#125;\n\n通过添加@PreAuthorize注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。\n这里其实是使用了SpEL表达式，相当于可以执行一些逻辑再得到结果，而不是直接传值，官方文档地址：https://docs.spring.io/spring-framework/docs/5.2.13.RELEASE/spring-framework-reference/core.html#expressions，内容比较多，不是重点，这里就不再详细介绍了。\n同样的还有@PostAuthorize注解，但是它是在方法执行之后再进行拦截：\n@PostAuthorize(&quot;hasRole(&#39;user&#39;)&quot;)\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    System.out.println(&quot;执行了&quot;);\n    return &quot;index&quot;;\n&#125;\n\n除了Controller以外，只要是由Spring管理的Bean都可以使用注解形式来控制权限，只要不具备访问权限，那么就无法执行方法并且会返回403页面。\n@Service\npublic class UserService &#123;\n\n    @PreAuthorize(&quot;hasAnyRole(&#39;user&#39;)&quot;)\n    public void test()&#123;\n        System.out.println(&quot;成功执行&quot;);\n    &#125;\n&#125;\n\n注意Service是由根容器进行注册，需要在Security配置类上添加@EnableGlobalMethodSecurity注解才可以生效。与具有相同功能的还有@Secure但是它不支持SpEL表达式的权限表示形式，并且需要添加”ROLE_”前缀，这里就不做演示了。\n我们还可以使用@PreFilter和@PostFilter对集合类型的参数或返回值进行过滤。\n比如：\n@PreFilter(&quot;filterObject.equals(&#39;lbwnb&#39;)&quot;)   &#x2F;&#x2F;filterObject代表集合中每个元素，只要满足条件的元素才会留下\npublic void test(List&lt;String&gt; list)&#123;\n    System.out.println(&quot;成功执行&quot;+list);\n&#125;\n\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    list.add(&quot;lbwnb&quot;);\n    list.add(&quot;yyds&quot;);\n    service.test(list);\n    return &quot;index&quot;;\n&#125;\n\n与@PreFilter类似的@PostFilter这里就不做演示了，它用于处理返回值，使用方法是一样的。\n当有多个集合时，需要使用filterTarget进行指定：\n@PreFilter(value &#x3D; &quot;filterObject.equals(&#39;lbwnb&#39;)&quot;, filterTarget &#x3D; &quot;list2&quot;)\npublic void test(List&lt;String&gt; list, List&lt;String&gt; list2)&#123;\n    System.out.println(&quot;成功执行&quot;+list);\n&#125;\n\n\n记住我我们的网站还有一个重要的功能，就是记住我，也就是说我们可以在登陆之后的一段时间内，无需再次输入账号和密码进行登陆，相当于服务端已经记住当前用户，再次访问时就可以免登陆进入，这是一个非常常用的功能。\n我们之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦，那么能否有一种更加高效的记住我功能实现呢？\nSpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。并且我们需要进行简单配置，即可开启记住我功能：\n.and()\n.rememberMe()   &#x2F;&#x2F;开启记住我功能\n.rememberMeParameter(&quot;remember&quot;)  &#x2F;&#x2F;登陆请求表单中需要携带的参数，如果携带，那么本次登陆会被记住\n.tokenRepository(new InMemoryTokenRepositoryImpl())  &#x2F;&#x2F;这里使用的是直接在内存中保存的TokenRepository实现\n  &#x2F;&#x2F;TokenRepository有很多种实现，InMemoryTokenRepositoryImpl直接基于Map实现的，缺点就是占内存、服务器重启后记住我功能将失效\n  &#x2F;&#x2F;后面我们还会讲解如何使用数据库来持久化保存Token信息\n\n接着我们需要在前端修改一下记住我勾选框的名称，将名称修改与上面一致，如果上面没有配置名称，那么默认使用”remember-me”作为名称：\n&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember&quot; class&#x3D;&quot;ad-checkbox&quot;&gt;\n\n现在我们启动服务器，在登陆时勾选记住我勾选框，观察Cookie的变化。\n虽然现在已经可以实现记住我功能了，但是还有一定的缺陷，如果服务器重新启动（因为Token信息全部存在HashMap中，也就是存在内存中），那么所有记录的Token信息将全部丢失，这时即使浏览器携带了之前的Token也无法恢复之前登陆的身份。\n我们可以将Token信息记录全部存放到数据库中（学习了Redis之后还可以放到Redis服务器中）利用数据库的持久化存储机制，即使服务器重新启动，所有的Token信息也不会丢失，配置数据库存储也很简单：\n@Resource\nPersistentTokenRepository repository;\n\n@Bean\npublic PersistentTokenRepository jdbcRepository(@Autowired DataSource dataSource)&#123;\n    JdbcTokenRepositoryImpl repository &#x3D; new JdbcTokenRepositoryImpl();  &#x2F;&#x2F;使用基于JDBC的实现\n    repository.setDataSource(dataSource);   &#x2F;&#x2F;配置数据源\n  \trepository.setCreateTableOnStartup(true);   &#x2F;&#x2F;启动时自动创建用于存储Token的表（建议第一次启动之后删除该行）\n    return repository;\n&#125;\n\n.and()\n.rememberMe()\n.rememberMeParameter(&quot;remember&quot;)\n.tokenRepository(repository)\n.tokenValiditySeconds(60 * 60 * 24 * 7)  &#x2F;&#x2F;Token的有效时间（秒）默认为14天\n\n稍后服务器启动我们可以观察一下数据库，如果出现名为persistent_logins的表，那么证明配置没有问题。\n当我们登陆并勾选了记住我之后，那么数据库中会新增一条Token记录。\n\nSecurityContext用户登录之后，怎么获取当前已经登录用户的信息呢？通过使用SecurityContextHolder就可以很方便地得到SecurityContext对象了，我们可以直接使用SecurityContext对象来获取当前的认证信息：\n@RequestMapping(&quot;&#x2F;index&quot;)\n    public String index()&#123;\n        SecurityContext context &#x3D; SecurityContextHolder.getContext();\n        Authentication authentication &#x3D; context.getAuthentication();\n        User user &#x3D; (User) authentication.getPrincipal();\n        System.out.println(user.getUsername());\n        System.out.println(user.getAuthorities());\n        return &quot;index&quot;;\n    &#125;\n\n通过SecurityContext我们就可以快速获取当前用户的名称和授权信息等。\n除了这种方式以外，我们还可以直接从Session中获取：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index(@SessionAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;) SecurityContext context)&#123;\n    Authentication authentication &#x3D; context.getAuthentication();\n    User user &#x3D; (User) authentication.getPrincipal();\n    System.out.println(user.getUsername());\n    System.out.println(user.getAuthorities());\n    return &quot;index&quot;;\n&#125;\n\n注意SecurityContextHolder是有一定的存储策略的，SecurityContextHolder中的SecurityContext对象会在一开始请求到来时被设定，至于存储方式其实是由存储策略决定的，如果我们这样编写，那么在默认情况下是无法获取到认证信息的：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    new Thread(() -&gt; &#123;   &#x2F;&#x2F;创建一个子线程去获取\n        SecurityContext context &#x3D; SecurityContextHolder.getContext();\n        Authentication authentication &#x3D; context.getAuthentication();\n        User user &#x3D; (User) authentication.getPrincipal();   &#x2F;&#x2F;NPE\n        System.out.println(user.getUsername());\n        System.out.println(user.getAuthorities()); \n    &#125;);\n    return &quot;index&quot;;\n&#125;\n\n这是因为SecurityContextHolder的存储策略默认是MODE_THREADLOCAL，它是基于ThreadLocal实现的，getContext()方法本质上调用的是对应的存储策略实现的方法：\npublic static SecurityContext getContext() &#123;\n    return strategy.getContext();\n&#125;\n\nSecurityContextHolderStrategy有三个实现类：\n\nGlobalSecurityContextHolderStrategy：全局模式，不常用\nThreadLocalSecurityContextHolderStrategy：基于ThreadLocal实现，线程内可见\nInheritableThreadLocalSecurityContextHolderStrategy：基于InheritableThreadLocal实现，线程和子线程可见\n\n因此，如果上述情况需要在子线程中获取，那么需要修改SecurityContextHolder的存储策略，在初始化的时候设置：\n@PostConstruct\npublic void init()&#123;\n    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n&#125;\n\n这样在子线程中也可以获取认证信息了。\n因为用户的验证信息是基于SecurityContext进行判断的，我们可以直接修改SecurityContext的内容，来手动为用户进行登陆：\n@RequestMapping(&quot;&#x2F;auth&quot;)\n@ResponseBody\npublic String auth()&#123;\n    SecurityContext context &#x3D; SecurityContextHolder.getContext();  &#x2F;&#x2F;获取SecurityContext对象（当前会话肯定是没有登陆的）\n    UsernamePasswordAuthenticationToken token &#x3D; new UsernamePasswordAuthenticationToken(&quot;Test&quot;, null,\n            AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ROLE_user&quot;));  &#x2F;&#x2F;手动创建一个UsernamePasswordAuthenticationToken对象，也就是用户的认证信息，角色需要添加ROLE_前缀，权限直接写\n    context.setAuthentication(token);  &#x2F;&#x2F;手动为SecurityContext设定认证信息\n    return &quot;Login success！&quot;;\n&#125;\n\n在未登陆的情况下，访问此地址将直接进行手动登陆，再次访问/index页面，可以直接访问，说明手动设置认证信息成功。\n疑惑：SecurityContext这玩意不是默认线程独占吗，那每次请求都是一个新的线程，按理说上一次的SecurityContext对象应该没了才对啊，为什么再次请求依然能够继续使用上一次SecurityContext中的认证信息呢？\nSecurityContext的生命周期：请求到来时从Session中取出，放入SecurityContextHolder中，请求结束时从SecurityContextHolder取出，并放到Session中，实际上就是依靠Session来存储的，一旦会话过期验证信息也跟着消失。\n\nSpringSecurity原理注意：本小节内容作为选学内容，但是难度比前两章的源码部分简单得多。\n最后我们再来聊一下SpringSecurity的实现原理，它本质上是依靠N个Filter实现的，也就是一个完整的过滤链（注意这里是过滤器，不是拦截器）\n我们就从AbstractSecurityWebApplicationInitializer开始下手，我们来看看它配置了什么：\n&#x2F;&#x2F;此方法会在启动时被调用\npublic final void onStartup(ServletContext servletContext) &#123;\n    this.beforeSpringSecurityFilterChain(servletContext);\n    if (this.configurationClasses !&#x3D; null) &#123;\n        AnnotationConfigWebApplicationContext rootAppContext &#x3D; new AnnotationConfigWebApplicationContext();\n        rootAppContext.register(this.configurationClasses);\n        servletContext.addListener(new ContextLoaderListener(rootAppContext));\n    &#125;\n\n    if (this.enableHttpSessionEventPublisher()) &#123;\n        servletContext.addListener(&quot;org.springframework.security.web.session.HttpSessionEventPublisher&quot;);\n    &#125;\n\n    servletContext.setSessionTrackingModes(this.getSessionTrackingModes());\n  \t&#x2F;&#x2F;重点在这里，这里插入了关键的FilterChain\n    this.insertSpringSecurityFilterChain(servletContext);\n    this.afterSpringSecurityFilterChain(servletContext);\n&#125;\n\nprivate void insertSpringSecurityFilterChain(ServletContext servletContext) &#123;\n    String filterName &#x3D; &quot;springSecurityFilterChain&quot;;\n  \t&#x2F;&#x2F;创建了一个DelegatingFilterProxy对象，它本质上也是一个Filter\n    DelegatingFilterProxy springSecurityFilterChain &#x3D; new DelegatingFilterProxy(filterName);\n    String contextAttribute &#x3D; this.getWebApplicationContextAttribute();\n    if (contextAttribute !&#x3D; null) &#123;\n        springSecurityFilterChain.setContextAttribute(contextAttribute);\n    &#125;\n\t\t&#x2F;&#x2F;通过ServletContext注册DelegatingFilterProxy这个Filter\n    this.registerFilter(servletContext, true, filterName, springSecurityFilterChain);\n&#125;\n\n我们接着来看看，DelegatingFilterProxy在做什么：\n&#x2F;&#x2F;这个是初始化方法，它由GenericFilterBean（父类）定义，在afterPropertiesSet方法中被调用\nprotected void initFilterBean() throws ServletException &#123;\n    synchronized(this.delegateMonitor) &#123;\n        if (this.delegate &#x3D;&#x3D; null) &#123;\n            if (this.targetBeanName &#x3D;&#x3D; null) &#123;\n                this.targetBeanName &#x3D; this.getFilterName();\n            &#125;\n\n            WebApplicationContext wac &#x3D; this.findWebApplicationContext();\n            if (wac !&#x3D; null) &#123;\n              \t&#x2F;&#x2F;耐心点，套娃很正常\n                this.delegate &#x3D; this.initDelegate(wac);\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\nprotected Filter initDelegate(WebApplicationContext wac) throws ServletException &#123;\n    String targetBeanName &#x3D; this.getTargetBeanName();\n    Assert.state(targetBeanName !&#x3D; null, &quot;No target bean name set&quot;);\n  \t&#x2F;&#x2F;这里通过WebApplicationContext获取了一个Bean\n    Filter delegate &#x3D; (Filter)wac.getBean(targetBeanName, Filter.class);\n    if (this.isTargetFilterLifecycle()) &#123;\n        delegate.init(this.getFilterConfig());\n    &#125;\n\n  \t&#x2F;&#x2F;返回Filter\n    return delegate;\n&#125;\n\n这里我们需要添加一个断点来查看到底获取到了什么Bean。\n通过断点调试，我们发现这里放回的对象是一个FilterChainProxy类型的，并且调用了它的初始化方法，但是FilterChainProxy类中并没有重写init方法或是initFilterBean方法。\n我们倒回去看，当Filter返回之后，DelegatingFilterProxy的一个成员变量delegate被赋值为得到的Filter，也就是FilterChainProxy对象，接着我们来看看，DelegatingFilterProxy是如何执行doFilter方法的。\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n    Filter delegateToUse &#x3D; this.delegate;\n    if (delegateToUse &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F;非正常情况，这里省略...\n    &#125;\n\t\t&#x2F;&#x2F;这里才是真正的调用，别忘了delegateToUse就是初始化的FilterChainProxy对象\n    this.invokeDelegate(delegateToUse, request, response, filterChain);\n&#125;\n\nprotected void invokeDelegate(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n  &#x2F;&#x2F;最后实际上调用的是FilterChainProxy的doFilter方法\n    delegate.doFilter(request, response, filterChain);\n&#125;\n\n所以我们接着来看，FilterChainProxy的doFilter方法又在干什么：\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    boolean clearContext &#x3D; request.getAttribute(FILTER_APPLIED) &#x3D;&#x3D; null;\n    if (!clearContext) &#123;\n      \t&#x2F;&#x2F;真正的过滤在这里执行\n        this.doFilterInternal(request, response, chain);\n    &#125; else &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nprivate void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    FirewalledRequest firewallRequest &#x3D; this.firewall.getFirewalledRequest((HttpServletRequest)request);\n    HttpServletResponse firewallResponse &#x3D; this.firewall.getFirewalledResponse((HttpServletResponse)response);\n  \t&#x2F;&#x2F;这里获取了一个Filter列表，实际上SpringSecurity就是由N个过滤器实现的，这里获取的都是SpringSecurity提供的过滤器\n  \t&#x2F;&#x2F;但是请注意，经过我们之前的分析，实际上真正注册的Filter只有DelegatingFilterProxy\n  \t&#x2F;&#x2F;而这里的Filter列表中的所有Filter并没有被注册，而是在这里进行内部调用\n    List&lt;Filter&gt; filters &#x3D; this.getFilters((HttpServletRequest)firewallRequest);\n  \t&#x2F;&#x2F;只要Filter列表不是空，就依次执行内置的Filter\n    if (filters !&#x3D; null &amp;&amp; filters.size() !&#x3D; 0) &#123;\n        if (logger.isDebugEnabled()) &#123;\n            logger.debug(LogMessage.of(() -&gt; &#123;\n                return &quot;Securing &quot; + requestLine(firewallRequest);\n            &#125;));\n        &#125;\n\t\t\t\t&#x2F;&#x2F;这里创建一个虚拟的过滤链，过滤流程是由SpringSecurity自己实现的\n        FilterChainProxy.VirtualFilterChain virtualFilterChain &#x3D; new FilterChainProxy.VirtualFilterChain(firewallRequest, chain, filters);\n      \t&#x2F;&#x2F;调用虚拟过滤链的doFilter\n        virtualFilterChain.doFilter(firewallRequest, firewallResponse);\n    &#125; else &#123;\n        if (logger.isTraceEnabled()) &#123;\n            logger.trace(LogMessage.of(() -&gt; &#123;\n                return &quot;No security for &quot; + requestLine(firewallRequest);\n            &#125;));\n        &#125;\n\n        firewallRequest.reset();\n        chain.doFilter(firewallRequest, firewallResponse);\n    &#125;\n&#125;\n\n我们来看一下虚拟过滤链的doFilter是怎么处理的：\n&#x2F;&#x2F;看似没有任何循环，实际上就是一个循环，是一个递归调用\npublic void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;\n  \t&#x2F;&#x2F;判断是否已经通过全部的内置过滤器，定位是否等于当前大小\n    if (this.currentPosition &#x3D;&#x3D; this.size) &#123;\n        if (FilterChainProxy.logger.isDebugEnabled()) &#123;\n            FilterChainProxy.logger.debug(LogMessage.of(() -&gt; &#123;\n                return &quot;Secured &quot; + FilterChainProxy.requestLine(this.firewalledRequest);\n            &#125;));\n        &#125;\n\n        this.firewalledRequest.reset();\n      \t&#x2F;&#x2F;所有的内置过滤器已经完成，按照正常流程走DelegatingFilterProxy的下一个Filter\n      \t&#x2F;&#x2F;也就是说这里之后就与DelegatingFilterProxy没有任何关系了，该走其他过滤器就走其他地方配置的过滤器，SpringSecurity的过滤操作已经结束\n        this.originalChain.doFilter(request, response);\n    &#125; else &#123;\n      \t&#x2F;&#x2F;定位自增\n        ++this.currentPosition;\n      \t&#x2F;&#x2F;获取当前定位的Filter\n        Filter nextFilter &#x3D; (Filter)this.additionalFilters.get(this.currentPosition - 1);\n        if (FilterChainProxy.logger.isTraceEnabled()) &#123;\n            FilterChainProxy.logger.trace(LogMessage.format(&quot;Invoking %s (%d&#x2F;%d)&quot;, nextFilter.getClass().getSimpleName(), this.currentPosition, this.size));\n        &#125;\n\t\t\t\t&#x2F;&#x2F;执行内部过滤器的doFilter方法，传入当前对象本身作为Filter，执行如果成功，那么一定会再次调用当前对象的doFilter方法\n      \t&#x2F;&#x2F;可能最不理解的就是这里，执行的难道不是内部其他Filter的doFilter方法吗，怎么会让当前对象的doFilter方法递归调用呢？\n      \t&#x2F;&#x2F;没关系，了解了其中一个内部过滤器就明白了\n        nextFilter.doFilter(request, response, this);\n    &#125;\n&#125;\n\n因此，我们差不多已经了解了整个SpringSecurity的实现机制了，那么我们来看几个内部的过滤器分别在做什么。\n比如用于处理登陆的过滤器UsernamePasswordAuthenticationFilter，它继承自AbstractAuthenticationProcessingFilter，我们来看看它是怎么进行过滤的：\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    this.doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);\n&#125;\n\nprivate void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n  \t&#x2F;&#x2F;如果不是登陆请求，那么根本不会理这个请求\n    if (!this.requiresAuthentication(request, response)) &#123;\n      \t&#x2F;&#x2F;直接调用传入的FilterChain的doFilter方法\n      \t&#x2F;&#x2F;而这里传入的正好是VirtualFilterChain对象\n      \t&#x2F;&#x2F;这下知道为什么上面说是递归了吧\n        chain.doFilter(request, response);\n    &#125; else &#123;\n      \t&#x2F;&#x2F;如果是登陆请求，那么会执行登陆请求的相关逻辑，注意执行过程中出现任何问题都会抛出异常\n      \t&#x2F;&#x2F;比如用户名和密码错误，我们之前也已经测试过了，会得到一个BadCredentialsException\n        try &#123;\n          \t&#x2F;&#x2F;进行认证\n            Authentication authenticationResult &#x3D; this.attemptAuthentication(request, response);\n            if (authenticationResult &#x3D;&#x3D; null) &#123;\n                return;\n            &#125;\n\n            this.sessionStrategy.onAuthentication(authenticationResult, request, response);\n            if (this.continueChainBeforeSuccessfulAuthentication) &#123;\n                chain.doFilter(request, response);\n            &#125;\n\n          \t&#x2F;&#x2F;如果一路绿灯，没有报错，那么验证成功，执行successfulAuthentication\n            this.successfulAuthentication(request, response, chain, authenticationResult);\n        &#125; catch (InternalAuthenticationServiceException var5) &#123;\n            this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, var5);\n          \t&#x2F;&#x2F;验证失败，会执行unsuccessfulAuthentication\n            this.unsuccessfulAuthentication(request, response, var5);\n        &#125; catch (AuthenticationException var6) &#123;\n            this.unsuccessfulAuthentication(request, response, var6);\n        &#125;\n\n    &#125;\n&#125;\n\n那么我们来看看successfulAuthentication和unsuccessfulAuthentication分别做了什么：\nprotected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n  \t&#x2F;&#x2F;向SecurityContextHolder添加认证信息，我们可以通过SecurityContextHolder对象获取当前登陆的用户\n    SecurityContextHolder.getContext().setAuthentication(authResult);\n    if (this.logger.isDebugEnabled()) &#123;\n        this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult));\n    &#125;\n\n  \t&#x2F;&#x2F;记住我实现\n    this.rememberMeServices.loginSuccess(request, response, authResult);\n    if (this.eventPublisher !&#x3D; null) &#123;\n        this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n    &#125;\n\t\t\n  \t&#x2F;&#x2F;调用默认的或是我们自己定义的AuthenticationSuccessHandler的onAuthenticationSuccess方法\n  \t&#x2F;&#x2F;这个根据我们配置文件决定\n  \t&#x2F;&#x2F;到这里其实页面就已经直接跳转了\n    this.successHandler.onAuthenticationSuccess(request, response, authResult);\n&#125;\n\nprotected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;\n  \t&#x2F;&#x2F;登陆失败会直接清理掉SecurityContextHolder中的认证信息\n    SecurityContextHolder.clearContext();\n    this.logger.trace(&quot;Failed to process authentication request&quot;, failed);\n    this.logger.trace(&quot;Cleared SecurityContextHolder&quot;);\n    this.logger.trace(&quot;Handling authentication failure&quot;);\n  \t&#x2F;&#x2F;登陆失败的记住我处理\n    this.rememberMeServices.loginFail(request, response);\n  \t&#x2F;&#x2F;同上，调用默认或是我们自己定义的AuthenticationFailureHandler\n    this.failureHandler.onAuthenticationFailure(request, response, failed);\n&#125;\n\n了解了整个用户验证实现流程，其实其它的过滤器是如何实现的也就很容易联想到了，SpringSecurity的过滤器从某种意义上来说，更像是一个处理业务的Servlet，它做的事情不像是拦截，更像是完成自己对应的职责，只不过是使用了过滤器机制进行实现罢了。\nSecurityContextPersistenceFilter也是内置的Filter，可以尝试阅读一下其源码，了解整个SecurityContextHolder的运作原理，这里先说一下大致流程，各位可以依照整个流程按照源码进行推导：\n当过滤器链执行到SecurityContextPersistenceFilter时，它会从HttpSession中把SecurityContext对象取出来（是存在Session中的，跟随会话的消失而消失），然后放入SecurityContextHolder对象中。请求结束后，再把SecurityContext存入HttpSession中，并清除SecurityContextHolder内的SecurityContext对象。\n\n完善功能在了解了SpringSecurity的大部分功能后，我们就来将整个网站的内容进行完善，登陆目前已经实现了，我们还需要实现以下功能：\n\n注册功能（仅针对于学生）\n角色分为同学和管理员\n管理员负责上架、删除、更新书籍，查看所有同学的借阅列表\n同学可以借阅和归还书籍，以及查看自己的借阅列表\n\n\n\n开始之前我们需要先配置一下Thymeleaf的SpringSecurity扩展，它针对SpringSecurity提供了更多额外的解析：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.0.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&#x2F;&#x2F;配置模板引擎Bean\n@Bean\npublic SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver)&#123;\n    SpringTemplateEngine engine &#x3D; new SpringTemplateEngine();\n    engine.setTemplateResolver(resolver);\n    engine.addDialect(new SpringSecurityDialect());   &#x2F;&#x2F;添加针对于SpringSecurity的方言\n    return engine;\n&#125;\n\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;\n      xmlns:sec&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;extras&#x2F;spring-security&quot;&gt;\n\n下一章就是最后一章了，我们会深入讲解MySQL的高级部分，包括函数、存储过程、锁机制、索引以及存储引擎。\n","slug":"JavaSSM笔记（三）","date":"2022-03-05T16:22:50.343Z","categories_index":"JavaSSM笔记","tags_index":"JavaSSM笔记","author_index":"YangChao"},{"id":"cb5396739d768c57aa162224d7506a32","title":"JavaSSM笔记（二）","content":"\nSpringMVC在前面学习完Spring框架技术之后，差不多会出现两批人：一批是听得云里雾里，依然不明白这个东西是干嘛的；还有一批就是差不多理解了核心思想，但是不知道这些东西该如何去发挥它的作用。在SpringMVC阶段，你就能逐渐够体会到Spring框架为我们带来的便捷之处了。\n此阶段，我们将再次回到Tomcat的Web应用程序开发中，去感受SpringMVC为我们带来的巨大便捷。\nMVC理论基础在之前，我们给大家讲解了三层架构，包括：\n\n每一层都有着各自的职责，其中最关键的当属表示层，因为它相当于就是直接与用户的浏览器打交道的一层，并且所有的请求都会经过它进行解析，然后再告知业务层进行处理，任何页面的返回和数据填充也全靠表示层来完成，因此它实际上是整个三层架构中最关键的一层，而在之前的实战开发中，我们编写了大量的Servlet（也就是表示层实现）来处理来自浏览器的各种请求，但是我们发现，仅仅是几个很小的功能，以及几个很基本的页面，我们都要编写将近十个Servlet，如果是更加大型的网站系统，比如淘宝、B站，光是一个页面中可能就包含了几十甚至上百个功能，想想那样的话写起来得多恐怖。\n因此，SpringMVC正是为了解决这种问题而生的，它是一个非常优秀的表示层框架（在此之前还有一个叫做Struts2的框架，但是现阶段貌似快凉透了），采用MVC思想设计实现。\nMVC解释如下：\n\nM是指业务模型（Model）：通俗的讲就是我们之前用于封装数据传递的实体类。\nV是指用户界面（View）：一般指的是前端页面。\nC则是控制器（Controller）：控制器就相当于Servlet的基本功能，处理请求，返回响应。\n\n\nSpringMVC正是希望这三者之间进行解耦，实现各干各的，更加精细地划分对应的职责。最后再将View和Model进行渲染，得到最终的页面并返回给前端（就像之前使用Thymeleaf那样，把实体数据对象和前端页面都给到Thymeleaf，然后它会将其进行整合渲染得到最终有数据的页面，而本教程也会使用Thymeleaf作为视图解析器进行讲解）\n\n配置环境并搭建项目由于SpringMVC还没有支持最新的Tomcat10（主要是之前提到的包名问题，神仙打架百姓遭殃）所以我们干脆就再来配置一下Tomcat9环境，相当于回顾一下。\n下载地址：https://tomcat.apache.org/download-90.cgi\n添加SpringMVC的依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.13&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n接着我们需要配置一下web.xml，将DispatcherServlet替换掉Tomcat自带的Servlet，这里url-pattern需要写为/，即可完成替换：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;\n         version&#x3D;&quot;4.0&quot;&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;mvc&lt;&#x2F;servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;\n    &lt;&#x2F;servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;mvc&lt;&#x2F;servlet-name&gt;\n        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;\n    &lt;&#x2F;servlet-mapping&gt;\n&lt;&#x2F;web-app&gt;\n\n接着需要为整个Web应用程序配置一个Spring上下文环境（也就是容器），因为SpringMVC是基于Spring开发的，它直接利用Spring提供的容器来实现各种功能，这里我们直接使用注解方式进行配置，不再使用XML配置文件：\n&lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;com.example.config.MvcConfiguration&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;\n            &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;\n        &lt;&#x2F;init-param&gt;\n\n如果还是想使用XML配置文件进行配置，那么可以直接这样写：\n&lt;init-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;\n    &lt;param-value&gt;配置文件名称&lt;&#x2F;param-value&gt;\n&lt;&#x2F;init-param&gt;\n\n如果你希望完完全全丢弃配置文件，可以直接添加一个类，Tomcat会在类路径中查找实现ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器，Spring提供了这个接口的实现类 SpringServletContainerInitializer , 通过@HandlesTypes(WebApplicationInitializer.class)设置，这个类反过来会查找实现WebApplicationInitializer 的类，并将配置的任务交给他们来完成，因此直接实现接口即可：\npublic class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    @Override\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;MainConfiguration.class&#125;;   &#x2F;&#x2F;基本的Spring配置类，一般用于业务层配置\n    &#125;\n\n    @Override\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[0];  &#x2F;&#x2F;配置DispatcherServlet的配置类、主要用于Controller等配置\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#x2F;&#x2F;匹配路径，与上面一致\n    &#125;\n&#125;\n\n顺便编写一下最基本的配置类：\n@Configuration\npublic class MainConfiguration &#123;\n\n&#125;\n\n后面我们都采用无XML配置方式进行讲解。\n\n这样，就完成最基本的配置了，现在任何请求都会优先经过DispatcherServlet进行集中处理，下面我们会详细讲解如何使用它。\n\nController控制器有了SpringMVC之后，我们不必再像之前那样一个请求地址创建一个Servlet了，它使用DispatcherServlet替代Tomcat为我们提供的默认的静态资源Servlet，也就是说，现在所有的请求（除了jsp，因为Tomcat还提供了一个jsp的Servlet）都会经过DispatcherServlet进行处理。\n那么DispatcherServlet会帮助我们做什么呢？\n\n根据图片我们可以了解，我们的请求到达Tomcat服务器之后，会交给当前的Web应用程序进行处理，而SpringMVC使用DispatcherServlet来处理所有的请求，也就是说它被作为一个统一的访问点，所有的请求全部由它来进行调度。\n当一个请求经过DispatcherServlet之后，会先走HandlerMapping，它会将请求映射为HandlerExecutionChain，依次经过HandlerInterceptor有点类似于之前我们所学的过滤器，不过在SpringMVC中我们使用的是拦截器，然后再交给HandlerAdapter，根据请求的路径选择合适的控制器进行处理，控制器处理完成之后，会返回一个ModelAndView对象，包括数据模型和视图，通俗的讲就是页面中数据和页面本身（只包含视图名称即可）。\n返回ModelAndView之后，会交给ViewResolver（视图解析器）进行处理，视图解析器会对整个视图页面进行解析，SpringMVC自带了一些视图解析器，但是只适用于JSP页面，我们也可以像之前一样使用Thymeleaf作为视图解析器，这样我们就可以根据给定的视图名称，直接读取HTML编写的页面，解析为一个真正的View。\n解析完成后，就需要将页面中的数据全部渲染到View中，最后返回给DispatcherServlet一个包含所有数据的成形页面，再响应给浏览器，完成整个过程。\n因此，实际上整个过程我们只需要编写对应请求路径的的Controller以及配置好我们需要的ViewResolver即可，之后还可以继续补充添加拦截器，而其他的流程已经由SpringMVC帮助我们完成了。\n配置视图解析器和控制器首先我们需要实现最基本的页面解析并返回，第一步就是配置视图解析器，这里我们使用Thymeleaf为我们提供的视图解析器，导入需要的依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.0.12.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n配置视图解析器非常简单，我们只需要将对应的ViewResolver注册为Bean即可，这里我们直接在配置类中编写：\n@ComponentScan(&quot;com.example.controller&quot;)\n@Configuration\n@EnableWebMvc\npublic class WebConfiguration &#123;\n\n  &#x2F;&#x2F;我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面\n    @Bean\n    public ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)&#123;\n        ThymeleafViewResolver resolver &#x3D; new ThymeleafViewResolver();\n        resolver.setOrder(1);   &#x2F;&#x2F;可以存在多个视图解析器，并且可以为他们设定解析顺序\n        resolver.setCharacterEncoding(&quot;UTF-8&quot;);   &#x2F;&#x2F;编码格式是重中之重\n        resolver.setTemplateEngine(springTemplateEngine);   &#x2F;&#x2F;和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎\n        return resolver;\n    &#125;\n  \n  \t&#x2F;&#x2F;配置模板解析器\n  \t@Bean\n    public SpringResourceTemplateResolver templateResolver()&#123;\n        SpringResourceTemplateResolver resolver &#x3D; new SpringResourceTemplateResolver();\n        resolver.setSuffix(&quot;.html&quot;);   &#x2F;&#x2F;需要解析的后缀名称\n        resolver.setPrefix(&quot;&#x2F;&quot;);   &#x2F;&#x2F;需要解析的HTML页面文件存放的位置\n        return resolver;\n    &#125;\n  \t\n  \t&#x2F;&#x2F;配置模板引擎Bean\n  \t@Bean\n    public SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver)&#123;\n        SpringTemplateEngine engine &#x3D; new SpringTemplateEngine();\n        engine.setTemplateResolver(resolver);   &#x2F;&#x2F;模板解析器，默认即可\n        return engine;\n    &#125;\n&#125;\n\n别忘了在Initializer中添加此类作为配置：\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n    return new Class[]&#123;MvcConfiguration.class&#125;;\n&#125;\n\n现在我们就完成了视图解析器的配置，我们接着来创建一个Controller，创建Controller也非常简单，只需在一个类上添加一个@Controller注解即可，它会被Spring扫描并自动注册为Controller类型的Bean，然后我们只需要在类中编写方法用于处理对应地址的请求即可：\n@Controller   &#x2F;&#x2F;直接添加注解即可\npublic class MainController &#123;\n\n    @RequestMapping(&quot;&#x2F;index&quot;)   &#x2F;&#x2F;直接填写访问路径\n    public ModelAndView index()&#123;\n        return new ModelAndView(&quot;index&quot;);  &#x2F;&#x2F;返回ModelAndView对象，这里填入了视图的名称\n      \t&#x2F;&#x2F;返回后会经过视图解析器进行处理\n    &#125;\n&#125;\n\n我们会发现，打开浏览器之后就可以直接访问我们的HTML页面了。\n而页面中的数据我们可以直接向Model进行提供：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index()&#123;\n    ModelAndView modelAndView &#x3D; new ModelAndView(&quot;index&quot;);\n    modelAndView.getModel().put(&quot;name&quot;, &quot;啊这&quot;);\n    return modelAndView;\n&#125;\n\n这样Thymeleaf就能收到我们传递的数据进行解析：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;static&#x2F;test.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    HelloWorld！\n    &lt;div th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n当然，如果仅仅是传递一个页面不需要任何的附加属性，我们可以直接返回View名称，SpringMVC会将其自动包装为ModelAndView对象：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;index&quot;;\n&#125;\n\n还可以单独添加一个Model作为形参进行设置，SpringMVC会自动帮助我们传递实例对象：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index(Model model)&#123;  &#x2F;&#x2F;这里不仅仅可以是Model，还可以是Map、ModelMap\n    model.addAttribute(&quot;name&quot;, &quot;yyds&quot;);\n    return &quot;index&quot;;\n&#125;\n\n这么方便的写法，你就说你爱不爱吧，你爱不爱。\n注意，一定要保证视图名称下面出现横线并且按住Ctrl可以跳转，配置才是正确的（最新版IDEA）\n我们的页面中可能还会包含一些静态资源，比如js、css，因此这里我们还需要配置一下，让静态资源通过Tomcat提供的默认Servlet进行解析，我们需要让配置类实现一下WebMvcConfigurer接口，这样在Web应用程序启动时，会根据我们重写方法里面的内容进行进一步的配置：\n@Override\npublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n    configurer.enable();   &#x2F;&#x2F;开启默认的Servlet\n&#125;\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    registry.addResourceHandler(&quot;&#x2F;static&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;WEB-INF&#x2F;static&#x2F;&quot;);   \n  \t&#x2F;&#x2F;配置静态资源的访问路径\n&#125;\n\n我们编写一下前端内容：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n      &lt;!-- 引用静态资源，这里使用Thymeleaf的网址链接表达式，Thymeleaf会自动添加web应用程序的名称到链接前面 --&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;test.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    HelloWorld！\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n创建test.js并编写如下内容：\nwindow.alert(&quot;欢迎来到GayHub全球最大同性交友网站&quot;)\n\n最后访问页面，页面在加载时就会显示一个弹窗，这样我们就完成了最基本的页面配置。相比之前的方式，这样就简单很多了，直接避免了编写大量的Servlet来处理请求。\n@RequestMapping详解前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个@RequestMapping即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊@RequestMapping吧，注解定义如下：\n@Mapping\npublic @interface RequestMapping &#123;\n    String name() default &quot;&quot;;\n\n    @AliasFor(&quot;path&quot;)\n    String[] value() default &#123;&#125;;\n\n    @AliasFor(&quot;value&quot;)\n    String[] path() default &#123;&#125;;\n\n    RequestMethod[] method() default &#123;&#125;;\n\n    String[] params() default &#123;&#125;;\n\n    String[] headers() default &#123;&#125;;\n\n    String[] consumes() default &#123;&#125;;\n\n    String[] produces() default &#123;&#125;;\n&#125;\n\n其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：\n@RequestMapping(&#123;&quot;&#x2F;index&quot;, &quot;&#x2F;test&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n现在我们访问&#x2F;index或是&#x2F;test都会经过此方法进行处理。\n我们也可以直接将@RequestMapping添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：\n@Controller\n@RequestMapping(&quot;&#x2F;yyds&quot;)\npublic class MainController &#123;\n\n    @RequestMapping(&#123;&quot;&#x2F;index&quot;, &quot;&#x2F;test&quot;&#125;)\n    public ModelAndView index()&#123;\n        return new ModelAndView(&quot;index&quot;);\n    &#125;\n&#125;\n\n那么现在我们需要访问/yyds/index或是/yyds/test才可以得到此页面。我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。\n路径还支持使用通配符进行匹配：\n\n?：表示任意一个字符，比如@RequestMapping(&quot;/index/x?&quot;)可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb等等。\n*：表示任意0-n个字符，比如@RequestMapping(&quot;/index/*&quot;)可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds等。\n**：表示当前目录或基于当前目录的多级目录，比如@RequestMapping(&quot;/index/**&quot;)可以匹配&#x2F;index、&#x2F;index&#x2F;xxx等。\n\n我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.POST)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n现在我们如果直接使用浏览器访问此页面，会显示405方法不支持，因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。\n我们也可以使用衍生注解直接设定为指定类型的请求映射：\n@PostMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n这里使用了@PostMapping直接指定为POST请求类型的请求映射，同样的，还有@GetMapping可以直接指定为GET请求方式，这里就不一一列举了。\n我们可以使用params属性来指定请求必须携带哪些请求参数，比如：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;username&quot;, &quot;password&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n比如这里我们要求请求中必须携带username和password属性，否则无法访问。它还支持表达式，比如我们可以这样编写：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;!username&quot;, &quot;password&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, params &#x3D; &#123;&quot;username!&#x3D;test&quot;, &quot;password&#x3D;123&quot;&#125;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n这样，请求参数username不允许为test，并且password必须为123，否则无法访问。\nheader属性用法与params一致，但是它要求的是请求头中需要携带什么内容，比如：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, headers &#x3D; &quot;!Connection&quot;)\npublic ModelAndView index()&#123;\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n那么，如果请求头中携带了Connection属性，将无法访问。其他两个属性：\n\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;\nproduces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n\n@RequestParam和@RequestHeader详解我们接着来看，如何获取到请求中的参数。\n我们只需要为方法添加一个形式参数，并在形式参数前面添加@RequestParam注解即可：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(&quot;username&quot;) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n我们需要在@RequestParam中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加@RequestParam也能获取到参数值。\n一旦添加@RequestParam，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@RequestParam(value &#x3D; &quot;username&quot;, required &#x3D; false, defaultValue &#x3D; &quot;伞兵一号&quot;) String username)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+username);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n如果需要使用Servlet原本的一些类，比如：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpServletRequest request)&#123;\n    System.out.println(&quot;接受到请求参数：&quot;+request.getParameterMap().keySet());\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n直接添加HttpServletRequest为形式参数即可，SpringMVC会自动传递该请求原本的HttpServletRequest对象，同理，我们也可以添加HttpServletResponse作为形式参数，甚至可以直接将HttpSession也作为参数传递：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpSession session)&#123;\n    System.out.println(session.getAttribute(&quot;test&quot;));\n    session.setAttribute(&quot;test&quot;, &quot;鸡你太美&quot;);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n我们还可以直接将请求参数传递给一个实体类：\n@Data\npublic class User &#123;\n    String username;\n    String password;\n&#125;\n\n注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(User user)&#123;\n    System.out.println(&quot;获取到cookie值为：&quot;+user);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n@RequestHeader与@RequestParam用法一致，不过它是用于获取请求头参数的，这里就不再演示了。\n@CookieValue和@SessionAttrbutie通过使用@CookieValue注解，我们也可以快速获取请求携带的Cookie信息：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(HttpServletResponse response,\n                          @CookieValue(value &#x3D; &quot;test&quot;, required &#x3D; false) String test)&#123;\n    System.out.println(&quot;获取到cookie值为：&quot;+test);\n    response.addCookie(new Cookie(&quot;test&quot;, &quot;lbwnb&quot;));\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n同样的，Session也能使用注解快速获取：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic ModelAndView index(@SessionAttribute(value &#x3D; &quot;test&quot;, required &#x3D; false) String test,\n                          HttpSession session)&#123;\n    session.setAttribute(&quot;test&quot;, &quot;xxxx&quot;);\n    System.out.println(test);\n    return new ModelAndView(&quot;index&quot;);\n&#125;\n\n可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。\n重定向和请求转发重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;redirect:home&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;home&quot;)\npublic String home()&#123;\n    return &quot;home&quot;;\n&#125;\n\n通过添加redirect:前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用forward:前缀表示转发给其他请求映射：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;forward:home&quot;;\n&#125;\n\n@RequestMapping(&quot;&#x2F;home&quot;)\npublic String home()&#123;\n    return &quot;home&quot;;\n&#125;\n\n使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。\nBean的Web作用域在学习Spring时我们讲解了Bean的作用域，包括singleton和prototype，Bean分别会以单例和多例模式进行创建，而在SpringMVC中，它的作用域被继续细分：\n\nrequest：对于每次HTTP请求，使用request作用域定义的Bean都将产生一个新实例，请求结束后Bean也消失。\nsession：对于每一个会话，使用session作用域定义的Bean都将产生一个新实例，会话过期后Bean也消失。\nglobal session：不常用，不做讲解。\n\n这里我们创建一个测试类来试试看：\npublic class TestBean &#123;\n\n&#125;\n\n接着将其注册为Bean，注意这里需要添加@RequestScope或是@SessionScope表示此Bean的Web作用域：\n@Bean\n@RequestScope\npublic TestBean testBean()&#123;\n    return new TestBean();\n&#125;\n\n接着我们将其自动注入到Controller中：\n@Controller\npublic class MainController &#123;\n\n    @Resource\n    TestBean bean;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\n    public ModelAndView index()&#123;\n        System.out.println(bean);\n        return new ModelAndView(&quot;index&quot;);\n    &#125;\n&#125;\n\n我们发现，每次发起得到的Bean实例都不同，接着我们将其作用域修改为@SessionScope，这样作用域就上升到Session，只要清理浏览器的Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么Bean实例始终不变。\n实际上，它也是通过代理实现的，我们调用Bean中的方法会被转发到真正的Bean对象去执行。\n\nRestFul风格中文释义为“表现层状态转换”（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST&#x2F;GET&#x2F;PUT&#x2F;DELETE），来执行相同请求地址的不同类型操作。\n因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：\nhttp://localhost:8080/mvc/index/123456\n我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：\n@RequestMapping(&quot;&#x2F;index&#x2F;&#123;str&#125;&quot;)\npublic String index(@PathVariable String str) &#123;\n    System.out.println(str);\n    return &quot;index&quot;;\n&#125;\n\n注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了@PathVariable注解的参数，或是由@PathVariable注解指定为占位符名称：\n@RequestMapping(&quot;&#x2F;index&#x2F;&#123;str&#125;&quot;)\npublic String index(@PathVariable(&quot;str&quot;) String text)&#123;\n    System.out.println(text);\n    return &quot;index&quot;;\n&#125;\n\n如果没有配置正确，方法名称上会出现黄线。\n我们可以按照不同功能进行划分：\n\nPOST http://localhost:8080/mvc/index  -  添加用户信息，携带表单数据\nGET http://localhost:8080/mvc/index/{id}  -  获取用户信息，id直接放在请求路径中\nPUT http://localhost:8080/mvc/index  -  修改用户信息，携带表单数据\nDELETE http://localhost:8080/mvc/index/{id}  -  删除用户信息，id直接放在请求路径中\n\n我们分别编写四个请求映射：\n@Controller\npublic class MainController &#123;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)\n    public String get(@PathVariable(&quot;id&quot;) String text)&#123;\n        System.out.println(&quot;获取用户：&quot;+text);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.POST)\n    public String post(String username)&#123;\n        System.out.println(&quot;添加用户：&quot;+username);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.DELETE)\n    public String delete(@PathVariable(&quot;id&quot;) String text)&#123;\n        System.out.println(&quot;删除用户：&quot;+text);\n        return &quot;index&quot;;\n    &#125;\n\n    @RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, method &#x3D; RequestMethod.PUT)\n    public String put(String username)&#123;\n        System.out.println(&quot;修改用户：&quot;+username);\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n这只是一种设计风格而已，各位小伙伴了解即可。\n\nInterceptor拦截器拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的拦截器才可以成功到达Servlet，而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理，它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。\n\n创建拦截器创建一个拦截器我们需要实现一个HandlerInterceptor接口：\npublic class MainInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;我是处理之前！&quot;);\n        return true;   &#x2F;&#x2F;只有返回true才会继续，否则直接结束\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;我是处理之后！&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;我是完成之后！&quot;);\n    &#125;\n&#125;\n\n接着我们需要在配置类中进行注册：\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    registry.addInterceptor(new MainInterceptor())\n      .addPathPatterns(&quot;&#x2F;**&quot;)    &#x2F;&#x2F;添加拦截器的匹配路径，只要匹配一律拦截\n      .excludePathPatterns(&quot;&#x2F;home&quot;);   &#x2F;&#x2F;拦截器不进行拦截的路径\n&#125;\n\n现在我们在浏览器中访问index页面，拦截器已经生效。\n得到整理拦截器的执行顺序：\n\n\n\n\n\n\n\n\n\n我是处理之前！\n我是处理！\n我是处理之后！\n我是完成之后！\n也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次afterCompletion方法，其实整个过程与我们之前所认识的Filter类似，不过在处理前，我们只需要返回true或是false表示是否被拦截即可，而不是再去使用FilterChain进行向下传递。\n那么我们就来看看，如果处理前返回false，会怎么样：\n\n\n\n\n\n\n\n\n\n我是处理之前！\n通过结果发现一旦返回false，之后的所有流程全部取消，那么如果是在处理中发生异常了呢？\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    System.out.println(&quot;我是处理！&quot;);\n    if(true) throw new RuntimeException(&quot;&quot;);\n    return &quot;index&quot;;\n&#125;\n\n结果为：\n\n\n\n\n\n\n\n\n\n我是处理之前！我是处理！我是完成之后！\n我们发现如果处理过程中抛出异常，那么久不会执行处理后postHandle方法，但是会执行afterCompletion方法，我们可以在此方法中获取到抛出的异常。\n多级拦截器前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：\npublic class SubInterceptor implements HandlerInterceptor &#123;\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是处理之前！&quot;);\n        return true;\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是处理之后！&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;二号拦截器：我是完成之后！&quot;);\n    &#125;\n&#125;\n\n注册二号拦截器：\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n  \t&#x2F;&#x2F;一号拦截器\n    registry.addInterceptor(new MainInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(&quot;&#x2F;home&quot;);\n  \t&#x2F;&#x2F;二号拦截器\n    registry.addInterceptor(new SubInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);\n&#125;\n\n注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：\n\n\n\n\n\n\n\n\n\n一号拦截器：我是处理之前！二号拦截器：我是处理之前！我是处理！二号拦截器：我是处理之后！一号拦截器：我是处理之后！二号拦截器：我是完成之后！一号拦截器：我是完成之后！\n和多级Filter相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法，而完成后是在所有的postHandle执行之后再同样的以倒序方式执行。\n那么如果这时一号拦截器在处理前就返回了false呢？\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n    System.out.println(&quot;一号拦截器：我是处理之前！&quot;);\n    return false;\n&#125;\n\n得到结果如下：\n\n\n\n\n\n\n\n\n\n一号拦截器：我是处理之前！\n我们发现，与单个拦截器的情况一样，一旦拦截器返回false，那么之后无论有无拦截器，都不再继续。\n异常处理当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为SpringMVC为我们提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。\n我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：\n@ControllerAdvice\npublic class ErrorController &#123;\n\n    @ExceptionHandler(Exception.class)\n    public String error(Exception e, Model model)&#123;  &#x2F;&#x2F;可以直接添加形参来获取异常\n        e.printStackTrace();\n        model.addAttribute(&quot;e&quot;, e);\n        return &quot;500&quot;;\n    &#125;\n&#125;\n\n接着我们编写一个专门显示异常的页面：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  500 - 服务器出现了一个内部错误QAQ\n  &lt;div th:text&#x3D;&quot;$&#123;e&#125;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n接着修改：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    System.out.println(&quot;我是处理！&quot;);\n    if(true) throw new RuntimeException(&quot;您的氪金力度不足，无法访问！&quot;);\n    return &quot;index&quot;;\n&#125;\n\n访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。\nJSON数据格式与AJAX请求JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。\n我们现在推崇的是前后端分离的开发模式，而不是所有的内容全部交给后端渲染再发送给浏览器，也就是说，整个Web页面的内容在一开始就编写完成了，而其中的数据由前端执行JS代码来向服务器动态获取，再到前端进行渲染（填充），这样可以大幅度减少后端的压力，并且后端只需要传输关键数据即可（在即将到来的SpringBoot阶段，我们将完全采用前后端分离的开发模式）\nJSON数据格式既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。因此JSON横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过JSON格式承载的。\n一个JSON格式的数据长这样，以学生对象为例：\n&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;\n\n多个学生可以以数组的形式表示：\n[&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;]\n\n嵌套关系可以表示为：\n&#123;&quot;studentList&quot;: [&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;], &quot;count&quot;: 2&#125;\n\n它直接包括了属性的名称和属性的值，与JavaScript的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个JS对象，我们可以直接在控制台窗口中测试：\nlet obj &#x3D; JSON.parse(&#39;&#123;&quot;studentList&quot;: [&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;], &quot;count&quot;: 2&#125;&#39;)\n&#x2F;&#x2F;将JSON格式字符串转换为JS对象\nobj.studentList[0].name   &#x2F;&#x2F;直接访问第一个学生的名称\n\n我们也可以将JS对象转换为JSON字符串：\nJSON.stringify(obj)\n\n我们后端就可以以JSON字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。\n那么后端如何快速创建一个JSON格式的数据呢？我们首先需要导入以下依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.78&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nJSON解析框架有很多种，比较常用的是Jackson和FastJSON，这里我们使用阿里巴巴的FastJSON进行解析。\n首先要介绍的是JSONObject，它和Map的使用方法一样（实现了Map接口），比如我们向其中存放几个数据：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    JSONObject object &#x3D; new JSONObject();\n    object.put(&quot;name&quot;, &quot;杰哥&quot;);\n    object.put(&quot;age&quot;, 18);\n    System.out.println(object.toJSONString());   &#x2F;&#x2F;以JSON格式输出JSONObject字符串\n    return &quot;index&quot;;\n&#125;\n\n最后我们得到的结果为：\n&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;\n\n实际上JSONObject就是对JSON数据的一种对象表示。同样的还有JSONArray，它表示一个数组，用法和List一样，数组中可以嵌套其他的JSONObject或是JSONArray：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;)\npublic String index()&#123;\n    JSONObject object &#x3D; new JSONObject();\n    object.put(&quot;name&quot;, &quot;杰哥&quot;);\n    object.put(&quot;age&quot;, 18);\n    JSONArray array &#x3D; new JSONArray();\n    array.add(object);\n    System.out.println(array.toJSONString());\n    return &quot;index&quot;;\n&#125;\n\n得到的结果为：\n[&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;]\n\n当出现循环引用时，会按照以下语法来解析：\n我们可以也直接创建一个实体类，将实体类转换为JSON格式的数据：\n@RequestMapping(value &#x3D; &quot;&#x2F;index&quot;, produces &#x3D; &quot;application&#x2F;json&quot;)\n@ResponseBody\npublic String data()&#123;\n    Student student &#x3D; new Student();\n    student.setName(&quot;杰哥&quot;);\n    student.setAge(18);\n    return JSON.toJSONString(student);\n&#125;\n\n这里我们修改了produces的值，将返回的内容类型设定为application/json，表示服务器端返回了一个JSON格式的数据（当然不设置也行，也能展示，这样是为了规范）然后我们在方法上添加一个@ResponseBody表示方法返回（也可以在类上添加@RestController表示此Controller默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。\n接着我们使用JSON工具类将其转换为JSON格式的字符串，打开浏览器，得到JSON格式数据。\nSpringMVC非常智能，我们可以直接返回一个对象类型，它会被自动转换为JSON字符串格式：\n@RequestMapping(value &#x3D; &quot;&#x2F;data&quot;, produces &#x3D; &quot;application&#x2F;json&quot;)\n@ResponseBody\npublic Student data()&#123;\n    Student student &#x3D; new Student();\n    student.setName(&quot;杰哥&quot;);\n    student.setAge(18);\n    return student;\n&#125;\n\n注意需要在配置类中添加一下FastJSON转换器（默认只支持JackSon）：\n@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n    converters.add(new FastJsonHttpMessageConverter());\n&#125;\n\nAJAX请求前面我们讲解了如何向浏览器发送一个JSON格式的数据，那么我们现在来看看如何向服务器请求数据。\n\nAjax即Asynchronous Javascript And XML（异步JavaScript和XML），它的目标就是实现页面中的数据动态更新，而不是直接刷新整个页面，它是一个概念。\n它在JQuery框架中有实现，因此我们直接导入JQuery（JQuery极大地简化了JS的开发，封装了很多内容，感兴趣的可以了解一下）：\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n接着我们就可以直接使用了，首先修改一下前端页面：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script th:src&#x3D;&quot;@&#123;&#x2F;static&#x2F;test.js&#125;&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    你好，\n    &lt;span id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;span&gt;\n    您的年龄是：\n    &lt;span id&#x3D;&quot;age&quot;&gt;&lt;&#x2F;span&gt;\n    &lt;button onclick&#x3D;&quot;updateData()&quot;&gt;点我更新页面数据&lt;&#x2F;button&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n现在我们希望用户名称和年龄需要在我们点击按钮之后才会更新，我们接着来编写一下JS：\nfunction updateData() &#123;\n    &#x2F;&#x2F;美元符.的方式来使用Ajax请求，这里使用的是get方式，第一个参数为请求的地址（注意需要带上Web应用程序名称），第二个参数为成功获取到数据的方法，data就是返回的数据内容\n  \t$.get(&quot;&#x2F;mvc&#x2F;data&quot;, function (data) &#123;   &#x2F;&#x2F;获取成功执行的方法\n        window.alert(&#39;接受到异步请求数据：&#39;+JSON.stringify(data))  &#x2F;&#x2F;弹窗展示数据\n        $(&quot;#username&quot;).text(data.name)   &#x2F;&#x2F;这里使用了JQuery提供的选择器，直接选择id为username的元素，更新数据\n        $(&quot;#age&quot;).text(data.age)\n    &#125;)\n&#125;\n\n使用JQuery非常方便，我们直接通过JQuery的选择器就可以快速获取页面中的元素，注意这里获取的元素是被JQuery封装过的元素，需要使用JQuery提供的方法来进行操作。\n这样，我们就实现了从服务端获取数据并更新到页面中（实际上之前，我们在JavaWeb阶段使用XHR请求也演示过，不过当时是纯粹的数据）\n那么我们接着来看，如何向服务端发送一个JS对象数据并进行解析：\nfunction submitData() &#123;\n    $.post(&quot;&#x2F;mvc&#x2F;submit&quot;, &#123;   &#x2F;&#x2F;这里使用POST方法发送请求\n        name: &quot;测试&quot;,     &#x2F;&#x2F;第二个参数是要传递的对象，会以表单数据的方式发送\n      \tage: 18   \n    &#125;, function (data) &#123;\n        window.alert(JSON.stringify(data))   &#x2F;&#x2F;发送成功执行的方法\n    &#125;)\n&#125;\n\n服务器端只需要在请求参数位置添加一个对象接收即可（和前面是一样的，因为这里也是提交的表单数据）：\n@RequestMapping(&quot;&#x2F;submit&quot;)\n@ResponseBody\npublic String submit(Student student)&#123;\n    System.out.println(&quot;接收到前端数据：&quot;+student);\n    return &quot;&#123;\\&quot;success\\&quot;: true&#125;&quot;;\n&#125;\n\n我们也可以将js对象转换为JSON字符串的形式进行传输，这里需要使用ajax方法来处理：\nfunction submitData() &#123;\n    $.ajax(&#123;   &#x2F;&#x2F;最基本的请求方式，需要自己设定一些参数\n        type: &#39;POST&#39;,   &#x2F;&#x2F;设定请求方法\n        url: &quot;&#x2F;mvc&#x2F;submit&quot;,   &#x2F;&#x2F;请求地址\n        data: JSON.stringify(&#123;name: &quot;测试&quot;, age: 18&#125;),  &#x2F;&#x2F;转换为JSON字符串进行发送\n        success: function (data) &#123;\n            window.alert(JSON.stringify(data))\n        &#125;,\n        contentType: &quot;application&#x2F;json&quot;  &#x2F;&#x2F;请求头Content-Type一定要设定为JSON格式\n    &#125;)\n&#125;\n\n如果我们需要读取前端发送给我们的JSON格式数据，那么这个时候就需要添加@RequestBody注解：\n@RequestMapping(&quot;&#x2F;submit&quot;)\n@ResponseBody\npublic String submit(@RequestBody JSONObject object)&#123;\n    System.out.println(&quot;接收到前端数据：&quot;+object);\n    return &quot;&#123;\\&quot;success\\&quot;: true&#125;&quot;;\n&#125;\n\n这样，我们就实现了前后端使用JSON字符串进行通信。\n实现文件上传和下载利用SpringMVC，我们可以很轻松地实现文件上传和下载，同样的，我们只需要配置一个Resolver：\n@Bean(&quot;multipartResolver&quot;)   &#x2F;&#x2F;注意这里Bean的名称是固定的，必须是multipartResolver\npublic CommonsMultipartResolver commonsMultipartResolver()&#123;\n    CommonsMultipartResolver resolver &#x3D; new CommonsMultipartResolver();\n    resolver.setMaxUploadSize(1024 * 1024 * 10);   &#x2F;&#x2F;最大10MB大小\n    resolver.setDefaultEncoding(&quot;UTF-8&quot;);   &#x2F;&#x2F;默认编码格式\n    return resolver;\n&#125;\n\n接着我们直接编写Controller即可：\n@RequestMapping(value &#x3D; &quot;&#x2F;upload&quot;, method &#x3D; RequestMethod.POST)\n@ResponseBody\npublic String upload(@RequestParam CommonsMultipartFile file) throws IOException &#123;\n    File fileObj &#x3D; new File(&quot;test.html&quot;);\n    file.transferTo(fileObj);\n    System.out.println(&quot;用户上传的文件已保存到：&quot;+fileObj.getAbsolutePath());\n    return &quot;文件上传成功！&quot;;\n&#125;\n\n使用CommonsMultipartFile对象来接收用户上传的文件。它是基于Apache的Commons-fileupload框架实现的，我们还需要导入一个依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n最后在前端添加一个文件的上传点：\n&lt;div&gt;\n    &lt;form action&#x3D;&quot;upload&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;\n        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&gt;\n        &lt;input type&#x3D;&quot;submit&quot;&gt;\n    &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;\n\n这样，点击提交之后，文件就会上传到服务器了。\n下载其实和我们之前的写法大致一样，直接使用HttpServletResponse，并向输出流中传输数据即可。\n@RequestMapping(value &#x3D; &quot;&#x2F;download&quot;, method &#x3D; RequestMethod.GET)\n@ResponseBody\npublic void download(HttpServletResponse response)&#123;\n    response.setContentType(&quot;multipart&#x2F;form-data&quot;);\n    try(OutputStream stream &#x3D; response.getOutputStream();\n        InputStream inputStream &#x3D; new FileInputStream(&quot;test.html&quot;))&#123;\n        IOUtils.copy(inputStream, stream);\n    &#125;catch (IOException e)&#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n在前端页面中添加一个下载点：\n&lt;a href&#x3D;&quot;download&quot; download&#x3D;&quot;test.html&quot;&gt;下载最新资源&lt;&#x2F;a&gt;\n\n解读DispatcherServlet源码注意：本部分作为选学内容！\n到目前为止，关于SpringMVC的相关内容就学习得差不多了，但是我们在最后还是需要深入了解一下DispatcherServlet底层是如何进行调度的，因此，我们会从源码角度进行讲解。\n首先我们需要找到DispatcherServlet的最顶层HttpServletBean，在这里直接继承的HttpServlet，那么我们首先来看一下，它在初始化方法中做了什么：\npublic final void init() throws ServletException &#123;\n  \t&#x2F;&#x2F;读取配置参数，并进行配置\n    PropertyValues pvs &#x3D; new HttpServletBean.ServletConfigPropertyValues(this.getServletConfig(), this.requiredProperties);\n    if (!pvs.isEmpty()) &#123;\n        try &#123;\n            BeanWrapper bw &#x3D; PropertyAccessorFactory.forBeanPropertyAccess(this);\n            ResourceLoader resourceLoader &#x3D; new ServletContextResourceLoader(this.getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.getEnvironment()));\n            this.initBeanWrapper(bw);\n            bw.setPropertyValues(pvs, true);\n        &#125; catch (BeansException var4) &#123;\n            if (this.logger.isErrorEnabled()) &#123;\n                this.logger.error(&quot;Failed to set bean properties on servlet &#39;&quot; + this.getServletName() + &quot;&#39;&quot;, var4);\n            &#125;\n\n            throw var4;\n        &#125;\n    &#125;\n\t\t&#x2F;&#x2F;此初始化阶段由子类实现，\n    this.initServletBean();\n&#125;\n\n我们接着来看initServletBean()方法是如何实现的，它是在子类FrameworkServlet中定义的：\nprotected final void initServletBean() throws ServletException &#123;\n    this.getServletContext().log(&quot;Initializing Spring &quot; + this.getClass().getSimpleName() + &quot; &#39;&quot; + this.getServletName() + &quot;&#39;&quot;);\n    if (this.logger.isInfoEnabled()) &#123;\n        this.logger.info(&quot;Initializing Servlet &#39;&quot; + this.getServletName() + &quot;&#39;&quot;);\n    &#125;\n\n    long startTime &#x3D; System.currentTimeMillis();\n\n    try &#123;\n      \t&#x2F;&#x2F;注意：我们在一开始说了SpringMVC有两个容器，一个是Web容器一个是根容器\n      \t&#x2F;&#x2F;Web容器只负责Controller等表现层内容\n      \t&#x2F;&#x2F;根容器就是Spring容器，它负责Service、Dao等，并且它是Web容器的父容器。\n      \t&#x2F;&#x2F;初始化WebApplicationContext，这个阶段会为根容器和Web容器进行父子关系建立\n        this.webApplicationContext &#x3D; this.initWebApplicationContext();\n        this.initFrameworkServlet();\n    &#125; catch (RuntimeException | ServletException var4) &#123;\n      &#x2F;&#x2F;...以下内容全是打印日志\n&#125;\n\n\n我们来看看initWebApplicationContext是如何进行初始化的：\nprotected WebApplicationContext initWebApplicationContext() &#123;\n  \t&#x2F;&#x2F;这里获取的是根容器，一般用于配置Service、数据源等\n    WebApplicationContext rootContext &#x3D; WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());\n    WebApplicationContext wac &#x3D; null;\n    if (this.webApplicationContext !&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果webApplicationContext在之前已经存在，则直接给到wac\n        wac &#x3D; this.webApplicationContext;\n        if (wac instanceof ConfigurableWebApplicationContext) &#123;\n            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext)wac;\n            if (!cwac.isActive()) &#123;\n                if (cwac.getParent() &#x3D;&#x3D; null) &#123;\n                  \t&#x2F;&#x2F;设定根容器为Web容器的父容器\n                    cwac.setParent(rootContext);\n                &#125;\n\n                this.configureAndRefreshWebApplicationContext(cwac);\n            &#125;\n        &#125;\n    &#125;\n\n    if (wac &#x3D;&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果webApplicationContext是空，那么就从ServletContext找一下有没有初始化上下文\n        wac &#x3D; this.findWebApplicationContext();\n    &#125;\n\n    if (wac &#x3D;&#x3D; null) &#123;\n      \t&#x2F;&#x2F;如果还是找不到，直接创个新的，并直接将根容器作为父容器\n        wac &#x3D; this.createWebApplicationContext(rootContext);\n    &#125;\n\n    if (!this.refreshEventReceived) &#123;\n        synchronized(this.onRefreshMonitor) &#123;\n          \t&#x2F;&#x2F;此方法由DispatcherServlet实现\n            this.onRefresh(wac);\n        &#125;\n    &#125;\n\n    if (this.publishContext) &#123;\n        String attrName &#x3D; this.getServletContextAttributeName();\n      \t&#x2F;&#x2F;把Web容器丢进ServletContext\n        this.getServletContext().setAttribute(attrName, wac);\n    &#125;\n\n    return wac;\n&#125;\n\n我们接着来看DispatcherServlet中实现的onRefresh()方法：\n@Override\nprotected void onRefresh(ApplicationContext context) &#123;\n    initStrategies(context);\n&#125;\n    \nprotected void initStrategies(ApplicationContext context) &#123;\n  \t&#x2F;&#x2F;初始化各种解析器\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n  \t&#x2F;&#x2F;在容器中查找所有的HandlerMapping，放入集合中\n  \t&#x2F;&#x2F;HandlerMapping保存了所有的请求映射信息（Controller中定义的），它可以根据请求找到处理器Handler，但并不是简单的返回处理器，而是将处理器和拦截器封装，形成一个处理器执行链（类似于之前的Filter）\n    initHandlerMappings(context);\n  \t&#x2F;&#x2F;在容器中查找所有的HandlerAdapter，它用于处理请求并返回ModelAndView对象\n  \t&#x2F;&#x2F;默认有三种实现HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter\n  \t&#x2F;&#x2F;当HandlerMapping找到处理请求的Controller之后，会选择一个合适的HandlerAdapter处理请求\n  \t&#x2F;&#x2F;比如我们之前使用的是注解方式配置Controller，现在有一个请求携带了一个参数，那么HandlerAdapter会对请求的数据进行解析，并传入方法作为实参，最后根据方法的返回值将其封装为ModelAndView对象\n    initHandlerAdapters(context);\n  \t&#x2F;&#x2F;其他的内容\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n&#125;\n\nDispatcherServlet初始化过程我们已经了解了，那么我们接着来看DispatcherServlet是如何进行调度的，首先我们的请求肯定会经过HttpServlet，然后其交给对应的doGet、doPost等方法进行处理，而在FrameworkServlet中，这些方法都被重写，并且使用processRequest来进行处理：\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    this.processRequest(request, response);\n&#125;\n\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n    this.processRequest(request, response);\n&#125;\n\n我们来看看processRequest做了什么：\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n  \t&#x2F;&#x2F;前期准备工作\n    long startTime &#x3D; System.currentTimeMillis();\n    Throwable failureCause &#x3D; null;\n    LocaleContext previousLocaleContext &#x3D; LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext &#x3D; this.buildLocaleContext(request);\n    RequestAttributes previousAttributes &#x3D; RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes &#x3D; this.buildRequestAttributes(request, response, previousAttributes);\n    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new FrameworkServlet.RequestBindingInterceptor());\n    this.initContextHolders(request, localeContext, requestAttributes);\n\n    try &#123;\n      \t&#x2F;&#x2F;重点在这里，这里进行了Service的执行，不过是在DispatcherServlet中定义的\n        this.doService(request, response);\n    &#125; catch (IOException | ServletException var16) &#123;\n        &#x2F;&#x2F;...\n&#125;\n\n请各位一定要耐心，这些大型框架的底层一般都是层层套娃，因为这样写起来层次会更加清晰，那么我们来看看DispatcherServlet中是如何实现的：\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n   &#x2F;&#x2F;...\n    try &#123;\n      \t&#x2F;&#x2F;重点在这里，这才是整个处理过程中最核心的部分\n        this.doDispatch(request, response);\n    &#125; finally &#123;\n        &#x2F;&#x2F;...\n&#125;\n\n终于找到最核心的部分了：\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n    HttpServletRequest processedRequest &#x3D; request;\n    HandlerExecutionChain mappedHandler &#x3D; null;\n    boolean multipartRequestParsed &#x3D; false;\n    WebAsyncManager asyncManager &#x3D; WebAsyncUtils.getAsyncManager(request);\n\n    try &#123;\n        try &#123;\n            ModelAndView mv &#x3D; null;\n            Object dispatchException &#x3D; null;\n\n            try &#123;\n                processedRequest &#x3D; this.checkMultipart(request);\n                multipartRequestParsed &#x3D; processedRequest !&#x3D; request;\n              \t&#x2F;&#x2F;在HandlerMapping集合中寻找可以处理当前请求的HandlerMapping\n                mappedHandler &#x3D; this.getHandler(processedRequest);\n                if (mappedHandler &#x3D;&#x3D; null) &#123;\n                    this.noHandlerFound(processedRequest, response);\n                  \t&#x2F;&#x2F;找不到HandlerMapping则无法进行处理\n                    return;\n                &#125;\n\n              \t&#x2F;&#x2F;根据HandlerMapping提供的信息，找到可以处理的HandlerAdapter\n                HandlerAdapter ha &#x3D; this.getHandlerAdapter(mappedHandler.getHandler());\n                String method &#x3D; request.getMethod();\n                boolean isGet &#x3D; HttpMethod.GET.matches(method);\n                if (isGet || HttpMethod.HEAD.matches(method)) &#123;\n                    long lastModified &#x3D; ha.getLastModified(request, mappedHandler.getHandler());\n                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;\n                        return;\n                    &#125;\n                &#125;\n\n              \t&#x2F;&#x2F;执行所有拦截器的preHandle()方法\n                if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;\n                    return;\n                &#125;\n\n              \t&#x2F;&#x2F;使用HandlerAdapter进行处理（我们编写的请求映射方法在这个位置才真正地执行了）\n              \t&#x2F;&#x2F;HandlerAdapter会帮助我们将请求的数据进行处理，再来调用我们编写的请求映射方法\n              \t&#x2F;&#x2F;最后HandlerAdapter会将结果封装为ModelAndView返回给mv\n                mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n                if (asyncManager.isConcurrentHandlingStarted()) &#123;\n                    return;\n                &#125;\n\n                this.applyDefaultViewName(processedRequest, mv);\n              \t&#x2F;&#x2F;执行所有拦截器的postHandle()方法\n                mappedHandler.applyPostHandle(processedRequest, response, mv);\n            &#125; catch (Exception var20) &#123;\n                dispatchException &#x3D; var20;\n            &#125; catch (Throwable var21) &#123;\n                dispatchException &#x3D; new NestedServletException(&quot;Handler dispatch failed&quot;, var21);\n            &#125;\n\n          \t&#x2F;&#x2F;最后处理结果，对视图进行渲染等，如果抛出异常会出现错误页面\n            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);\n        &#125; catch (Exception var22) &#123;\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);\n        &#125; catch (Throwable var23) &#123;\n            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, var23));\n        &#125;\n\n    &#125; finally &#123;\n        if (asyncManager.isConcurrentHandlingStarted()) &#123;\n            if (mappedHandler !&#x3D; null) &#123;\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            &#125;\n        &#125; else if (multipartRequestParsed) &#123;\n            this.cleanupMultipart(processedRequest);\n        &#125;\n\n    &#125;\n&#125;\n\n所以，根据以上源码分析得出最终的流程图：\n\n虽然完成本章学习后，我们已经基本能够基于Spring去重新编写一个更加高级的图书管理系统了，但是登陆验证复杂的问题依然没有解决，如果我们依然按照之前的方式编写登陆验证，显然太过简单，它仅仅只是一个登陆，但是没有任何的权限划分或是加密处理，我们需要更加高级的权限校验框架来帮助我们实现登陆操作，下一章，我们会详细讲解如何使用更加高级的SpringSecurity框架来进行权限验证，并在学习的过程中，重写我们的图书管理系统。\n","slug":"JavaSSM笔记（二）","date":"2022-03-05T16:22:45.742Z","categories_index":"JavaSSM笔记","tags_index":"JavaSSM笔记","author_index":"YangChao"},{"id":"9c23c4d0502f19daa98fa35771fc4957","title":"JavaSSM笔记（一）","content":"\n建议：对Java开发还不是很熟悉的同学，最好先花费半个月到一个月时间大量地去编写小项目，不推荐一口气学完，后面的内容相比前面的内容几乎是降维打击，一口气学完很容易忘记之前所学的基础知识，尤其是JavaSE阶段的内容。\nSpring框架技术恭喜各位顺利进入到SSM（Spring+SpringMVC+Mybatis）阶段的学习，也算是成功出了Java新手村，由于前面我们已经学习过Mybatis了，因此，本期教程的时间安排相比之前会更短一些。从这里开始，很多的概念理解起来就稍微有一点难度了，因为你们没有接触过企业开发场景，很难体会到那种思想带来的好处，甚至到后期接触到的几乎都是基于云计算和大数据理论实现的框架（当下最热门最前沿的技术）逐渐不再是和计算机基础相关联，而是和怎么高效干活相关了。\n在JavaWeb阶段，我们已经学习了如何使用Java进行Web应用程序开发，我们现在已经具有搭建Web网站的能力，但是，我们在开发的过程中，发现存在诸多的不便，在最后的图书管理系统编程实战中，我们发现虽然我们思路很清晰，知道如何编写对应的接口，但是这样的开发效率，实在是太慢了，并且对于对象创建的管理，存在诸多的不妥之处，因此，我们要去继续学习更多的框架技术，来简化和规范我们的Java开发。\nSpring就是这样的一个框架（文档：https://docs.spring.io/spring-framework/docs/5.2.13.RELEASE/spring-framework-reference/），它就是为了简化开发而生，它是轻量级的**IoC**和**AOP**的容器框架，主要是针对**JavaBean**的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。那么，首先一问，什么是**IoC**和**AOP**，什么又是**JavaBean**呢？只是听起来满满的高级感，实际上没有多高级（很多东西都是这样，名字听起来很牛，实际上只是一个很容易理解的东西）\n因此，一切的一切，我们还要从JavaBean说起，从这颗豆子生根发芽开始。\n什么是JavaBeanJavaBean就是有一定规范的Java实体类，跟普通类差不多，不同的是类内部提供了一些公共的方法以便外界对该对象内部属性进行操作，比如set、get操作，实际上，就是我们之前一直在用的：\npublic class User&#123;\n\tprivate String name;\n\tprivate int age;\n\tpublic String getName()&#123;\n\t\treturn name;\n\t&#125;\n\tpublic String getAge()&#123;\n\t\treturn age;\n\t&#125;\n\tpublic void setName(String name)&#123;\n\t\tthis.name &#x3D; name;\n\t&#125;\n\tpublic void setAge(int age)&#123;\n\t\tthis.age &#x3D; age;\n\t&#125;\n&#125;\n\n它的所有属性都是private，所有的属性都可以通过get&#x2F;set方法进行访问，同时还需要有一个无参构造（默认就有）\n因此我们之前编写的很多类，其实都可以是一个JavaBean。\nIoC理论基础在我们之前的图书管理系统Web应用程序中，我们发现，整个程序其实是依靠各个部分相互协作，共同完成一个操作，比如要展示借阅信息列表，那么首先需要使用Servlet进行请求和响应的数据处理，然后请求的数据全部交给对应的Service（业务层）来处理，当Service发现要从数据库中获取数据时，再向对应的Mapper发起请求。\n它们之间就像连接在一起的齿轮，谁也离不开谁：\n\n就像一个团队，每个人的分工都很明确，流水线上的一套操作必须环环相扣，这是一种高度耦合的体系。\n虽然这样的体系逻辑非常清晰，整个流程也能够让人快速了解，但是这样存在一个很严重的问题，我们现在的时代实际上是一个软件项目高速迭代的时代，我们发现很多App三天两头隔三差五地就更新，而且是什么功能当下最火，就马不停蹄地进行跟进开发，因此，就很容易出现，之前写好的代码，实现的功能，需要全部推翻，改成新的功能，那么我们就不得不去修改某些流水线上的模块，但是这样一修改，会直接导致整个流水线的引用关系大面积更新。\n就像我不想用这个Service实现类了，我想使用其他的实现类用不同的逻辑做这些功能，那么这个时候，我们只能每个类都去挨个进行修改，当项目特别庞大时，光是改个类名就够你改一天。\n因此，高耦合度带来的缺点是很明显的，也是现代软件开发中很致命的问题。如果要改善这种情况，我们只能将各个模块进行解耦，让各个模块之间的依赖性不再那么地强。也就是说，Service的实现类，不再由我们决定，而是让程序自己决定，所有的实现类对象，全部交给程序来管理，所有对象之间的关系，也由程序来动态决定，这样就引入了IoC理论。\nIOC是Inversion of Control的缩写，翻译为：“控制反转”，把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\n\n我们可以将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码，开发效率那是高的一匹啊。\n高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的管理。\n使用IoC容器首先一定要明确，使用Spring首要目的是为了使得软件项目进行解耦，而不是为了去简化代码！\nSpring并不是一个独立的框架，它实际上包含了很多的模块：\n\n而我们首先要去学习的就是Core Container，也就是核心容器模块。\nSpring是一个非入侵式的框架，就像一个工具库一样，因此，我们只需要直接导入其依赖就可以使用了。\n第一个Spring项目我们创建一个新的Maven项目，并导入Spring框架的依赖，Spring框架的坐标：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.13&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n接着在resource中创建一个Spring配置文件，命名为test.xml，直接右键点击即可创建：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n&lt;&#x2F;beans&gt;\n\n最后，在主方法中编写：\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;text&quot;);\n    \n&#125;\n\n这样，一个最基本的Spring项目就创建完成了，接着我们来看看如何向IoC容器中注册JavaBean，首先创建一个Student类：\n&#x2F;&#x2F;注意，这里还用不到值注入，只需要包含成员属性即可，不用Getter&#x2F;Setter。\npublic class Student &#123;\n    String name;\n    int age;\n&#125;\n\n然后在配置文件中添加这个bean：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&#x2F;&gt;\n\n现在，这个对象不需要我们再去生成了，而是由IoC容器来提供：\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;test.xml&quot;);\n    Student student &#x3D; (Student) context.getBean(&quot;student&quot;);\n    System.out.println(student);\n&#125;\n\n实际上，这里得到的Student对象是由Spring通过反射机制帮助我们创建的，初学者会非常疑惑，为什么要这样来创建对象，我们直接new一个它不香吗？为什么要交给IoC容器管理呢？在后面的学习中，我们再慢慢进行体会。\n将JavaBean交给IoC容器管理通过前面的例子，我们发现只要将我们创建好的JavaBean通过配置文件编写，即可将其交给IoC容器进行管理，那么，我们来看看，一个JavaBean的详细配置：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&#x2F;&gt;\n\n其中name属性（也可以是id属性），全局唯一，不可出现重复的名称，我们发现，之前其实就是通过Bean的名称来向IoC容器索要对应的对象，也可以通过其他方式获取。\n我们现在在主方法中连续获取两个对象：\nClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;test.xml&quot;);\nStudent student &#x3D; (Student) context.getBean(&quot;student&quot;);\nStudent student2 &#x3D; (Student) context.getBean(&quot;student&quot;);\nSystem.out.println(student);\nSystem.out.println(student2);\n\n我们发现两次获取到的实际上是同一个对象，也就是说，默认情况下，通过IoC容器进行管理的JavaBean是单例模式的，无论怎么获取始终为那一个对象，那么如何进行修改呢？只需要修改其作用域即可，添加scope属性：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;\n\n通过将其设定为prototype（原型模式）来使得其每次都会创建一个新的对象。我们接着来观察一下，这两种模式下Bean的生命周期，我们给构造方法添加一个输出：\npublic class Student &#123;\n    String name;\n    int age;\n\n    public Student()&#123;\n        System.out.println(&quot;我被构造了！&quot;);\n    &#125;\n&#125;\n\n接着我们在mian方法中打上断点来查看对象分别是在什么时候被构造的。\n我们发现，当Bean的作用域为单例模式，那么它会在一开始就被创建，而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于直接new了一个对象，并不会被保存。\n我们还可以通过配置文件，告诉创建一个对象需要执行此初始化方法，以及销毁一个对象的销毁方法：\npublic class Student &#123;\n    String name;\n    int age;\n\n    private void init()&#123;\n        System.out.println(&quot;我是初始化方法！&quot;);\n    &#125;\n\n    private void destroy()&#123;\n        System.out.println(&quot;我是销毁方法！&quot;);\n    &#125;\n\n    public Student()&#123;\n        System.out.println(&quot;我被构造了！&quot;);\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;test.xml&quot;);\n    Student student &#x3D; (Student) context.getBean(&quot;student&quot;);\n    System.out.println(student);\n    context.close();  &#x2F;&#x2F;手动销毁容器\n&#125;\n\n最后在XML文件中编写配置：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;destroy&quot;&#x2F;&gt;\n\n接下来测试一下即可。\n我们还可以手动指定Bean的加载顺序，若某个Bean需要保证一定在另一个Bean加载之前加载，那么就可以使用depend-on属性。\n依赖注入DI现在我们已经了解了如何注册和使用一个Bean，那么，如何向Bean的成员属性进行赋值呢？也就是说，IoC在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用property标签来实现，但是一定注意，此属性必须存在一个set方法，否则无法赋值：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\npublic class Student &#123;\n    String name;\n    int age;\n\n    public void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void say()&#123;\n        System.out.println(&quot;我是：&quot;+name);\n    &#125;\n&#125;\n\n最后测试是否能够成功将属性注入到我们的对象中：\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;test.xml&quot;);\n    Student student &#x3D; (Student) context.getBean(&quot;student&quot;);\n    student.say();\n&#125;\n\n那么，如果成员属性是一个非基本类型非String的对象类型，我们该怎么注入呢？\npublic class Card &#123;\n&#125;\n\npublic class Student &#123;\n    String name;\n    int age;\n    Card card;\n\n    public void setCard(Card card) &#123;\n        this.card &#x3D; card;\n    &#125;\n  \n  \tpublic void setName(String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public void say()&#123;\n        System.out.println(&quot;我是：&quot;+name+&quot;，我都学生证：&quot;+card);\n    &#125;\n&#125;\n\n我们只需要将对应的类型也注册为bean即可，然后直接使用ref属性来进行引用：\n&lt;bean name&#x3D;&quot;card&quot; class&#x3D;&quot;com.test.bean.Card&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;card&quot; ref&#x3D;&quot;card&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n那么，集合如何实现注入呢？我们需要在property内部进行编写：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&gt;\n    &lt;property name&#x3D;&quot;list&quot;&gt;\n        &lt;list&gt;\n            &lt;value type&#x3D;&quot;double&quot;&gt;100.0&lt;&#x2F;value&gt;\n            &lt;value type&#x3D;&quot;double&quot;&gt;95.0&lt;&#x2F;value&gt;\n            &lt;value type&#x3D;&quot;double&quot;&gt;92.5&lt;&#x2F;value&gt;\n        &lt;&#x2F;list&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n现在，我们就可以直接以一个数组的方式将属性注入，注意如果是List类型的话，我们也可以使用array数组。同样的，如果是一个Map类型，我们也可以使用entry来注入：\npublic class Student &#123;\n    String name;\n    int age;\n    Map&lt;String, Double&gt; map;\n\n    public void setMap(Map&lt;String, Double&gt; map) &#123;\n        this.map &#x3D; map;\n    &#125;\n\n    public void say()&#123;\n        System.out.println(&quot;我的成绩：&quot;+ map);\n    &#125;\n&#125;\n\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&gt;\n    &lt;property name&#x3D;&quot;map&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key&#x3D;&quot;语文&quot; value&#x3D;&quot;100.0&quot;&#x2F;&gt;\n            &lt;entry key&#x3D;&quot;数学&quot; value&#x3D;&quot;80.0&quot;&#x2F;&gt;\n            &lt;entry key&#x3D;&quot;英语&quot; value&#x3D;&quot;92.5&quot;&#x2F;&gt;\n        &lt;&#x2F;map&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n我们还可以使用自动装配来实现属性值的注入：\n&lt;bean name&#x3D;&quot;card&quot; class&#x3D;&quot;com.test.bean.Card&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot; autowire&#x3D;&quot;byType&quot;&#x2F;&gt;\n\n自动装配会根据set方法中需要的类型，自动在容器中查找是否存在对应类型或是对应名称以及对应构造方法的Bean，比如我们上面指定的为byType，那么其中的card属性就会被自动注入类型为Card的Bean\n我们已经了解了如何使用set方法来创建对象，那么能否不使用默认的无参构造方法，而是指定一个有参构造进行对象的创建呢？我们可以指定构造方法：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;小明&quot;&#x2F;&gt;\n        &lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;18&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\npublic class Student &#123;\n    String name;\n    int age;\n\n    public Student(String name, int age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    public void say()&#123;\n        System.out.println(&quot;我是：&quot;+name+&quot;今年&quot;+age+&quot;岁了！&quot;);\n    &#125;\n&#125;\n\n通过手动指定构造方法参数，我们就可以直接告诉容器使用哪一个构造方法来创建对象。\n\n面向切面AOP又是一个听起来很高大上的名词，AOP思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，就是代理！\n通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。\n\n相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的，我们在JavaWeb阶段已经给大家讲解过动态代理了。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不是接口。\n使用SpringAOPSpring是支持AOP编程的框架之一（实际上它整合了AspectJ框架的一部分），要使用AOP我们需要先导入一个依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.13&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n那么，如何使用AOP呢？首先我们要明确，要实现AOP操作，我们需要知道这些内容：\n\n需要切入的类，类的哪个方法需要被切入\n切入之后需要执行什么动作\n是在方法执行前切入还是在方法执行后切入\n如何告诉Spring需要进行切入\n\n那么我们依次来看，首先需要解决的问题是，找到需要切入的类：\npublic class Student &#123;\n    String name;\n    int age;\n\n\t\t&#x2F;&#x2F;分别在test方法执行前后切入\n    public int test(String str) &#123;\n        System.out.println(&quot;我是一个测试方法：&quot;+str);\n        return str.length();\n    &#125;\n&#125;\n\n现在我们希望在test方法执行前后添加我们的额外执行的内容，接着，我们来看看如何为方法执行前和执行后添加切入动作。比如现在我们想在方法返回之后，再执行我们的动作，首先定义我们要执行的操作：\npublic class AopTest &#123;\n\n    &#x2F;&#x2F;执行之后的方法\n    public void after()&#123;\n        System.out.println(&quot;我是执行之后&quot;);\n    &#125;\n\n    &#x2F;&#x2F;执行之前的方法\n    public void before()&#123;\n        System.out.println(&quot;我是执行之前&quot;);\n    &#125;\n&#125;\n\n那么，现在如何告诉Spring我们需要在方法执行之前和之后插入其他逻辑呢？首先我们将要进行AOP操作的类注册为Bean：\n&lt;bean name&#x3D;&quot;student&quot; class&#x3D;&quot;com.test.bean.Student&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;aopTest&quot; class&#x3D;&quot;com.test.aop.AopTest&quot;&#x2F;&gt;\n\n一个是Student类，还有一个就是包含我们要切入方法的AopTest类，注册为Bean后，他们就交给Spring进行管理，这样Spring才能帮助我们完成AOP操作。\n接着，我们需要告诉Spring，我们需要添加切入点，首先将顶部修改为，引入aop相关标签：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;\n\n通过使用aop:config来添加一个新的AOP配置：\n&lt;aop:config&gt;\n    \n&lt;&#x2F;aop:config&gt;\n\n首先第一行，我们需要告诉Spring，我们要切入的是哪一个类的哪个或是哪些方法：\n&lt;aop:pointcut id&#x3D;&quot;test&quot; expression&#x3D;&quot;execution(* com.test.bean.Student.test(String))&quot;&#x2F;&gt;\n\n其中，expression属性的execution填写格式如下：\n修饰符 包名.类名.方法名称(方法参数)\n\n\n修饰符：public、protected、private、包括返回值类型、static等等（使用*代表任意修饰符）\n包名：如com.test（*代表全部，比如com.*代表com包下的全部包）\n类名：使用*也可以代表包下的所有类\n方法名称：可以使用*代表全部方法\n方法参数：填写对应的参数即可，比如(String, String)，也可以使用*来代表任意一个参数，使用..代表所有参数。\n\n也可以使用其他属性来进行匹配，比如@annotation可以用于表示标记了哪些注解的方法被切入。\n接着，我们需要为此方法添加一个执行前动作和一个执行后动作：\n&lt;aop:aspect ref&#x3D;&quot;aopTest&quot;&gt;\n    &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;test&quot;&#x2F;&gt;\n    &lt;aop:after-returning method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;test&quot;&#x2F;&gt;\n&lt;&#x2F;aop:aspect&gt;\n\n这样，我们就完成了全部的配置，现在来实验一下吧：\npublic static void main(String[] args) &#123;\n    ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;test.xml&quot;);\n    Student student &#x3D; context.getBean(Student.class);\n    student.test(&quot;lbwnb&quot;);\n&#125;\n\n我们发现，方法执行前后，分别调用了我们对应的方法。但是仅仅这样还是不能满足一些需求，在某些情况下，我们可以需求方法执行的一些参数，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等。\n这个时候，我们可以为我们切入的方法添加一个参数，通过此参数就可以快速获取切点位置的一些信息：\n&#x2F;&#x2F;执行之前的方法\npublic void before(JoinPoint point)&#123;\n    System.out.println(&quot;我是执行之前&quot;);\n    System.out.println(point.getTarget());  &#x2F;&#x2F;获取执行方法的对象\n    System.out.println(Arrays.toString(point.getArgs()));  &#x2F;&#x2F;获取传入方法的实参\n&#125;\n\n通过添加JoinPoint作为形参，Spring会自动给我们一个实现类对象，这样我们就能获取方法的一些信息了。\n最后我们再来看环绕方法，环绕方法相当于完全代理了此方法，它完全将此方法包含在中间，需要我们手动调用才可以执行此方法，并且我们可以直接获取更多的参数：\npublic Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;\n    System.out.println(&quot;方法开始之前&quot;);\n    Object value &#x3D; joinPoint.proceed();\n    System.out.println(&quot;方法执行完成，结果为：&quot;+value);\n    return value;\n&#125;\n\n注意，如果代理方法存在返回值，那么环绕方法也需要有一个返回值，通过proceed方法来执行代理的方法，也可以修改参数之后调用proceed(Object[])，使用我们给定的参数再去执行：\npublic Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;\n    System.out.println(&quot;方法开始之前&quot;);\n    String arg &#x3D; joinPoint.getArgs()[0] + &quot;伞兵一号&quot;;\n    Object value &#x3D; joinPoint.proceed(new Object[]&#123;arg&#125;);\n    System.out.println(&quot;方法执行完成，结果为：&quot;+value);\n    return value;\n&#125;\n\n使用接口实现AOP前面我们介绍了如何使用xml配置一个AOP操作，这节课我们来看看如何使用Advice实现AOP。\n它与我们之前学习的动态代理更接近一些，比如在方法开始执行之前或是执行之后会去调用我们实现的接口，首先我们需要将一个类实现Advice接口，只有实现此接口，才可以被通知，比如我们这里使用MethodBeforeAdvice表示是一个在方法执行之前的动作：\npublic class AopTest implements MethodBeforeAdvice &#123;\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable &#123;\n        System.out.println(&quot;通过Advice实现AOP&quot;);\n    &#125;\n&#125;\n\n我们发现，方法中包括了很多的参数，其中args代表的是方法执行前得到的实参列表，还有target表示执行此方法的实例对象。运行之后，效果和之前是一样的，但是在这里我们就可以快速获取到更多信息。\n&lt;aop:config&gt;\n    &lt;aop:pointcut id&#x3D;&quot;stu&quot; expression&#x3D;&quot;execution(* com.test.bean.Student.say(String))&quot;&#x2F;&gt;\n    &lt;aop:advisor advice-ref&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;stu&quot;&#x2F;&gt;\n&lt;&#x2F;aop:config&gt;\n\n除了此接口以外，还有其他的接口，比如AfterReturningAdvice就需要实现一个方法执行之后的操作：\npublic class AopTest implements MethodBeforeAdvice, AfterReturningAdvice &#123;\n    @Override\n    public void before(Method method, Object[] args, Object target) throws Throwable &#123;\n        System.out.println(&quot;我是方法执行之前！&quot;);\n    &#125;\n\n    @Override\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;\n        System.out.println(&quot;我是方法执行之后！&quot;);\n    &#125;\n&#125;\n\n其实，我们之前学习的操作正好对应了AOP 领域中的特性术语：\n\n通知（Advice）: AOP 框架中的增强处理，通知描述了切面何时执行以及如何执行增强处理，也就是我们上面编写的方法实现。\n连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。\n切点（PointCut）: 可以插入增强处理的连接点，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。\n切面（Aspect）: 切面是通知和切点的结合，我们之前在xml中定义的就是切面，包括很多信息。\n引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。\n织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，我们之前都是在将我们的增强处理添加到目标对象，也就是织入（这名字挺有文艺范的）\n\n\n使用注解开发前面我们已经了解了IoC容器和AOP实现，但是我们发现，要使用这些功能，我们就不得不编写大量的配置，这是非常浪费时间和精力的，并且我们还只是演示了几个小的例子，如果是像之前一样去编写一个完整的Web应用程序，那么产生的配置可能会非常多。能否有一种更加高效的方法能够省去配置呢？当然还是注解了。\n所以说，第一步先把你的xml配置文件删了吧，现在我们全部使用注解进行开发（哈哈，是不是感觉XML配置白学了）\n注解实现配置文件那么，现在既然不使用XML文件了，那通过注解的方式就只能以实体类的形式进行配置了，我们在要作为配置的类上添加@Configuration注解，我们这里创建一个新的类MainConfiguration：\n@Configuration\npublic class MainConfiguration &#123;\n    &#x2F;&#x2F;没有配置任何Bean\n&#125;\n\n你可以直接把它等价于：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\t\t&lt;!-- 没有配置任何Bean --&gt;\n&lt;&#x2F;beans&gt;\n\n那么我们来看看，如何配置Bean，之前我们是直接在配置文件中编写Bean的一些信息，现在在配置类中，我们只需要编写一个方法，并返回我们要创建的Bean的对象即可，并在其上方添加@Bean注解：\n@Bean\npublic Card card()&#123;\n    return new Card();\n&#125;\n\n这样，等价于：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\t\t&lt;bean class&#x3D;&quot;com.test.bean.Card&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n我们还可以继续添加@Scope注解来指定作用域，这里我们就用原型模式：\n@Bean\n@Scope(&quot;prototype&quot;)\npublic Card card()&#123;\n    return new Card();\n&#125;\n\n采用这种方式，我们就可以更加方便地控制一个Bean对象的创建过程，现在相当于这个对象时由我们创建好了再交给Spring进行后续处理，我们可以在对象创建时做很多额外的操作，包括一些属性值的配置等。\n既然现在我们已经创建好了配置类，接着我们就可以在主方法中加载此配置类，并创建一个基于配置类的容器：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n      \t&#x2F;&#x2F;使用AnnotationConfigApplicationContext来实现注解配置\n        AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(MainConfiguration.class); &#x2F;&#x2F;这里需要告诉Spring哪个类作为配置类\n        Card card &#x3D; context.getBean(Card.class);  &#x2F;&#x2F;容器用法和之前一样\n        System.out.println(card);\n    &#125;\n&#125;\n\n在配置的过程中，我们可以点击IDEA底部的Spring标签，打开后可以对当前向容器中注册的Bean进行集中查看，并且会标注Bean之间的依赖关系，我们可以发现，Bean的默认名称实际上就是首字母小写的方法名称，我们也可以手动指定：\n@Bean(&quot;lbwnb&quot;)\n@Scope(&quot;prototype&quot;)\npublic Card card()&#123;\n    return new Card();\n&#125;\n\n除了像原来一样在配置文件中创建Bean以外，我们还可以直接在类上添加@Component注解来将一个类进行注册（现在最常用的方式），不过要实现这样的方式，我们需要添加一个自动扫描，来告诉Spring需要在哪些包中查找我们提供@Component声明的Bean。\n只需要在配置类上添加一个@ComponentScan注解即可，如果要添加多个包进行扫描，可以使用@ComponentScans来批量添加。这里我们演示将bean包下的所有类进行扫描：\n@ComponentScan(&quot;com.test.bean&quot;)\n@Configuration\npublic class MainConfiguration &#123;\n\n&#125;\n\n现在删除类中的Bean定义，我们在Student类的上面添加@Component注解，来表示此类型需要作为Bean交给容器进行管理：\n@Component\n@Scope(&quot;prototype&quot;)\npublic class Student &#123;\n    String name;\n    int age;\n    Card card;\n&#125;\n\n同样的，在类上也可以直接添加@Scope来限定作用域。\n效果和刚刚实际上是相同的，我们可以来测试一下：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(MainConfiguration.class);\n        System.out.println(context.getBean(Student.class));\n    &#125;\n&#125;\n\n我们可以看到IDEA的Spring板块中也显示了我们刚刚通过直接在类上添加@Component声明的Bean。\n与@Component同样效果的还有@Controller、@Service和@Repository，但是现在暂时不提，讲到SpringMVC时再来探讨。\n现在我们就有两种方式注册一个Bean了，那么如何实现像之前一样的自动注入呢，比如我们将Card也注册为Bean，我们希望Spring自动将其注入到Student的属性中：\n@Component\npublic class Student &#123;\n    String name;\n    int sid;\n    Card card;\n&#125;\n\n因此，我们可以将此类型，也通过这种方式注册为一个Bean：\n@Component\n@Scope(&quot;prototype&quot;)\npublic class Card &#123;\n&#125;\n\n现在，我们在需要注入的位置，添加一个@Resource注解来实现自动装配：\n@Component\npublic class Student &#123;\n    String name;\n    int sid;\n    \n    @Resource\n    Card card;\n&#125;\n\n这样的好处是，我们完全不需要创建任何的set方法，只需要添加这样的一个注解就可以了，Spring会跟之前配置文件的自动注入一样，在整个容器中进行查找，并将对应的Bean实例对象注入到此属性中，当然，如果还是需要通过set方法来注入，可以将注解添加到方法上：\n@Component\npublic class Student &#123;\n    String name;\n    int sid;\n    Card card;\n\n    @Resource\n    public void setCard(Card card) &#123;\n        System.out.println(&quot;通过方法&quot;);\n        this.card &#x3D; card;\n    &#125;\n&#125;\n\n除了使用@Resource以外，我们还可以使用@Autowired（IDEA不推荐将其使用在字段上，会出现黄标，但是可以放在方法或是构造方法上），它们的效果是一样的，但是它们存在区别，虽然它们都是自动装配：\n\n@Resource默认ByName如果找不到则ByType，可以添加到set方法、字段上。\n@Autowired默认是byType，可以添加在构造方法、set方法、字段、方法参数上。\n\n并且@Autowired可以配合@Qualifier使用，来指定一个名称的Bean进行注入：\n@Autowired\n@Qualifier(&quot;sxc&quot;)\npublic void setCard(Card card) &#123;\n    System.out.println(&quot;通过方法&quot;);\n    this.card &#x3D; card;\n&#125;\n\n如果Bean是在配置文件中进行定义的，我们还可以在方法的参数中使用@Autowired来进行自动注入：\n@ComponentScan(&quot;com.test.bean&quot;)\n@Configuration\npublic class MainConfiguration &#123;\n\n    @Bean\n    public Student student(@Autowired Card card)&#123;\n        Student student &#x3D; new Student();\n        student.setCard(card);\n        return student;\n    &#125;\n&#125;\n\n我们还可以通过@PostConstruct注解来添加构造后执行的方法，它等价于之前讲解的init-method：\n@PostConstruct\npublic void init()&#123;\n    System.out.println(&quot;我是初始化方法！1&quot;);\n&#125;\n\n注意它们的顺序：Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct\n同样的，如果需要销毁方法，也可以使用@PreDestroy注解，这里就不做演示了。\n这样，两种通过注解进行Bean声明的方式就讲解完毕了，那么什么时候该用什么方式去声明呢？\n\n如果要注册为Bean的类是由其他框架提供，我们无法修改其源代码，那么我们就使用第一种方式进行配置。\n如果要注册为Bean的类是我们自己编写的，我们就可以直接在类上添加注解，并在配置中添加扫描。\n\n注解实现AOP操作了解了如何使用注解注册Bean之后，我们接着来看如何通过注解实现AOP操作，首先我们需要在主类添加@EnableAspectJAutoProxy注解，开启AOP注解支持：\n@EnableAspectJAutoProxy\n@ComponentScan(&quot;com.test.bean&quot;)\n@Configuration\npublic class MainConfiguration &#123;\n&#125;\n\n接着我们只需在定义AOP增强操作的类上添加@Aspect注解和@Component将其注册为Bean即可，就像我们之前在配置文件中也要将其注册为Bean：\n@Component\n@Aspect\npublic class AopTest &#123;\n\n&#125;\n\n接着，我们直接在里面编写方法，并将此方法添加到一个切点中，比如我们希望在Student的test方法执行之前执行我们的方法：\npublic int test(String str)&#123;\n    System.out.println(&quot;我被调用了:&quot;+str);\n    return str.length();\n&#125;\n\n只需要添加@Before注解即可：\n@Before(&quot;execution(* com.test.bean.Student.test(..))&quot;)\npublic void before()&#123;\n    System.out.println(&quot;我是之前执行的内容！&quot;);\n&#125;\n\n同样的，我们可以为其添加JoinPoint参数来获取切入点信息：\n@Before(&quot;execution(* com.test.bean.Student.test(..))&quot;)\npublic void before(JoinPoint point)&#123;\n    System.out.println(&quot;参数列表：&quot;+ Arrays.toString(point.getArgs()));\n    System.out.println(&quot;我是之前执行的内容！&quot;);\n&#125;\n\n我们也可以使用@AfterReturning注解来指定方法返回后的操作：\n@AfterReturning(value &#x3D; &quot;execution(* com.test.bean.Student.test(..))&quot;, returning &#x3D; &quot;returnVal&quot;)\npublic void after(Object returnVal)&#123;\n    System.out.println(&quot;方法已返回，结果为：&quot;+returnVal);\n&#125;\n\n我们还可以指定returning属性，并将其作为方法某个参数的实参。同样的，环绕也可以直接通过注解声明：\n@Around(&quot;execution(* com.test.bean.Student.test(..))&quot;)\npublic Object around(ProceedingJoinPoint point) throws Throwable &#123;\n    System.out.println(&quot;方法执行之前！&quot;);\n    Object val &#x3D; point.proceed();\n    System.out.println(&quot;方法执行之后！&quot;);\n    return val;\n&#125;\n\n其他注解配置配置文件可能不止一个，我们有可能会根据模块划分，定义多个配置文件，这个时候，可能会出现很多个配置类，如果我们需要@Import注解来快速将某个类加入到容器中，比如我们现在创建一个新的配置文件，并将数据库Bean也搬过去：\npublic class Test2Configuration &#123;\n    @Bean\n    public Connection getConnection() throws SQLException &#123;\n        System.out.println(&quot;创建新的连接！&quot;);\n        return DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;study&quot;,\n                &quot;root&quot;,\n                &quot;root&quot;);\n    &#125;\n&#125;\n\n@EnableAspectJAutoProxy\n@Configuration\n@ComponentScan(&quot;com.test&quot;)\n@Import(Test2Configuration.class)\npublic class TestConfiguration &#123;\n\n    @Resource\n    Connection connection;\n\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(connection);\n    &#125;\n&#125;\n\n注意另一个配置类并没有添加任何注解，实际上，相当于导入的类被强制注册为了一个Bean，到现在，我们一共了解了三种注册为Bean的方式，利用这种特性，我们还可以将其他的类型也强制注册为Bean：\n@EnableAspectJAutoProxy\n@Configuration\n@ComponentScan(&quot;com.test&quot;)\n@Import(&#123;Test2Configuration.class, Date.class&#125;)\npublic class TestConfiguration &#123;\n\n    @Resource\n    Connection connection;\n    @Resource\n    Date date;\n\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(date+&quot; -&gt; &quot;+connection);\n    &#125;\n&#125;\n\n可以看到，日期直接作为一个Bean放入到IoC容器中了，并且时间永远都是被new的那个时间，也就是同一个对象（因为默认是单例模式）。\n通过@Import方式最主要为了实现的目标并不是创建Bean，而是为了方便一些框架的Registrar进行Bean定义，在讲解到Spring原理时，我们再来详细讨论，目前只做了解即可。\n到这里，关于Spring框架的大致内容就聊得差不多了，其余的内容，我们会在后面继续讲解。\n\n深入Mybatis框架学习了Spring之后，我们已经了解如何将一个类作为Bean交由IoC容器管理，也就是说，现在我们可以通过更方便的方式来使用Mybatis框架，我们可以直接把SqlSessionFactory、Mapper交给Spring进行管理，并且可以通过注入的方式快速地使用它们。\n因此，我们要学习一下如何将Mybatis与Spring进行整合，那么首先，我们需要在之前知识的基础上继续深化学习。\n了解数据源在之前，我们如果需要创建一个JDBC的连接，那么必须使用DriverManager.getConnection()来创建连接，连接建立后，我们才可以进行数据库操作。\n而学习了Mybatis之后，我们就不用再去使用DriverManager为我们提供连接对象，而是直接使用Mybatis为我们提供的SqlSessionFactory工具类来获取对应的SqlSession通过会话对象去操作数据库。\n那么，它到底是如何封装JDBC的呢？我们可以试着来猜想一下，会不会是Mybatis每次都是帮助我们调用DriverManager来实现的数据库连接创建？我们可以看看Mybatis的源码：\npublic SqlSession openSession(boolean autoCommit) &#123;\n    return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, autoCommit);\n&#125;\n\n在通过SqlSessionFactory调用openSession方法之后，它调用了内部的一个私有的方法openSessionFromDataSource，我们接着来看，这个方法里面定义了什么内容：\nprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;\n    Transaction tx &#x3D; null;\n\n    DefaultSqlSession var8;\n    try &#123;\n      \t&#x2F;&#x2F;获取当前环境（由配置文件映射的对象实体）\n        Environment environment &#x3D; this.configuration.getEnvironment();\n      \t&#x2F;&#x2F;事务工厂（暂时不提，下一板块讲解）\n        TransactionFactory transactionFactory &#x3D; this.getTransactionFactoryFromEnvironment(environment);\n      \t&#x2F;&#x2F;配置文件中：&lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n      \t&#x2F;&#x2F;生成事务（根据我们的配置，会默认生成JdbcTransaction），这里是关键，我们看到这里用到了environment.getDataSource()方法\n        tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n      \t&#x2F;&#x2F;执行器，包括全部的数据库操作方法定义，本质上是在使用执行器操作数据库，需要传入事务对象\n        Executor executor &#x3D; this.configuration.newExecutor(tx, execType);\n      \t&#x2F;&#x2F;封装为SqlSession对象\n        var8 &#x3D; new DefaultSqlSession(this.configuration, executor, autoCommit);\n    &#125; catch (Exception var12) &#123;\n        this.closeTransaction(tx);\n        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + var12, var12);\n    &#125; finally &#123;\n        ErrorContext.instance().reset();\n    &#125;\n\t\t\n    return var8;\n&#125;\n\n也就是说，我们的数据源配置信息，存放在了Transaction对象中，那么现在我们只需要知道执行器到底是如何执行SQL语句的，我们就知道到底如何创建Connection对象了，就需要获取数据库的链接信息了，那么我们来看看，这个DataSource到底是个什么：\npublic interface DataSource  extends CommonDataSource, Wrapper &#123;\n\n  Connection getConnection() throws SQLException;\n\n  Connection getConnection(String username, String password)\n    throws SQLException;\n&#125;\n\n我们发现，它是在javax.sql定义的一个接口，它包括了两个方法，都是用于获取连接的。因此，现在我们可以断定，并不是通过之前DriverManager的方法去获取连接了，而是使用DataSource的实现类来获取的，因此，也就正式引入到我们这一节的话题了：\n\n\n\n\n\n\n\n\n\n数据库链接的建立和关闭是极其耗费系统资源的操作，通过DriverManager获取的数据库连接，一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完后立即关闭连接，频繁的打开、关闭连接会持续消耗网络资源，造成整个系统性能的低下。\n因此，JDBC为我们定义了一个数据源的标准，也就是DataSource接口，告诉数据源数据库的连接信息，并将所有的连接全部交给数据源进行集中管理，当需要一个Connection对象时，可以向数据源申请，数据源会根据内部机制，合理地分配连接对象给我们。\n一般比较常用的DataSource实现，都是采用池化技术，就是在一开始就创建好N个连接，这样之后使用就无需再次进行连接，而是直接使用现成的Connection对象进行数据库操作。\n\n当然，也可以使用传统的即用即连的方式获取Connection对象，Mybatis为我们提供了几个默认的数据源实现，我们之前一直在使用的是官方的默认配置，也就是池化数据源：\n&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n      &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;\n      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;\n    &lt;&#x2F;dataSource&gt;\n\n一共三个选项：\n\nUNPOOLED    不使用连接池的数据源\nPOOLED      使用连接池的数据源\nJNDI        使用JNDI实现的数据源\n\n解读Mybatis数据源实现那么我们先来看看，不使用池化的数据源实现，它叫做UnpooledDataSource，我们来看看源码：\npublic class UnpooledDataSource implements DataSource &#123;\n    private ClassLoader driverClassLoader;\n    private Properties driverProperties;\n    private static Map&lt;String, Driver&gt; registeredDrivers &#x3D; new ConcurrentHashMap();\n    private String driver;\n    private String url;\n    private String username;\n    private String password;\n    private Boolean autoCommit;\n    private Integer defaultTransactionIsolationLevel;\n    private Integer defaultNetworkTimeout;\n\n首先这个类中定义了很多的成员，包括数据库的连接信息、数据库驱动信息、事务相关信息等。\n我们接着来看，它是如何实现DataSource中提供的接口的：\npublic Connection getConnection() throws SQLException &#123;\n    return this.doGetConnection(this.username, this.password);\n&#125;\n\npublic Connection getConnection(String username, String password) throws SQLException &#123;\n    return this.doGetConnection(username, password);\n&#125;\n\n实际上，这两个方法都指向了内部的一个doGetConnection方法，那么我们接着来看：\nprivate Connection doGetConnection(String username, String password) throws SQLException &#123;\n    Properties props &#x3D; new Properties();\n    if (this.driverProperties !&#x3D; null) &#123;\n        props.putAll(this.driverProperties);\n    &#125;\n\n    if (username !&#x3D; null) &#123;\n        props.setProperty(&quot;user&quot;, username);\n    &#125;\n\n    if (password !&#x3D; null) &#123;\n        props.setProperty(&quot;password&quot;, password);\n    &#125;\n\n    return this.doGetConnection(props);\n&#125;\n\n首先它将数据库的连接信息也给添加到Properties对象中进行存放，并交给下一个doGetConnection来处理，套娃就完事了呗，接着来看下一层源码：\nprivate Connection doGetConnection(Properties properties) throws SQLException &#123;\n  \t&#x2F;&#x2F;若未初始化驱动，需要先初始化，内部维护了一个Map来记录初始化信息，这里不多介绍了\n    this.initializeDriver();\n  \t&#x2F;&#x2F;传统的获取连接的方式\n    Connection connection &#x3D; DriverManager.getConnection(this.url, properties);\n  \t&#x2F;&#x2F;对连接进行额外的一些配置\n    this.configureConnection(connection);\n    return connection;\n&#125;\n\n到这里，就返回Connection对象了，而此对象正是通过DriverManager来创建的，因此，非池化的数据源实现依然使用的是传统的连接创建方式，那我们接着来看池化的数据源实现，它是PooledDataSource类：\npublic class PooledDataSource implements DataSource &#123;\n    private static final Log log &#x3D; LogFactory.getLog(PooledDataSource.class);\n    private final PoolState state &#x3D; new PoolState(this);\n    private final UnpooledDataSource dataSource;\n    protected int poolMaximumActiveConnections &#x3D; 10;\n    protected int poolMaximumIdleConnections &#x3D; 5;\n    protected int poolMaximumCheckoutTime &#x3D; 20000;\n    protected int poolTimeToWait &#x3D; 20000;\n    protected int poolMaximumLocalBadConnectionTolerance &#x3D; 3;\n    protected String poolPingQuery &#x3D; &quot;NO PING QUERY SET&quot;;\n    protected boolean poolPingEnabled;\n    protected int poolPingConnectionsNotUsedFor;\n    private int expectedConnectionTypeCode;\n\n我们发现，在这里的定义就比非池化的实现复杂得多了，因为它还要考虑并发的问题，并且还要考虑如何合理地存放大量的链接对象，该如何进行合理分配，因此它的玩法非常之高级，但是，再高级的玩法，我们都要拿下。\n首先注意，它存放了一个UnpooledDataSource，此对象是在构造时就被创建，其实创建Connection还是依靠数据库驱动创建，我们后面慢慢解析，首先我们来看看它是如何实现接口方法的：\npublic Connection getConnection() throws SQLException &#123;\n    return this.popConnection(this.dataSource.getUsername(), this.dataSource.getPassword()).getProxyConnection();\n&#125;\n\npublic Connection getConnection(String username, String password) throws SQLException &#123;\n    return this.popConnection(username, password).getProxyConnection();\n&#125;\n\n可以看到，它调用了popConnection()方法来获取连接对象，然后进行了一个代理，我们可以猜测，有可能整个连接池就是一个类似于栈的集合类型结构实现的。那么我们接着来看看popConnection方法：\nprivate PooledConnection popConnection(String username, String password) throws SQLException &#123;\n    boolean countedWait &#x3D; false;\n  \t&#x2F;&#x2F;返回的是PooledConnection对象，\n    PooledConnection conn &#x3D; null;\n    long t &#x3D; System.currentTimeMillis();\n    int localBadConnectionCount &#x3D; 0;\n\n    while(conn &#x3D;&#x3D; null) &#123;\n        synchronized(this.state) &#123;   &#x2F;&#x2F;加锁，因为有可能很多个线程都需要获取连接对象\n            PoolState var10000;\n          \t&#x2F;&#x2F;PoolState存了两个List，一个是空闲列表，一个是活跃列表\n            if (!this.state.idleConnections.isEmpty()) &#123;   &#x2F;&#x2F;有空闲连接时，可以直接分配Connection\n                conn &#x3D; (PooledConnection)this.state.idleConnections.remove(0);  &#x2F;&#x2F;ArrayList中取第一个元素\n                if (log.isDebugEnabled()) &#123;\n                    log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);\n                &#125;\n              &#x2F;&#x2F;如果已经没有多余的连接可以分配，那么就检查一下活跃连接数是否达到最大的分配上限，如果没有，就new一个\n            &#125; else if (this.state.activeConnections.size() &lt; this.poolMaximumActiveConnections) &#123;\n              \t&#x2F;&#x2F;注意new了之后并没有立即往List里面塞，只是存了一些基本信息\n              \t&#x2F;&#x2F;我们发现，这里依靠UnpooledDataSource创建了一个Connection对象，并将其封装到PooledConnection中\n                conn &#x3D; new PooledConnection(this.dataSource.getConnection(), this);\n                if (log.isDebugEnabled()) &#123;\n                    log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);\n                &#125;\n              &#x2F;&#x2F;以上条件都不满足，那么只能从之前的连接中寻找了，看看有没有那种卡住的链接（由于网络问题有可能之前的连接一直被卡住，然而正常情况下早就结束并且可以使用了，所以这里相当于是优化也算是一种捡漏的方式）\n            &#125; else &#123;\n              \t&#x2F;&#x2F;获取最早创建的连接\n                PooledConnection oldestActiveConnection &#x3D; (PooledConnection)this.state.activeConnections.get(0);\n                long longestCheckoutTime &#x3D; oldestActiveConnection.getCheckoutTime();\n              \t&#x2F;&#x2F;判断是否超过最大的使用时间\n                if (longestCheckoutTime &gt; (long)this.poolMaximumCheckoutTime) &#123;\n                  \t&#x2F;&#x2F;超时统计信息（不重要）\n                    ++this.state.claimedOverdueConnectionCount;\n                    var10000 &#x3D; this.state;\n                    var10000.accumulatedCheckoutTimeOfOverdueConnections +&#x3D; longestCheckoutTime;\n                    var10000 &#x3D; this.state;\n                    var10000.accumulatedCheckoutTime +&#x3D; longestCheckoutTime;\n                  \t&#x2F;&#x2F;从活跃列表中移除此链接信息\n                    this.state.activeConnections.remove(oldestActiveConnection);\n                  \t&#x2F;&#x2F;如果开启事务，还需要回滚一下\n                    if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;\n                        try &#123;\n                            oldestActiveConnection.getRealConnection().rollback();\n                        &#125; catch (SQLException var15) &#123;\n                            log.debug(&quot;Bad connection. Could not roll back&quot;);\n                        &#125;\n                    &#125;\n\t\t\t\t\t\t\t\t\t\t\n                  \t&#x2F;&#x2F;这里就根据之前的连接对象直接new一个新的连接（注意使用的还是之前的Connection对象，只是被重新封装了）\n                    conn &#x3D; new PooledConnection(oldestActiveConnection.getRealConnection(), this);\n                    conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());\n                    conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());\n                  \t&#x2F;&#x2F;过期\n                    oldestActiveConnection.invalidate();\n                    if (log.isDebugEnabled()) &#123;\n                        log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);\n                    &#125;\n                &#125; else &#123;\n                  &#x2F;&#x2F;确实是没得用了，只能卡住了（阻塞）\n                  &#x2F;&#x2F;然后记录一下有几个线程在等待当前的任务搞完\n                    try &#123;\n                        if (!countedWait) &#123;\n                            ++this.state.hadToWaitCount;\n                            countedWait &#x3D; true;\n                        &#125;\n\n                        if (log.isDebugEnabled()) &#123;\n                            log.debug(&quot;Waiting as long as &quot; + this.poolTimeToWait + &quot; milliseconds for connection.&quot;);\n                        &#125;\n\n                        long wt &#x3D; System.currentTimeMillis();\n                        this.state.wait((long)this.poolTimeToWait);   &#x2F;&#x2F;要是超过等待时间还是没等到，只能放弃\n                      \t&#x2F;&#x2F;注意这样的话con就为null了\n                        var10000 &#x3D; this.state;\n                        var10000.accumulatedWaitTime +&#x3D; System.currentTimeMillis() - wt;\n                    &#125; catch (InterruptedException var16) &#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n\t\t\t\t\t\t\n          \t&#x2F;&#x2F;经过之前的操作，已经成功分配到连接对象的情况下\n            if (conn !&#x3D; null) &#123;\n                if (conn.isValid()) &#123;  &#x2F;&#x2F;是否有效\n                    if (!conn.getRealConnection().getAutoCommit()) &#123;  &#x2F;&#x2F;清理之前遗留的事务操作\n                        conn.getRealConnection().rollback();\n                    &#125;\n\n                    conn.setConnectionTypeCode(this.assembleConnectionTypeCode(this.dataSource.getUrl(), username, password));\n                    conn.setCheckoutTimestamp(System.currentTimeMillis());\n                    conn.setLastUsedTimestamp(System.currentTimeMillis());\n                  \t&#x2F;&#x2F;添加到活跃表中\n                    this.state.activeConnections.add(conn);\n                    &#x2F;&#x2F;统计信息（不重要）\n                    ++this.state.requestCount;\n                    var10000 &#x3D; this.state;\n                    var10000.accumulatedRequestTime +&#x3D; System.currentTimeMillis() - t;\n                &#125; else &#123;\n                  \t&#x2F;&#x2F;无效的连接，直接抛异常\n                    if (log.isDebugEnabled()) &#123;\n                        log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;);\n                    &#125;\n\n                    ++this.state.badConnectionCount;\n                    ++localBadConnectionCount;\n                    conn &#x3D; null;\n                    if (localBadConnectionCount &gt; this.poolMaximumIdleConnections + this.poolMaximumLocalBadConnectionTolerance) &#123;\n                        if (log.isDebugEnabled()) &#123;\n                            log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);\n                        &#125;\n\n                        throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\t\n  \t&#x2F;&#x2F;最后该干嘛干嘛，拿不到连接直接抛异常\n    if (conn &#x3D;&#x3D; null) &#123;\n        if (log.isDebugEnabled()) &#123;\n            log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);\n        &#125;\n\n        throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);\n    &#125; else &#123;\n        return conn;\n    &#125;\n&#125;\n\n经过上面一顿猛如虎的操作之后，我们可以得到以下信息：\n\n\n\n\n\n\n\n\n\n如果最后得到了连接对象（有可能是从空闲列表中得到，有可能是直接创建的新的，还有可能是经过回收策略回收得到的），那么连接(Connection)对象一定会被放在活跃列表中(state.activeConnections)\n那么肯定有一个疑问，现在我们已经知道获取一个链接会直接进入到活跃列表中，那么，如果一个连接被关闭，又会发生什么事情呢，我们来看看此方法返回之后，会调用getProxyConnection来获取一个代理对象，实际上就是PooledConnection类：\nclass PooledConnection implements InvocationHandler &#123;\n  private static final String CLOSE &#x3D; &quot;close&quot;;\n    private static final Class&lt;?&gt;[] IFACES &#x3D; new Class[]&#123;Connection.class&#125;;\n    private final int hashCode;\n  \t&#x2F;&#x2F;会记录是来自哪一个数据源创建的的\n    private final PooledDataSource dataSource;\n  \t&#x2F;&#x2F;连接对象本体\n    private final Connection realConnection;\n  \t&#x2F;&#x2F;代理的链接对象\n    private final Connection proxyConnection;\n  ...\n\n它直接代理了构造方法中传入的Connection对象，也是使用JDK的动态代理实现的，那么我们来看一下，它是如何进行代理的：\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n    String methodName &#x3D; method.getName();\n  \t&#x2F;&#x2F;如果调用的是Connection对象的close方法，\n    if (&quot;close&quot;.equals(methodName)) &#123;\n      \t&#x2F;&#x2F;这里并不会真的关闭连接（这也是为什么用代理），而是调用之前数据源的pushConnection方法，将此连接改为为空闲状态\n        this.dataSource.pushConnection(this);\n        return null;\n    &#125; else &#123;\n        try &#123;\n            if (!Object.class.equals(method.getDeclaringClass())) &#123;\n                this.checkConnection();\n              \t&#x2F;&#x2F;任何操作执行之前都会检查连接是否可用\n            &#125;\n\n          \t&#x2F;&#x2F;该干嘛干嘛\n            return method.invoke(this.realConnection, args);\n        &#125; catch (Throwable var6) &#123;\n            throw ExceptionUtil.unwrapThrowable(var6);\n        &#125;\n    &#125;\n&#125;\n\n那么我们最后再来看看pushConnection方法：\nprotected void pushConnection(PooledConnection conn) throws SQLException &#123;\n    synchronized(this.state) &#123;   &#x2F;&#x2F;老规矩，先来把锁\n      \t&#x2F;&#x2F;先从活跃列表移除此连接\n        this.state.activeConnections.remove(conn);\n      \t&#x2F;&#x2F;判断此链接是否可用\n        if (conn.isValid()) &#123;\n            PoolState var10000;\n          \t&#x2F;&#x2F;看看闲置列表容量是否已满（容量满了就回不去了）\n            if (this.state.idleConnections.size() &lt; this.poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() &#x3D;&#x3D; this.expectedConnectionTypeCode) &#123;\n                var10000 &#x3D; this.state;\n                var10000.accumulatedCheckoutTime +&#x3D; conn.getCheckoutTime();\n                if (!conn.getRealConnection().getAutoCommit()) &#123;\n                    conn.getRealConnection().rollback();\n                &#125;\n\n              \t&#x2F;&#x2F;把唯一有用的Connection对象拿出来，然后重新创建一个PooledConnection\n                PooledConnection newConn &#x3D; new PooledConnection(conn.getRealConnection(), this);\n              \t&#x2F;&#x2F;放入闲置列表，成功回收\n                this.state.idleConnections.add(newConn);\n                newConn.setCreatedTimestamp(conn.getCreatedTimestamp());\n                newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());\n                conn.invalidate();\n                if (log.isDebugEnabled()) &#123;\n                    log.debug(&quot;Returned connection &quot; + newConn.getRealHashCode() + &quot; to pool.&quot;);\n                &#125;\n\n                this.state.notifyAll();\n            &#125; else &#123;\n                var10000 &#x3D; this.state;\n                var10000.accumulatedCheckoutTime +&#x3D; conn.getCheckoutTime();\n                if (!conn.getRealConnection().getAutoCommit()) &#123;\n                    conn.getRealConnection().rollback();\n                &#125;\n\n                conn.getRealConnection().close();\n                if (log.isDebugEnabled()) &#123;\n                    log.debug(&quot;Closed connection &quot; + conn.getRealHashCode() + &quot;.&quot;);\n                &#125;\n\n                conn.invalidate();\n            &#125;\n        &#125; else &#123;\n            if (log.isDebugEnabled()) &#123;\n                log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) attempted to return to the pool, discarding connection.&quot;);\n            &#125;\n\n            ++this.state.badConnectionCount;\n        &#125;\n\n    &#125;\n&#125;\n\n这样，我们就已经完全了解了Mybatis的池化数据源的执行流程了。只不过，无论Connection管理方式如何变换，无论数据源再高级，我们要知道，它都最终都会使用DriverManager来创建连接对象，而最终使用的也是DriverManager提供的Connection对象。\n整合Mybatis框架通过了解数据源，我们已经清楚，Mybatis实际上是在使用自己编写的数据源（数据源有很多，之后我们再聊其他的）默认使用的是池化的数据源，它预先存储了很多的连接对象。\n那么我们来看一下，如何将Mybatis与Spring更好的结合呢，比如我们现在希望将SqlSessionFactory交给IoC容器进行管理，而不是我们自己创建工具类来管理（我们之前一直都在使用工具类管理和创建会话）\n首先导入依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;8.0.25&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.5.7&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.0.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.13&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n在mybatis-spring依赖中，为我们提供了SqlSessionTemplate类，它其实就是官方封装的一个工具类，我们可以将其注册为Bean，这样我们随时都可以向IoC容器索要，而不用自己再去编写一个工具类了，我们可以直接在配置类中创建：\n@Configuration\n@ComponentScan(&quot;com.test&quot;)\npublic class TestConfiguration &#123;\n    @Bean\n    public SqlSessionTemplate sqlSessionTemplate() throws IOException &#123;\n        SqlSessionFactory factory &#x3D; new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;));\n        return new SqlSessionTemplate(factory);\n    &#125;\n&#125;\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;study&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n  \t&lt;mappers&gt;\n        &lt;mapper class&#x3D;&quot;com.test.mapper.TestMapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\npublic static void main(String[] args) &#123;\n    ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n    SqlSessionTemplate template &#x3D; context.getBean(SqlSessionTemplate.class);\n    TestMapper testMapper &#x3D; template.getMapper(TestMapper.class);\n    System.out.println(testMapper.getStudent());\n&#125;\n\n@Mapper\npublic interface TestMapper &#123;\n\n    @Select(&quot;select * from student where sid &#x3D; 1&quot;)\n    Student getStudent();\n&#125;\n\n@Data\npublic class Student &#123;\n    int sid;\n    String name;\n    String sex;\n&#125;\n\n最后成功得到Student实体类，证明SqlSessionTemplate成功注册为Bean可以使用了。虽然这样已经很方便了，但是还不够方便，我们依然需要手动去获取Mapper对象，那么能否直接得到对应的Mapper对象呢，我们希望让Spring直接帮助我们管理所有的Mapper，当需要时，可以直接从容器中获取，我们可以直接在配置类上方添加注解：\n@MapperScan(&quot;com.test.mapper&quot;)\n\n这样，Spring会自动扫描所有的Mapper，并将其实现注册为Bean，那么我们现在就可以直接通过容器获取了：\npublic static void main(String[] args) throws InterruptedException &#123;\n    ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n    TestMapper mapper &#x3D; context.getBean(TestMapper.class);\n    System.out.println(mapper.getStudent());\n&#125;\n\n请一定注意，必须存在SqlSessionTemplate或是SqlSessionFactoryBean的Bean，否则会无法初始化（毕竟要数据库的链接信息）\n我们接着来看，如果我们希望直接去除Mybatis的配置文件，那么改怎么去实现呢？我们可以使用SqlSessionFactoryBean类：\n@Configuration\n@ComponentScan(&quot;com.test&quot;)\n@MapperScan(&quot;com.test.mapper&quot;)\npublic class TestConfiguration &#123;\n    @Bean\n    public DataSource dataSource()&#123;\n        return new PooledDataSource(&quot;com.mysql.cj.jdbc.Driver&quot;,\n                &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;study&quot;, &quot;root&quot;, &quot;123456&quot;);\n    &#125;\n\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactoryBean(@Autowired DataSource dataSource)&#123;\n        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();\n        bean.setDataSource(dataSource);\n        return bean;\n    &#125;\n&#125;\n\n首先我们需要创建一个数据源的实现类，因为这是数据库最基本的信息，然后再给到SqlSessionFactoryBean实例，这样，我们相当于直接在一开始通过IoC容器配置了SqlSessionFactory，只需要传入一个DataSource的实现即可。\n删除配置文件，重新再来运行，同样可以正常使用Mapper。从这里开始，通过IoC容器，Mybatis已经不再需要使用配置文件了，之后基于Spring的开发将不会再出现Mybatis的配置文件。\n使用HikariCP连接池前面我们提到了数据源还有其他实现，比如C3P0、Druid等，它们都是非常优秀的数据源实现（可以自行了解），不过我们这里要介绍的，是之后在SpringBoot中还会遇到的HikariCP连接池。\n\n\n\n\n\n\n\n\n\nHikariCP是由日本程序员开源的一个数据库连接池组件，代码非常轻量，并且速度非常的快。根据官方提供的数据，在酷睿i7开启32个线程32个连接的情况下，进行随机数据库读写操作，HikariCP的速度是现在常用的C3P0数据库连接池的数百倍。在SpringBoot2.0中，官方也是推荐使用HikariCP。\n\n首先，我们需要导入依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;com.zaxxer&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;HikariCP&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.4.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n接着修改一下Bean的定义：\n@Bean\npublic DataSource dataSource() throws SQLException &#123;\n    HikariDataSource dataSource &#x3D; new HikariDataSource();\n    dataSource.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;study&quot;);\n    dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    dataSource.setUsername(&quot;root&quot;);\n    dataSource.setPassword(&quot;123456&quot;);\n    return dataSource;\n&#125;\n\n最后我们发现，同样可以得到输出结果，但是出现了一个报错：\nSLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#StaticLoggerBinder for further details.\n\n此数据源实际上是采用了SLF4J日志框架打印日志信息，但是现在没有任何的日志实现（slf4j只是一个API标准，它规范了多种日志框架的操作，统一使用SLF4J定义的方法来操作不同的日志框架）我们这里就使用JUL作为日志实现，我们需要导入另一个依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;slf4j-jdk14&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.7.25&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n注意版本一定要和slf4j-api保持一致！\n这样就能得到我们的日志信息了：\n十二月 07, 2021 8:46:41 下午 com.zaxxer.hikari.HikariDataSource getConnection\n信息: HikariPool-1 - Starting...\n十二月 07, 2021 8:46:41 下午 com.zaxxer.hikari.HikariDataSource getConnection\n信息: HikariPool-1 - Start completed.\nStudent(sid&#x3D;1, name&#x3D;小明, sex&#x3D;男)\n\n在SpringBoot阶段，我们还会遇到HikariPool-1 - Starting...和HikariPool-1 - Start completed.同款日志信息。\n当然，Lombok肯定也是支持这个日志框架快速注解的：\n@Slf4j\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        log.info(&quot;项目正在启动...&quot;);\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n        TestMapper mapper &#x3D; context.getBean(TestMapper.class);\n        System.out.println(mapper.getStudent());\n    &#125;\n&#125;\n\nMybatis事务管理我们前面已经讲解了如何让Mybatis与Spring更好地融合在一起，通过将对应的Bean类型注册到容器中，就能更加方便的去使用Mapper，那么现在，我们接着来看Spring的事务控制。\n在开始之前，我们还是回顾一下事务机制。首先事务遵循一个ACID原则：\n\n原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。\n一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。\n隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。\n持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。\n\n简单来说，事务就是要么完成，要么就啥都别做！并且不同的事务直接相互隔离，互不干扰。\n那么我们接着来深入了解一下事务的隔离机制（在之前数据库入门阶段并没有提到）我们说了，事务之间是相互隔离互不干扰的，那么如果出现了下面的情况，会怎么样呢：\n\n\n\n\n\n\n\n\n\n当两个事务同时在执行，并且同时在操作同一个数据，这样很容易出现并发相关的问题，比如一个事务先读取了某条数据，而另一个事务此时修改了此数据，当前一个事务紧接着再次读取时，会导致和前一次读取的数据不一致，这就是一种典型的数据虚读现象。\n因此，为了解决这些问题，事务之间实际上是存在一些隔离级别的：\n\nISOLATION_READ_UNCOMMITTED（读未提交）：其他事务会读取当前事务尚未更改的提交（相当于读取的是这个事务暂时缓存的内容，并不是数据库中的内容）\nISOLATION_READ_COMMITTED（读已提交）：其他事务会读取当前事务已经提交的数据（也就是直接读取数据库中已经发生更改的内容）\nISOLATION_REPEATABLE_READ（可重复读）：其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改（注意这里仅仅是不允许修改数据）\nISOLATION_SERIALIZABLE（串行化）：它完全服从ACID原则，一个事务必须等待其他事务结束之后才能开始执行，相当于挨个执行，效率很低\n\n我们依次来看看，不同的隔离级别会导致什么问题。首先是读未提交级别，此级别属于最低级别，相当于各个事务共享一个缓存区域，任何事务的操作都在这里进行。那么它会导致以下问题：\n\n也就是说，事务A最后得到的实际上是一个毫无意义的数据（事务B已经回滚了）我们称此数据为”脏数据”，这种现象称为脏读\n我们接着来看读已提交级别，事务只能读取其他事务已经提交的内容，相当于直接从数据中读取数据，这样就可以避免脏读问题了，但是它还是存在以下问题：\n\n这正是我们前面例子中提到的问题，虽然它避免了脏读问题，但是如果事件B修改并提交了数据，那么实际上事务A之前读取到的数据依然不是最新的数据，直接导致两次读取的数据不一致，这种现象称为虚读也可以称为不可重复读\n因此，下一个隔离级别可重复读就能够解决这样的问题（MySQL的默认隔离级别），它规定在其他事务执行时，不允许修改数据，这样，就可以有效地避免不可重复读的问题，但是这样就一定安全了吗？这里仅仅是禁止了事务执行过程中的UPDATE操作，但是它并没有禁止INSERT这类操作，因此，如果事务A执行过程中事务B插入了新的数据，那么A这时是毫不知情的，比如：\n\n两个人同时报名一个活动，两个报名的事务同时在进行，但是他们一开始读取到的人数都是5，而这时，它们都会认为报名成功后人数应该变成6，而正常情况下应该是7，因此这个时候就发生了数据的幻读现象。\n因此，要解决这种问题，只能使用最后一种隔离级别串行化来实现了，每个事务不能同时进行，直接避免所有并发问题，简单粗暴，但是效率爆减，并不推荐。\n最后总结三种情况：\n\n脏读：读取到了被回滚的数据，它毫无意义。\n虚读（不可重复读）：由于其他事务更新数据，两次读取的数据不一致。\n幻读：由于其他事务执行插入删除操作，而又无法感知到表中记录条数发生变化，当下次再读取时会莫名其妙多出或缺失数据，就像产生幻觉一样。\n\n（对于虚读和幻读的区分：虚读是某个数据前后读取不一致，幻读是整个表的记录数量前后读取不一致）\n最后这张图，请务必记在你的脑海，记在你的心中，记在你的全世界：\n\nMybatis对于数据库的事务管理，也有着相应的封装。一个事务无非就是创建、提交、回滚、关闭，因此这些操作被Mybatis抽象为一个接口：\npublic interface Transaction &#123;\n    Connection getConnection() throws SQLException;\n\n    void commit() throws SQLException;\n\n    void rollback() throws SQLException;\n\n    void close() throws SQLException;\n\n    Integer getTimeout() throws SQLException;\n&#125;\n\n对于此接口的实现，MyBatis的事务管理分为两种形式：\n\n使用JDBC的事务管理机制：即利用对应数据库的驱动生成的Connection对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等，对应的实现类为JdbcTransaction\n使用MANAGED的事务管理机制：这种机制MyBatis自身不会去实现事务管理，而是让程序的容器（比如Spring）来实现对事务的管理，对应的实现类为ManagedTransaction\n\n而我们之前一直使用的其实就是JDBC的事务，相当于直接使用Connection对象（之前JavaWeb阶段已经讲解过了）在进行事务操作，并没有额外的管理机制，对应的配置为：\n&lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n\n那么我们来看看JdbcTransaction是不是像我们上面所说的那样管理事务的，直接上源码：\npublic class JdbcTransaction implements Transaction &#123;\n    private static final Log log &#x3D; LogFactory.getLog(JdbcTransaction.class);\n    protected Connection connection;\n    protected DataSource dataSource;\n    protected TransactionIsolationLevel level;\n    protected boolean autoCommit;\n\n    public JdbcTransaction(DataSource ds, TransactionIsolationLevel desiredLevel, boolean desiredAutoCommit) &#123;\n      \t&#x2F;&#x2F;数据源\n        this.dataSource &#x3D; ds;\n      \t&#x2F;&#x2F;事务隔离级别，上面已经提到过了\n        this.level &#x3D; desiredLevel;\n      \t&#x2F;&#x2F;是否自动提交\n        this.autoCommit &#x3D; desiredAutoCommit;\n    &#125;\n  \t\n  &#x2F;&#x2F;也可以直接给个Connection对象\n   public JdbcTransaction(Connection connection) &#123;\n        this.connection &#x3D; connection;\n    &#125;\n\n    public Connection getConnection() throws SQLException &#123;\n      \t&#x2F;&#x2F;没有就通过数据源新开一个Connection\n        if (this.connection &#x3D;&#x3D; null) &#123;\n            this.openConnection();\n        &#125;\n\t\n        return this.connection;\n    &#125;\n\n    public void commit() throws SQLException &#123;\n      \t&#x2F;&#x2F;连接已经创建并且没开启自动提交才可以使用\n        if (this.connection !&#x3D; null &amp;&amp; !this.connection.getAutoCommit()) &#123;\n            if (log.isDebugEnabled()) &#123;\n                log.debug(&quot;Committing JDBC Connection [&quot; + this.connection + &quot;]&quot;);\n            &#125;\n\t\t\t\t\t\t&#x2F;&#x2F;实际上使用的是数据库驱动提供的Connection对象进行事务操作\n            this.connection.commit();\n        &#125;\n\n    &#125;\n\n相当于JdbcTransaction只是为数据库驱动提供的Connection对象套了层壳，所有的事务操作实际上是直接调用Connection对象。\n那么我们接着来看ManagedTransaction的源码：\npublic class ManagedTransaction implements Transaction &#123;\n    ...\n\n    public void commit() throws SQLException &#123;\n    &#125;\n\n    public void rollback() throws SQLException &#123;\n    &#125;\n\n    ...\n&#125;\n\n我们发现，大体内容和JdbcTransaction差不多，但是它并没有实现任何的事务操作。也就是说，它希望将实现交给其他的管理框架来完成，而Spring就为Mybatis提供了一个非常好的事务管理实现。\n使用Spring事务管理现在我们来学习一下Spring提供的事务管理（Spring事务管理分为编程式事务和声明式事务，但是编程式事务过于复杂并且具有高度耦合性，违背了Spring框架的设计初衷，因此这里只讲解声明式事务）声明式事务是基于AOP实现的。\n使用声明式事务非常简单，我们只需要在配置类添加@EnableTransactionManagement注解即可，这样就可以开启Spring的事务支持了。接着，我们只需要把一个事务要做的所有事情封装到Service层的一个方法中即可，首先需要在配置文件中注册一个新的Bean，事务需要执行必须有一个事务管理器：\n@Bean\npublic TransactionManager transactionManager(@Autowired DataSource dataSource)&#123;\n    return new DataSourceTransactionManager(dataSource);\n&#125;\n\n接着编写Mapper操作：\n@Mapper\npublic interface TestMapper &#123;\n\n    @Insert(&quot;insert into student(name, sex) values(&#39;测试&#39;, &#39;男&#39;)&quot;)\n    void insertStudent();\n&#125;\n\n这样会向数据库中插入一条新的学生信息，接着，假设我们这里有一个业务需要连续插入两条学生信息，首先编写业务层的接口：\npublic interface TestService &#123;\n\n    void test();\n&#125;\n\n接着，我们再来编写业务层的实现，我们可以直接将其注册为Bean，交给Spring来进行管理，这样就可以自动将Mapper注入到类中了，并且可以支持事务：\n@Component\npublic class TestServiceImpl implements TestService&#123;\n\n    @Resource\n    TestMapper mapper;\n\n    @Transactional\n    @Override\n    public void test() &#123;\n        mapper.insertStudent();\n        if(true) throw new RuntimeException(&quot;我是测试异常！&quot;);\n        mapper.insertStudent();\n    &#125;\n&#125;\n\n我们只需在方法上添加@Transactional注解，即可表示此方法执行的是一个事务操作，在调用此方法时，Spring会通过AOP机制为其进行增强，一旦发现异常，事务会自动回滚。最后我们来调用一下此方法：\n@Slf4j\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        log.info(&quot;项目正在启动...&quot;);\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n        TestService service &#x3D; context.getBean(TestService.class);\n        service.test();\n    &#125;\n&#125;\n\n得到的结果是出现错误：\n十二月 08, 2021 3:09:29 下午 com.test.Main main\n信息: 项目正在启动...\n十二月 08, 2021 3:09:29 下午 com.zaxxer.hikari.HikariDataSource getConnection\n信息: HikariPool-1 - Starting...\n十二月 08, 2021 3:09:29 下午 com.zaxxer.hikari.HikariDataSource getConnection\n信息: HikariPool-1 - Start completed.\nException in thread &quot;main&quot; java.lang.RuntimeException: 我是测试异常！\n\tat com.test.service.TestServiceImpl.test(TestServiceImpl.java:22)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\n\tat com.sun.proxy.$Proxy30.test(Unknown Source)\n\tat com.test.Main.main(Main.java:17)\n\n我们发现，整个栈追踪信息中包含了大量aop包下的相关内容，也就印证了，它确实是通过AOP实现的，那么我们接着来看一下，数据库中的数据是否没有发生变化（出现异常回滚了）\n结果显而易见，确实被回滚了，数据库中没有任何的内容。\n我们接着来研究一下@Transactional注解的一些参数：\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Transactional &#123;\n    @AliasFor(&quot;transactionManager&quot;)\n    String value() default &quot;&quot;;\n\n    @AliasFor(&quot;value&quot;)\n    String transactionManager() default &quot;&quot;;\n\n    String[] label() default &#123;&#125;;\n\n    Propagation propagation() default Propagation.REQUIRED;\n\n    Isolation isolation() default Isolation.DEFAULT;\n\n    int timeout() default -1;\n\n    String timeoutString() default &quot;&quot;;\n\n    boolean readOnly() default false;\n\n    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;\n\n    String[] rollbackForClassName() default &#123;&#125;;\n\n    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;\n\n    String[] noRollbackForClassName() default &#123;&#125;;\n&#125;\n\n我们来讲解几个比较关键的信息：\n\ntransactionManager：指定事务管理器\npropagation：事务传播规则，一个事务可以包括N个子事务\nisolation：事务隔离级别，不多说了\ntimeout：事务超时时间\nreadOnly：是否为只读事务，不同的数据库会根据只读属性进行优化，比如MySQL一旦声明事务为只读，那么久不允许增删改操作了。\nrollbackFor和noRollbackFor：发生指定异常时回滚或是不回滚，默认发生任何异常都回滚\n\n除了事务的传播规则，其他的内容其实已经给大家讲解过了，那么我们就来看看事务的传播。事务传播一共有七种级别：\n\nSpring默认的传播级别是PROPAGATION_REQUIRED，那么我们来看看，它是如何传播的，现在我们的Service类中一共存在两个事务，而一个事务方法包含了另一个事务方法：\n@Transactional\npublic void test() &#123;\n    test2();\n    if(true) throw new RuntimeException(&quot;我是测试异常！&quot;);  &#x2F;&#x2F;发生异常时，会回滚另一个事务吗？\n&#125;\n\n@Transactional\npublic void test2() &#123;\n    mapper.insertStudent();\n&#125;\n\n最后我们得到结果，另一个事务被回滚了，也就是说，相当于另一个事务直接加入到此事务中了，也就是表中所描述的那样。\n如果单独执行test2()则会开启一个新的事务，而执行test()则会直接让内部的test2()加入到当前事务中。\n@Transactional\npublic void test() &#123;\n    test2();\n&#125;\n\n@Transactional(propagation &#x3D; Propagation.SUPPORTS)\npublic void test2() &#123;\n    mapper.insertStudent();\n   \tif(true) throw new RuntimeException(&quot;我是测试异常！&quot;);\n&#125;\n\n现在我们将test2()的传播级别设定为SUPPORTS，那么这时如果单独调用test2()方法，并不会以事务的方式执行，当发生异常时，虽然依然存在AOP增强，但是不会进行回滚操作，而现在再调用test()方法，才会以事务的方式执行。\n我们接着来看MANDATORY，它非常严格，如果当前方法并没有在任何事务中进行，会直接出现异常：\n@Transactional\npublic void test() &#123;\n    test2();\n&#125;\n\n@Transactional(propagation &#x3D; Propagation.MANDATORY)\npublic void test2() &#123;\n    mapper.insertStudent();\n    if(true) throw new RuntimeException(&quot;我是测试异常！&quot;);\n&#125;\n\n直接运行test2()方法，报错如下：\nException in thread &quot;main&quot; org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;\n\tat org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:362)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\n\tat com.sun.proxy.$Proxy29.test2(Unknown Source)\n\tat com.test.Main.main(Main.java:17)\n\nNESTED级别表示如果存在外层事务，则此方法单独创建一个子事务，回滚只会影响到此子事务，实际上就是利用创建Savepoint，然后回滚到此保存点实现的。NEVER级别表示此方法不应该加入到任何事务中，其余类型适用于同时操作多数据源情况下的分布式事务管理，这里暂时不做介绍。\n至此，有关Spring的核心内容就讲解完毕了。\n\n集成JUnit测试既然使用了Spring，那么怎么集成到JUnit中进行测试呢，首先大家能够想到的肯定是：\npublic class TestMain &#123;\n\n    @Test\n    public void test()&#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n        TestService service &#x3D; context.getBean(TestService.class);\n        service.test();\n    &#125;\n&#125;\n\n直接编写一个测试用例即可，但是这样的话，如果我们有很多个测试用例，那么我们不可能每次测试都去创建ApplicationContext吧？我们可以使用@Before添加一个测试前动作来提前配置ApplicationContext，但是这样的话，还是不够简便，能不能有更快速高效的方法呢？\nSpring为我们提供了一个Test模块，它会自动集成Junit进行测试，我们可以导入一下依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;junit-jupiter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.8.1&lt;&#x2F;version&gt;\n    &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.3.12&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n这里导入的是JUnit5和SpringTest模块依赖，然后直接在我们的测试类上添加两个注解就可以搞定：\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes &#x3D; TestConfiguration.class)\npublic class TestMain &#123;\n\n    @Autowired\n    TestService service;\n    \n    @Test\n    public void test()&#123;\n        service.test();\n    &#125;\n&#125;\n\n@ExtendWith是由JUnit提供的注解，等同于旧版本的@RunWith注解，然后使用SpringTest模块提供的@ContextConfiguration注解来表示要加载哪一个配置文件，可以是XML文件也可以是类，我们这里就直接使用类进行加载。\n配置完成后，我们可以直接使用@Autowired来进行依赖注入，并且直接在测试方法中使用注入的Bean，现在就非常方便了。\n\n探究Spring原理注意：本版块难度很大，作为选学内容。\n如果学习Spring基本内容对你来说已经非常困难了，建议跳过此小节，直接进入MVC阶段的学习，此小节会从源码角度解释Spring的整个运行原理，对初学者来说等同于小学跨越到高中，它并不是必学内容，但是对于个人开发能力的提升极为重要（推荐完成整个SSM阶段的学习并且加以实战之后再来看此部分），如果你还是觉得自己能够跟上节奏继续深入钻研底层原理，那么现在就开始吧。\n探究IoC原理首先我们大致了解一下ApplicationContext的加载流程：\n\n我们可以看到，整个过程极为复杂，一句话肯定是无法解释的，所以我们就从ApplicationContext说起吧。\n由于Spring的源码极为复杂，因此我们不可能再像了解其他框架那样直接自底向上逐行干源码了（可以自己点开看看，代码量非常之多），我们可以先从一些最基本的接口定义开始讲起，自顶向下逐步瓦解，那么我们来看看ApplicationContext最顶层接口是什么，一直往上，我们会发现有一个AbstractApplicationContext类，我们直接右键生成一个UML类图查看：\n![image-20211209202503121](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211209202503121.png)\n我们发现最顶层实际上是一个BeanFactory接口，那么我们就从这个接口开始研究起。\n我们可以看到此接口中定义了很多的行为：\npublic interface BeanFactory &#123;\n    String FACTORY_BEAN_PREFIX &#x3D; &quot;&amp;&quot;;\n\n    Object getBean(String var1) throws BeansException;\n\n    &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException;\n\n    Object getBean(String var1, Object... var2) throws BeansException;\n\n    &lt;T&gt; T getBean(Class&lt;T&gt; var1) throws BeansException;\n\n    &lt;T&gt; T getBean(Class&lt;T&gt; var1, Object... var2) throws BeansException;\n\n    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; var1);\n\n    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType var1);\n\n    boolean containsBean(String var1);\n\n    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;\n\n    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;\n\n    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;\n\n    boolean isTypeMatch(String var1, Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException;\n\n    @Nullable\n    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;\n\n    @Nullable\n    Class&lt;?&gt; getType(String var1, boolean var2) throws NoSuchBeanDefinitionException;\n\n    String[] getAliases(String var1);\n&#125;\n\n我们发现，其中最眼熟的就是getBean()方法了，此方法被重载了很多次，可以接受多种参数，因此，我们可以断定，一个IoC容器最基本的行为在此接口中已经被定义好了，也就是说，所有的BeanFactory实现类都应该具备容器管理Bean的基本能力，就像它的名字一样，它就是一个Bean工厂，工厂就是用来生产Bean实例对象的。\n我们可以直接找到此接口的一个抽象实现AbstractBeanFactory类，它实现了getBean()方法：\npublic Object getBean(String name) throws BeansException &#123;\n    return this.doGetBean(name, (Class)null, (Object[])null, false);\n&#125;\n\n那么我们doGetBean()接着来看方法里面干了什么：\nprotected &lt;T&gt; T doGetBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123;\n    String beanName &#x3D; this.transformedBeanName(name);\n    Object sharedInstance &#x3D; this.getSingleton(beanName);\n    Object beanInstance;\n    if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;\n      ...\n\n因为所有的Bean默认都是单例模式，对象只会存在一个，因此它会先调用父类的getSingleton()方法来直接获取单例对象，如果有的话，就可以直接拿到Bean的实例。如果没有会进入else代码块，我们接着来看，首先会进行一个判断：\nif (this.isPrototypeCurrentlyInCreation(beanName)) &#123;\n    throw new BeanCurrentlyInCreationException(beanName);\n&#125;\n\n这是为了解决循环依赖进行的处理，比如A和B都是以原型模式进行创建，而A中需要注入B，B中需要注入A，这时就会出现A还未创建完成，就需要B，而B这时也没创建完成，因为B需要A，而A等着B，这样就只能无限循环下去了，所以就出现了循环依赖的问题（同理，一个对象，多个对象也会出现这种情况）但是在单例模式下，由于每个Bean只会创建一个实例，Spring完全有机会处理好循环依赖的问题，只需要一个正确的赋值操作实现循环即可。那么单例模式下是如何解决循环依赖问题的呢？\n\n我们回到getSingleton()方法中，单例模式是可以自动解决循环依赖问题的：\n@Nullable\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;\n    Object singletonObject &#x3D; this.singletonObjects.get(beanName);\n  \t&#x2F;&#x2F;先从第一层列表中拿Bean实例，拿到直接返回\n    if (singletonObject &#x3D;&#x3D; null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123;\n      \t&#x2F;&#x2F;第一层拿不到，并且已经认定为处于循环状态，看看第二层有没有\n        singletonObject &#x3D; this.earlySingletonObjects.get(beanName);\n        if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;\n            synchronized(this.singletonObjects) &#123;\n              \t&#x2F;&#x2F;加锁再执行一次上述流程\n                singletonObject &#x3D; this.singletonObjects.get(beanName);\n                if (singletonObject &#x3D;&#x3D; null) &#123;\n                    singletonObject &#x3D; this.earlySingletonObjects.get(beanName);\n                    if (singletonObject &#x3D;&#x3D; null) &#123;\n                      \t&#x2F;&#x2F;仍然没有获取到实例，只能从singletonFactory中获取了\n                        ObjectFactory&lt;?&gt; singletonFactory &#x3D; (ObjectFactory)this.singletonFactories.get(beanName);\n                        if (singletonFactory !&#x3D; null) &#123;\n                            singletonObject &#x3D; singletonFactory.getObject();\n                          \t&#x2F;&#x2F;丢进earlySingletonObjects中，下次就可以直接在第二层拿到了\n                            this.earlySingletonObjects.put(beanName, singletonObject);\n                            this.singletonFactories.remove(beanName);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return singletonObject;\n&#125;\n\n看起来很复杂，实际上它使用了三层列表的方式来处理循环依赖的问题。包括：\n\nsingletonObjects\nearlySingletonObjects\nsingletonFactories\n\n当第一层拿不到时，会接着判断这个Bean是否处于创建状态isSingletonCurrentlyInCreation()，它会从一个Set集合中查询，这个集合中存储了已经创建但还未注入属性的实例对象，也就是说处于正在创建状态，如果说发现此Bean处于正在创建状态（一定是因为某个Bean需要注入这个Bean的实例），就可以断定它应该是出现了循环依赖的情况。\nearlySingletonObjects相当于是专门处理循环依赖的表，一般包含singletonObjects中的全部实例，如果这个里面还是没有，接着往下走，这时会从singletonFactories中获取（所有的Bean初始化完成之后都会被丢进singletonFactories，也就是只创建了，但是还没进行依赖注入的时候）在获取到后，向earlySingletonObjects中丢入此Bean的实例，并将实例从singletonFactories中移除。\n我们最后再来梳理一下流程，还是用我们刚才的例子，A依赖于B，B依赖于A：\n\n假如A先载入，那么A首先进入了singletonFactories中，注意这时还没进行依赖注入，A中的B还是null\nsingletonFactories：A\nearlySingletonObjects：\nsingletonObjects：\n\n\n接着肯定是注入A的依赖B了，但是B还没初始化，因此现在先把B给载入了，B构造完成后也进了singletonFactories\nsingletonFactories：A，B\nearlySingletonObjects：\nsingletonObjects：\n\n\n开始为B注入依赖，发现B依赖于A，这时又得去获取A的实例，根据上面的分析，这时候A还在singletonFactories中，那么它会被丢进earlySingletonObjects，然后从singletonFactories中移除，然后返回A的实例（注意此时A中的B依赖还是null）\nsingletonFactories：B\nearlySingletonObjects：A\nsingletonObjects：\n\n\n这时B已经完成依赖注入了，因此可以直接丢进singletonObjects中\nsingletonFactories：\nearlySingletonObjects：A\nsingletonObjects：B\n\n\n然后再将B注入到A中，完成A的依赖注入，A也被丢进singletonObjects中，至此循环依赖完成，A和B完成实例创建\nsingletonFactories：\nearlySingletonObjects：\nsingletonObjects：A，B\n\n\n\n经过整体过程梳理，关于Spring如何解决单例模式的循环依赖理解起来就非常简单了。\n现在让我们回到之前的地方，原型模式下如果出现循环依赖会直接抛出异常，如果不存在会接着向下：\n&#x2F;&#x2F;BeanFactory存在父子关系\nBeanFactory parentBeanFactory &#x3D; this.getParentBeanFactory();\n&#x2F;&#x2F;如果存在父BeanFactory，同时当前BeanFactory没有这个Bean的定义\nif (parentBeanFactory !&#x3D; null &amp;&amp; !this.containsBeanDefinition(beanName)) &#123;\n  \t&#x2F;&#x2F;这里是因为Bean可能有别名，找最原始的那个名称\n    String nameToLookup &#x3D; this.originalBeanName(name);\n    if (parentBeanFactory instanceof AbstractBeanFactory) &#123;\n      \t&#x2F;&#x2F;向父BeanFactory递归查找\n        return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);\n    &#125;\n\n    if (args !&#x3D; null) &#123;\n      \t&#x2F;&#x2F;根据参数查找\n        return parentBeanFactory.getBean(nameToLookup, args);\n    &#125;\n\n    if (requiredType !&#x3D; null) &#123;\n      \t&#x2F;&#x2F;根据类型查找\n        return parentBeanFactory.getBean(nameToLookup, requiredType);\n    &#125;\n\n  \t&#x2F;&#x2F;各种找\n    return parentBeanFactory.getBean(nameToLookup);\n&#125;\n\n也就是说，BeanFactory会先看当前是否存在Bean的定义，如果没有会直接用父BeanFactory各种找。这里出现了一个新的接口BeanDefinition，既然工厂需要生产商品，那么肯定需要拿到商品的原材料以及制作配方，我们的Bean也是这样，Bean工厂需要拿到Bean的信息才可以去生成这个Bean的实例对象，而BeanDefinition就是用于存放Bean的信息的，所有的Bean信息正是从XML配置文件读取或是注解扫描后得到的。\n我们接着来看，如果此BeanFactory不存在父BeanFactory或是包含了Bean的定义，那么会接着往下走，这时只能自己创建Bean了，首先会拿到一个RootBeanDefinition对象：\ntry &#123;\n    if (requiredType !&#x3D; null) &#123;\n        beanCreation.tag(&quot;beanType&quot;, requiredType::toString);\n    &#125;\n\n    RootBeanDefinition mbd &#x3D; this.getMergedLocalBeanDefinition(beanName);\n\n下面的内容就非常复杂了，但是我们可以知道，它一定是根据对应的类型（单例、原型）进行了对应的处理，最后自行创建一个新的对象返回。一个Bean的加载流程为：\n首先拿到BeanDefinition定义，选择对应的构造方法，通过反射进行实例化，然后进行属性填充（依赖注入），完成之后再调用初始化方法（init-method），最后如果存在AOP，则会生成一个代理对象，最后返回的才是我们真正得到的Bean对象。\n最后让我们回到ApplicationContext中，实际上，它就是一个强化版的BeanFactory，在最基本的Bean管理基础上，还添加了：\n\n国际化（MessageSource）\n访问资源，如URL和文件（ResourceLoader）\n载入多个（有继承关系）上下文 \n消息发送、响应机制（ApplicationEventPublisher）\nAOP机制\n\n我们发现，无论是还是的构造方法中都会调用refresh()方法来刷新应用程序上下文：\npublic AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) &#123;\n    this();\n    this.register(componentClasses);\n    this.refresh();\n&#125;\n\n此方法在讲解完AOP原理之后，再进行讲解。综上，有关IoC容器的大部分原理就讲解完毕了。\n探究AOP原理前面我们提到了PostProcessor，它其实是Spring提供的一种后置处理机制，它可以让我们能够插手Bean、BeanFactory、BeanDefinition的创建过程，相当于进行一个最终的处理，而最后得到的结果（比如Bean实例、Bean定义等）就是经过后置处理器返回的结果，它是整个加载过程的最后一步。\n而AOP机制正是通过它来实现的，我们首先来认识一下第一个接口BeanPostProcessor，它相当于Bean初始化的一个后置动作，我们可以直接实现此接口：\n&#x2F;&#x2F;注意它后置处理器也要进行注册\n@Component\npublic class TestBeanProcessor implements BeanPostProcessor &#123;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(beanName);  &#x2F;&#x2F;打印bean的名称\n        return bean;\n    &#125;\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n    &#125;\n&#125;\n\n我们发现，此接口中包括两个方法，一个是postProcessAfterInitialization用于在Bean初始化之后进行处理，还有一个postProcessBeforeInitialization用于在Bean初始化之前进行处理，注意这里的初始化不是创建对象，而是调用类的初始化方法，比如：\n@Component\npublic class TestBeanProcessor implements BeanPostProcessor &#123;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;我是之后：&quot;+beanName);\n        return bean;   &#x2F;&#x2F;这里返回的Bean相当于最终的结果了，我们依然能够插手修改，这里返回之后是什么就是什么了\n    &#125;\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;我是之前：&quot;+beanName);\n        return bean;   &#x2F;&#x2F;这里返回的Bean会交给下一个阶段，也就是初始化方法\n    &#125;\n&#125;\n\n@Component\npublic class TestServiceImpl implements TestService&#123;\n\n    public TestServiceImpl()&#123;\n        System.out.println(&quot;我是构造方法&quot;);\n    &#125;\n\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(&quot;我是初始化方法&quot;);\n    &#125;\n\n    TestMapper mapper;\n\n    @Autowired\n    public void setMapper(TestMapper mapper) &#123;\n        System.out.println(&quot;我是依赖注入&quot;);\n        this.mapper &#x3D; mapper;\n    &#125;\n  \t\n  \t...\n\n而TestServiceImpl的加载顺序为：\n我是构造方法\n我是依赖注入\n我是之前：testServiceImpl\n我是初始化方法\n我是之后：testServiceImpl\n\n现在我们再来总结一下一个Bean的加载流程：\n[Bean定义]首先扫描Bean，加载Bean定义 -&gt; [依赖注入]根据Bean定义通过反射创建Bean实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化Bean]BeanPostProcessor的初始化之前方法 -&gt; [初始化Bean]Bean初始化方法 -&gt; [初始化Bean]BeanPostProcessor的初始化之前后方法 -&gt; [完成]最终得到的Bean加载完成的实例\n利用这种机制，理解Aop的实现过程就非常简单了，AOP实际上也是通过这种机制实现的，它的实现类是AnnotationAwareAspectJAutoProxyCreator，而它就是在最后对Bean进行了代理，因此最后我们得到的结果实际上就是一个动态代理的对象（有关详细实现过程，这里就不进行列举了，感兴趣的可以继续深入）\n那么肯定有人有疑问了，这个类没有被注册啊，那按理说它不应该参与到Bean的初始化流程中的，为什么它直接就被加载了呢？\n还记得@EnableAspectJAutoProxy吗？我们来看看它是如何定义就知道了：\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)\npublic @interface EnableAspectJAutoProxy &#123;\n    boolean proxyTargetClass() default false;\n\n    boolean exposeProxy() default false;\n&#125;\n\n我们发现它使用了@Import来注册AspectJAutoProxyRegistrar，那么这个类又是什么呢，我们接着来看：\nclass AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;\n    AspectJAutoProxyRegistrar() &#123;\n    &#125;\n\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;\n      \t&#x2F;&#x2F;注册AnnotationAwareAspectJAutoProxyCreator到容器中\n        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);\n        AnnotationAttributes enableAspectJAutoProxy &#x3D; AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);\n        if (enableAspectJAutoProxy !&#x3D; null) &#123;\n            if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;\n                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n            &#125;\n\n            if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;\n                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n它实现了接口，这个接口也是Spring提供的一种Bean加载机制，它支持直接向容器中添加Bean定义，容器也会加载这个Bean：\n\nImportBeanDefinitionRegistrar类只能通过其他类@Import的方式来加载，通常是启动类或配置类。\n使用@Import，如果括号中的类是ImportBeanDefinitionRegistrar的实现类，则会调用接口中方法（一般用于注册Bean）\n实现该接口的类拥有注册bean的能力。\n\n我们可以看到此接口提供了一个BeanDefinitionRegistry正是用于注册Bean的定义的。\n因此，当我们打上了@EnableAspectJAutoProxy注解之后，首先会通过@Import加载AspectJAutoProxyRegistrar，然后调用其registerBeanDefinitions方法，然后使用工具类注册AnnotationAwareAspectJAutoProxyCreator到容器中，这样在每个Bean创建之后，如果需要使用AOP，那么就会通过AOP的后置处理器进行处理，最后返回一个代理对象。\n我们也可以尝试编写一个自己的ImportBeanDefinitionRegistrar实现，首先编写一个测试Bean：\npublic class TestBean &#123;\n    \n    @PostConstruct\n    void init()&#123;\n        System.out.println(&quot;我被初始化了！&quot;);\n    &#125;\n&#125;\n\npublic class TestBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;\n        BeanDefinition definition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(Student.class).getBeanDefinition();\n        registry.registerBeanDefinition(&quot;lbwnb&quot;, definition);\n    &#125;\n&#125;\n\n观察控制台输出，成功加载Bean实例。\n与BeanPostProcessor差不多的还有BeanFactoryPostProcessor，它和前者一样，也是用于我们自己处理后置动作的，不过这里是用于处理BeanFactory加载的后置动作，BeanDefinitionRegistryPostProcessor直接继承自BeanFactoryPostProcessor，并且还添加了新的动作postProcessBeanDefinitionRegistry，你可以在这里动态添加Bean定义或是修改已经存在的Bean定义，这里我们就直接演示BeanDefinitionRegistryPostProcessor的实现：\n@Component\npublic class TestDefinitionProcessor implements BeanDefinitionRegistryPostProcessor &#123;\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;\n        System.out.println(&quot;我是Bean定义后置处理！&quot;);\n        BeanDefinition definition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(TestBean.class).getBeanDefinition();\n        registry.registerBeanDefinition(&quot;lbwnb&quot;, definition);\n    &#125;\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123;\n        System.out.println(&quot;我是Bean工厂后置处理！&quot;);\n    &#125;\n&#125;\n\n在这里注册Bean定义其实和之前那种方法效果一样。\n最后，我们再完善一下Bean加载流程（加粗部分是新增的）：\n[Bean定义]首先扫描Bean，加载Bean定义 -&gt; [Bean定义]Bean定义和Bean工厂后置处理 -&gt; [依赖注入]根据Bean定义通过反射创建Bean实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化Bean]BeanPostProcessor的初始化之前方法 -&gt; [初始化Bean]Bean初始化方法 -&gt; [初始化Bean]BeanPostProcessor的初始化之前后方法 -&gt; [完成]最终得到的Bean加载完成的实例\n最后我们再来研究一下ApplicationContext中的refresh()方法：\npublic void refresh() throws BeansException, IllegalStateException &#123;\n    synchronized(this.startupShutdownMonitor) &#123;\n        StartupStep contextRefresh &#x3D; this.applicationStartup.start(&quot;spring.context.refresh&quot;);\n        this.prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory &#x3D; this.obtainFreshBeanFactory();\n      \t&#x2F;&#x2F;初始化Bean工厂\n        this.prepareBeanFactory(beanFactory);\n\n        try &#123;\n            this.postProcessBeanFactory(beanFactory);\n            StartupStep beanPostProcess &#x3D; this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);\n          \t&#x2F;&#x2F;调用所有的Bean工厂、Bean注册后置处理器\n            this.invokeBeanFactoryPostProcessors(beanFactory);\n          \t&#x2F;&#x2F;注册Bean后置处理器（包括Spring内部的）\n            this.registerBeanPostProcessors(beanFactory);\n            beanPostProcess.end();\n          \t&#x2F;&#x2F;国际化支持\n            this.initMessageSource();\n          \t&#x2F;&#x2F;监听和事件广播\n            this.initApplicationEventMulticaster();\n            this.onRefresh();\n            this.registerListeners();\n          \t&#x2F;&#x2F;实例化所有的Bean\n            this.finishBeanFactoryInitialization(beanFactory);\n            this.finishRefresh();\n        &#125; catch (BeansException var10) &#123;\n            if (this.logger.isWarnEnabled()) &#123;\n                this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var10);\n            &#125;\n\n            this.destroyBeans();\n            this.cancelRefresh(var10);\n            throw var10;\n        &#125; finally &#123;\n            this.resetCommonCaches();\n            contextRefresh.end();\n        &#125;\n\n    &#125;\n&#125;\n\n我们可以给这些部分分别打上断点来观察一下此方法的整体加载流程。\nMybatis整合原理通过之前的了解，我们再来看Mybatis的@MapperScan是如何实现的，现在理解起来就非常简单了。\n我们可以直接打开查看：\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123;ElementType.TYPE&#125;)\n@Documented\n@Import(&#123;MapperScannerRegistrar.class&#125;)\n@Repeatable(MapperScans.class)\npublic @interface MapperScan &#123;\n    String[] value() default &#123;&#125;;\n\n    String[] basePackages() default &#123;&#125;;\n  \t...\n\n我们发现，和Aop一样，它也是通过Registrar机制，通过@Import来进行Bean的注册，我们来看看MapperScannerRegistrar是个什么东西，关键代码如下：\nvoid registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) &#123;\n    BeanDefinitionBuilder builder &#x3D; BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);\n    builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);\n    Class&lt;? extends Annotation&gt; annotationClass &#x3D; annoAttrs.getClass(&quot;annotationClass&quot;);\n    if (!Annotation.class.equals(annotationClass)) &#123;\n        builder.addPropertyValue(&quot;annotationClass&quot;, annotationClass);\n    &#125;\n\n    Class&lt;?&gt; markerInterface &#x3D; annoAttrs.getClass(&quot;markerInterface&quot;);\n    if (!Class.class.equals(markerInterface)) &#123;\n        builder.addPropertyValue(&quot;markerInterface&quot;, markerInterface);\n    &#125;\n\n    Class&lt;? extends BeanNameGenerator&gt; generatorClass &#x3D; annoAttrs.getClass(&quot;nameGenerator&quot;);\n    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;\n        builder.addPropertyValue(&quot;nameGenerator&quot;, BeanUtils.instantiateClass(generatorClass));\n    &#125;\n\n    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass &#x3D; annoAttrs.getClass(&quot;factoryBean&quot;);\n    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;\n        builder.addPropertyValue(&quot;mapperFactoryBeanClass&quot;, mapperFactoryBeanClass);\n    &#125;\n\n    String sqlSessionTemplateRef &#x3D; annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;);\n    if (StringUtils.hasText(sqlSessionTemplateRef)) &#123;\n        builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));\n    &#125;\n\n    String sqlSessionFactoryRef &#x3D; annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;);\n    if (StringUtils.hasText(sqlSessionFactoryRef)) &#123;\n        builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));\n    &#125;\n\n    List&lt;String&gt; basePackages &#x3D; new ArrayList();\n    basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));\n    basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));\n    basePackages.addAll((Collection)Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName).collect(Collectors.toList()));\n    if (basePackages.isEmpty()) &#123;\n        basePackages.add(getDefaultBasePackage(annoMeta));\n    &#125;\n\n    String lazyInitialization &#x3D; annoAttrs.getString(&quot;lazyInitialization&quot;);\n    if (StringUtils.hasText(lazyInitialization)) &#123;\n        builder.addPropertyValue(&quot;lazyInitialization&quot;, lazyInitialization);\n    &#125;\n\n    String defaultScope &#x3D; annoAttrs.getString(&quot;defaultScope&quot;);\n    if (!&quot;&quot;.equals(defaultScope)) &#123;\n        builder.addPropertyValue(&quot;defaultScope&quot;, defaultScope);\n    &#125;\n\n    builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));\n    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());\n&#125;\n\n虽然很长很多，但是这些代码都是在添加一些Bean定义的属性，而最关键的则是最上方的MapperScannerConfigurer，Mybatis将其Bean信息注册到了容器中，那么这个类又是干嘛的呢？\npublic class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123;\n    private String basePackage;\n\n它实现了BeanDefinitionRegistryPostProcessor，也就是说它为Bean信息加载提供了后置处理，我们接着来看看它在Bean信息后置处理中做了什么：\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;\n    if (this.processPropertyPlaceHolders) &#123;\n        this.processPropertyPlaceHolders();\n    &#125;\n\n  \t&#x2F;&#x2F;初始化类路径Mapper扫描器，它相当于是一个工具类，可以快速扫描出整个包下的类定义信息\n  \t&#x2F;&#x2F;ClassPathMapperScanner是Mybatis自己实现的一个扫描器，修改了一些扫描规则\n    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);\n    scanner.setAddToConfig(this.addToConfig);\n    scanner.setAnnotationClass(this.annotationClass);\n    scanner.setMarkerInterface(this.markerInterface);\n    scanner.setSqlSessionFactory(this.sqlSessionFactory);\n    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);\n    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);\n    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);\n    scanner.setResourceLoader(this.applicationContext);\n    scanner.setBeanNameGenerator(this.nameGenerator);\n    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);\n    if (StringUtils.hasText(this.lazyInitialization)) &#123;\n        scanner.setLazyInitialization(Boolean.valueOf(this.lazyInitialization));\n    &#125;\n\n    if (StringUtils.hasText(this.defaultScope)) &#123;\n        scanner.setDefaultScope(this.defaultScope);\n    &#125;\n\n  \t&#x2F;&#x2F;添加过滤器，这里会配置为所有的接口都能被扫描（因此即使你不添加@Mapper注解都能够被扫描并加载）\n    scanner.registerFilters();\n  \t&#x2F;&#x2F;开始扫描\n    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, &quot;,; \\t\\n&quot;));\n&#125;\n\n开始扫描后，会调用doScan()方法，我们接着来看（这是ClassPathMapperScanner中的扫描方法）：\npublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;\n    Set&lt;BeanDefinitionHolder&gt; beanDefinitions &#x3D; super.doScan(basePackages);\n  \t&#x2F;&#x2F;首先从包中扫描所有的Bean定义\n    if (beanDefinitions.isEmpty()) &#123;\n        LOGGER.warn(() -&gt; &#123;\n            return &quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;;\n        &#125;);\n    &#125; else &#123;\n      \t&#x2F;&#x2F;处理所有的Bean定义，实际上就是生成对应Mapper的代理对象，并注册到容器中\n        this.processBeanDefinitions(beanDefinitions);\n    &#125;\n\n  \t&#x2F;&#x2F;最后返回所有的Bean定义集合\n    return beanDefinitions;\n&#125;\n\n通过断点我们发现，最后处理得到的Bean定义发现此Bean是一个MapperFactoryBean，它不同于普通的Bean，FactoryBean相当于为普通的Bean添加了一层外壳，它并不是依靠Spring直接通过反射创建，而是使用接口中的方法：\npublic interface FactoryBean&lt;T&gt; &#123;\n    String OBJECT_TYPE_ATTRIBUTE &#x3D; &quot;factoryBeanObjectType&quot;;\n\n    @Nullable\n    T getObject() throws Exception;\n\n    @Nullable\n    Class&lt;?&gt; getObjectType();\n\n    default boolean isSingleton() &#123;\n        return true;\n    &#125;\n&#125;\n\n通过getObject()方法，就可以获取到Bean的实例了。\n注意这里一定要区分FactoryBean和BeanFactory的概念：\n\nBeanFactory是个Factory，也就是 IOC 容器或对象工厂，所有的 Bean 都是由 BeanFactory( 也就是 IOC 容器 ) 来进行管理。\nFactoryBean是一个能生产或者修饰生成对象的工厂Bean(本质上也是一个Bean)，可以在BeanFactory（IOC容器）中被管理，所以它并不是一个简单的Bean。当使用容器中factory bean的时候，该容器不会返回factory bean本身，而是返回其生成的对象。要想获取FactoryBean的实现类本身，得在getBean(String BeanName)中的BeanName之前加上&amp;,写成getBean(String &amp;BeanName)。\n\n我们也可以自己编写一个实现：\n@Component(&quot;test&quot;)\npublic class TestFb implements FactoryBean&lt;Student&gt; &#123;\n    @Override\n    public Student getObject() throws Exception &#123;\n        System.out.println(&quot;获取了学生&quot;);\n        return new Student();\n    &#125;\n\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return Student.class;\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    log.info(&quot;项目正在启动...&quot;);\n    ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(TestConfiguration.class);\n    System.out.println(context.getBean(&quot;&amp;test&quot;));   &#x2F;&#x2F;得到FactoryBean本身（得加个&amp;搞得像C语言指针一样）\n    System.out.println(context.getBean(&quot;test&quot;));   &#x2F;&#x2F;得到FactoryBean调用getObject()之后的结果\n&#125;\n\n因此，实际上我们的Mapper最终就以FactoryBean的形式，被注册到容器中进行加载了：\npublic T getObject() throws Exception &#123;\n    return this.getSqlSession().getMapper(this.mapperInterface);\n&#125;\n\n这样，整个Mybatis的@MapperScan的原理就全部解释完毕了。\n在了解完了Spring的底层原理之后，我们其实已经完全可以根据这些实现原理来手写一个Spring框架了。\n","slug":"JavaSSM笔记（一）","date":"2022-03-05T16:22:39.785Z","categories_index":"JavaSSM笔记","tags_index":"JavaSSM笔记","author_index":"YangChao"},{"id":"7e4642983a7bb3ca2238a4f0bb6ed9d8","title":"SpringBoot笔记（五）","content":"\nLinux操作系统与项目部署注意：本版块会涉及到操作系统相关知识。\n现在，几乎所有智能设备都有一个自己的操作系统，比如我们的家用个人电脑，基本都是预装Windows操作系统，我们的手机也有Android和iOS操作系统，还有程序员比较青睐的MacBook，预装MacOS操作系统，甚至连Macbook的Touchbar都有一个自己的小型操作系统。\n\n\n\n\n\n\n\n\n\n操作系统是管理计算机硬件与软件资源的计算机程序，操作系统可以对计算机系统的各项资源板块开展调度工作，运用计算机操作系统可以减少人工资源分配的工作强度。\n在我们的电脑没有操作系统的情况下，它就是一堆电子元器件组合而成的机器，就像我们有了一具完整的身体，但是现在缺少的是一个大脑，来控制我们的身体做出各种动作和行为，而安装了操作系统，就像为电脑注入了灵魂，操作系统会帮助我们对所有的硬件进行调度和管理。\n比如我们现在最常用的Windows操作系统，我们可以在系统中做各种各样的事情，包括游戏、看片、学习、编程等，而所有的程序正是基于操作系统之上运行的，操作系统帮助我们与底层硬件进行交互，而在程序中我们只需要告诉操作系统我们需要做什么就可以了，操作系统知道该如何使用和调度底层的硬件，来完成我们程序中指定的任务。\n（如果你在自己电脑上安装过Windows操作系统，甚至自己打过驱动程序，或是使用安装过Linux任意发行版本，那么本章学习起来会比较轻松）\n发展简史这是整个SpringBoot阶段的最后部分了，为了不让学习那么枯燥，我们先来讲点小故事。\n在1965年，当时还处于批处理操作系统的时代，但是它只能同时供一个用户使用，而当时人们正希望能够开发一种交互式的、具有多道程序处理能力的分时操作系统。于是，贝尔实验室、美国麻省理工学院和通用电气公司联合发起了一项名为 Multics 的工程计划，而目的也是希望能够开发出这样的一个操作系统，但是最终由于各种原因以失败告终。\n以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了分时操作系统的雏形，在1970 年该操作系统正式取名为UNIX，它是一个强大的多用户、多任务操作系统，支持多种处理器架构，1973 年，也就是C语言问世不久后，UNIX操作系统的绝大部分源代码都用C语言进行了重写。\n从这之后，大量的UNIX发行版本涌现（基于Unix进行完善的系统）比如 FreeBSD 就是美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。\n 而后来1984年苹果公司发布的的MacOS（在Macintosh电脑上搭载）操作系统，正是在 FreeBSD 基础之上开发的全新操作系统，这是首次计算机正式跨进图形化时代，具有里程碑的意义。\n\n同年，乔布斯非常高兴地将自家的图形化MacOS界面展示给微软创始人比尔盖茨，并且希望微软可以为MacOS开发一些软件。比尔盖茨一看，woc，这玩意牛逼啊，咱们自己也给安排一个。于是，在1985年，微软仿造MacOS并基于MS-DOS操作系统，开发出了名为Windows的操作系统：\n\nWindows操作系统的问世，无疑是对MacOS的一次打击，因为MacOS只能搭载在Mac上，但是售价实在太贵，并且软件生态也不尽人意，同时代的Windows却能够安装到各种各样的DIY电脑上，称其为PC，尤其是后来的Windows95，几乎是封神的存在，各种各样基于Windows的软件、游戏层出不穷，以至于到今天为止，MacOS的市场占有率依然远低于Windows，不过Apple这十几年一直在注重自家软件生态的发展，总体来说在办公领域体验感其实和Windows差不多，甚至可能还更好，但是打游戏，别想了。\n说了这么多，Linux呢，怎么一句都没提它呢？最牛逼的当然放最后说（不是\nUnix虽然强大但是有着昂贵的授权费用，并且不开放源代码，于是有人发起了GNU运动（GNU IS NOT UNIX，带有那么一丝嘲讽），模仿 Unix 的界面和使用方式，从头做一个开源的版本。在1987年荷兰有个大学教授安德鲁写了一个Minix，类似于Unix，专用于教学。当Minix流传开来之后，世界各地的黑客们纷纷开始使用并改进，希望把改进的东西合并到Minix中，但是安德鲁觉得他的系统是用于教学的，不能破坏纯净性，于是拒绝了。\n在1991年，林纳斯.托瓦兹（Linus Torvalds）认为Minix不够开放，自己又写了一个全新的开源操作系统，它希望这个系统由全世界的爱好者一同参与开发，并且不收费，于是Linux内核就被公开发布到互联网上。一经发布，便引起了社会强烈的反响，在大家的努力下，于1994年Linux的1.0版本正式发布。结合当时的GNU运动，最终合在一起称为了GNU&#x2F;Linux，以一只企鹅Tux作为吉祥物。\n\n没错，Git也是林纳斯.托瓦兹只花了2周时间开发的。不过林纳斯非常讨厌C++，他认为C++只会让一个项目变得混乱。\n从此以后，各式各样的基于Linux发行版就开始出现：\n\n这些发行版都是在Linux内核的基础之上，添加了大量的额外功能，包括开发环境、图形化桌面、包管理等。包括我们的安卓系统，也是基于Linux之上的，而我们要重点介绍的就是基于Debian之上的Ubuntu操作系统。\n最后，2022年了，我们再来看一下各大操作系统的市场占有率：\n\nWindows11&#x2F;10&#x2F;7：80%\nMacOS：11%\nLinux：5%\n其他：4%\n\nWindows无疑是现在最广泛的操作系统，尤其是Windows XP，是多少00后的青春，很多游戏都是基于Windows平台。当然，如果你已经厌倦了游戏，一心只读圣贤书的话，那么还是建议直接使用任意Linux桌面版或是Mac，因为它们能够为你提供极致和纯粹的开发体验（貌似之前华为也出过Linux笔记本？）\n\n\n安装Ubuntu系统这里我们就以安装虚拟机的方式在我们的电脑上安装Linux操作系统，我们选用Ubuntu作为教程，如果有经济实力，可以在腾讯云、阿里云之类的服务商购买一台云服务器，并选择预装Ubuntu系统；如果你还想搞嵌入式开发之类的工作，可以购买一台树莓派服务器，也可以在上面安装Ubuntu系统，相当于一台迷你主机。在你已经有云服务器的情况下，可以直接跳过虚拟机安装教学。\n官网下载：https://cn.ubuntu.com/download/server/step1\n注意是下载服务器版本，不是桌面版本。\n在虚拟机中安装这里我们使用VMware进行安装，VMware是一个虚拟化应用程序，它可以在我们当前运行的操作系统之上，创建一个虚线的主机，相当于创建了一台电脑，而我们就可以在这台电脑上安装各种各样的操作系统，并且我们可以自由为其分配CPU核心和内存以及硬盘容量（如果你接触过云计算相关内容，应该会对虚拟化技术有所了解）\n官网下载：https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html\n安装完成后，会出现一个类似于CMD的命令窗口，而我们就是通过输入命令来操作我们的操作系统。\n使用SSH远程连接如果你使用的是树莓派或是云服务器，那么你会得到一个公网的IP地址，以及默认的用户名和密码，由于服务器安装的Ubuntu并不是在我们的电脑上运行的，那么我们怎么去远程操作呢？\n比如我们要远程操作一台Windows电脑，直接使用远程桌面连接即可，但是Ubuntu上来就是命令行，这种情况下要实现远程连接就只能使用SSH终端。\nSSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。\n云服务器上安装的Ubuntu默认都是自带了OpenSSH服务端的，我们可以直接连接，如果你的Ubuntu服务器上没有安装OpenSSH服务器端，那么可以输入命令进行安装：\nsudo apt install openssh-server\n#输入后还需要你输入当前用户的密码才可以执行，至于为什么我们后面会说\n\n这里我们使用XShell来进行SSH登陆，官网：https://www.netsarang.com/zh/free-for-home-school/\n文件系统介绍在Windows下，我们的整个硬盘实际上可以被分为多个磁盘驱动器：\n\n我们一般习惯将软件装到D盘，文件数据存在E盘，系统和一些环境安装在C盘，根据不同的盘符进行划分，并且每个盘都有各自的存储容量大小。而在Linux中，没有这个概念，所有的文件都是位于根目录下的：\n\n我们可以看到根目录下有很多个文件夹，它们都有着各自的划分：\n\n&#x2F;bin 可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等实际上都是一些小的应用程序\n&#x2F;home 普通用户的主目录，对应Windows下的C:&#x2F;Users&#x2F;用户名&#x2F;\n&#x2F;root root用户的主目录（root用户是具有最高权限的用户，之后会讲）\n&#x2F;boot 内核文件的引导目录, 放置 linux 系统启动时用到的一些文件\n&#x2F;sbing 超级用户使用的指令文件\n&#x2F;tmp 临时文件目录，一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。\n&#x2F;dev 设备文件目录，在Linux中万物皆文件，实际上你插入的U盘等设备都会在dev目录下生成一个文件，我们可以很方便地通过文件IO方式去操作外设，对嵌入式开发极为友好。\n&#x2F;lib 共享库，系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。\n&#x2F;usr 第三方 程序目录\n&#x2F;etc 配置程序目录，系统配置文件存放的目录\n&#x2F;var 可变文件，放置系统执行过程中经常变化的文件\n&#x2F;opt 用户使用目录，给主机额外安装软件所摆放的目录。\n\n我们可以直接输入命令来查看目录下的所有文件：\n#只显示文件名称，且不显示隐藏文件\nls\n#显示隐藏文件以及文件详细信息\nll\n\n那么我们如何才能像Windows那样方便的管理Linux中的文件呢？我们可以使用FTP管理工具，默认情况下Ubuntu是安装了SFTP服务器的。\n这里我们使用Xftp来进行管理，官网：https://www.netsarang.com/zh/free-for-home-school/\n\n用户和用户组我们整个Linux阶段的学习主要是以实操为主，大量的命令需要大量的使用才能记得更牢固。\nLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统的用户，都必须申请一个账号，然后以这个账号的身份进入系统。比如我们之前就是使用我们在创建服务器时申请的初始用户test，通过输入用户名和密码登录到系统中，之后才能使用各种命令进行操作。其实用户机制和我们的Windows比较类似。一般的普通用户只能做一些比较基本的操作，并且只能在自己的目录（如&#x2F;home&#x2F;test）中进行文件的创建和删除操作。\n我们可以看到，当前状态信息分为三段：\ntest@ubuntu-server:~$\n\n格式为：用户名@服务器名称:当前所处的目录$，其中~代表用户目录，如果不是用户目录，会显示当前的绝对路径地址。我们也可以使用pwd命令来直接查看当前所处的目录。\n在Linux中默认存在一个超级用户root，而此用户拥有最高执行权限，它能够修改任何的内容，甚至可以删除整个Linux内核，正常情况下不会使用root用户进行登陆，只有在特殊情况下才会使用root用户来进行一些操作，root用户非常危险，哪怕一个小小的命令都能够毁掉整个Linux系统，比如rm -rf /*，感兴趣的话我们可以放在最后来演示（在以前老是听说安卓手机root，实际上就是获取安卓系统底层Linux系统的root权限，以实现修改系统文件的目的）\n我们可以使用sudo -s并输入当前用户的密码切换到root用户，可以看到出现了一些变化：\ntest@ubuntu-server:~$\n\nroot@ubuntu-server:&#x2F;home&#x2F;test#\n\n我们发现$符号变成了#符号，注意此符号表示当前的用户权限等级，并且test也变为了root，在此用户下，我们可以随意修改test用户文件夹以外的内容，而test用户下则无法修改。如果需要退出root用户，直接输入exit即可。\n接着我们来看一下，如何进行用户的管理操作，进行用户管理，包括添加用户和删除用户都需要root权限才可以执行，但是现在我们是test用户，我们可以在命令前面添加sudo来暂时以管理员身份执行此命令，比如说我们现在想要添加一个新的用户：\nsudo useradd study\n\n其中study就是我们想要创建的新用户，useradd命令就是创建新用户的命令，同样的，删除用户：\nsudo userdel study\n\nLinux中的命令一般都可以携带一些参数来以更多特地的方式执行，我们可以在创建用户时，添加一些额外的参数来进行更多高级操作：\n\n-d&lt;登录目录&gt; 　指定用户登录时的起始目录。\n-g&lt;群组&gt; 　指定用户所属的群组。\n-G&lt;群组&gt; 　指定用户所属的附加群组。\n-m 　自动建立用户的登入目录。\n-M 　不要自动建立用户的登入目录。\n-s  指定Shell，一般指定为&#x2F;bin&#x2F;bash\n\n如果还想查看更多命令，可以直接使用man来查看命令的详细参数列表，比如：\nman useradd\n\n比如我们现在需要在用户创建时顺便创建用户的文件夹，并指定shell（任意一种命令解释程序，用于处理我们输入的命令）为bash：\nsudo useradd study -m -s &#x2F;bin&#x2F;bash\n\n可以看到已经自动在home目录下创建了study文件夹（这里..表示上一级目录，.表示当前目录）：\ntest@ubuntu-server:~$ ls ..\nstudy  test\n\n用户创建完成之后，我们可以为此用户设定密码（如果不指定用户，那么会设置当前用户的密码）：\nsudo passwd study\n\n输入密码之后，我们可以使用命令来切换用户：\ntest@ubuntu-server:~$ su - study\nPassword: \nstudy@ubuntu-server:~$ \n\n可以看到，切换用户后名称已经修改为study了，我们使用exit即可退出当前用户回到test。\n输入who可以查看当前登录账号（注意是登录的账号）输入whoami可以查看当前的操作账号：\ntest@ubuntu-server:~$ su study\nPassword: \nstudy@ubuntu-server:&#x2F;home&#x2F;test$ cd ~\nstudy@ubuntu-server:~$ who\ntest     pts&#x2F;0        2022-01-24 03:57 (192.168.10.3)\nstudy@ubuntu-server:~$ whoami\nstudy\nstudy@ubuntu-server:~$ \n\n接着我们来看用户组，每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。我们可以输入groups来查看当前用户所有的用户组：\ntest@ubuntu-server:~$ groups\ntest adm cdrom sudo dip plugdev lxd\n\n我们可以输入id来查看用户所属的用户相关信息：\ntest@ubuntu-server:~$ id\nuid&#x3D;1000(test) gid&#x3D;1000(test) groups&#x3D;1000(test),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)\n\n我们可以看到test用户默认情况下主要用户组为同名的test用户组，并且还属于一些其他的用户组，其中sudo用户组就表示可以执行sudo命令，我们发现我们创建的study用户没有sudo的执行权限：\nstudy@ubuntu-server:~$ sudo -s\n[sudo] password for study: \nstudy is not in the sudoers file.  This incident will be reported.\n\n正是因为没有加入到sudo用户组，这里我们来尝试将其添加到sudo用户组：\ntest@ubuntu-server:~$ id study\nuid&#x3D;1001(study) gid&#x3D;1001(study) groups&#x3D;1001(study)\n\n使用usermod命令来对用户的相关设置进行修改，参数与useradd大致相同：\ntest@ubuntu-server:~$ sudo usermod study -G sudo\ntest@ubuntu-server:~$ id study\nuid&#x3D;1001(study) gid&#x3D;1001(study) groups&#x3D;1001(study),27(sudo)\n\n接着切换到study用户就可以使用sudo命令了：\nTo run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.\nSee &quot;man sudo_root&quot; for details.\n\nstudy@ubuntu-server:&#x2F;home&#x2F;test$ sudo -s\n[sudo] password for study: \nroot@ubuntu-server:&#x2F;home&#x2F;test# \n\n实际上，我们的用户信息是存储在配置文件中的，我们之前说了，配置文件一般都放在etc目录下，而用户和用户组相关的配置文件，存放在/etc/passwd和/etc/group中，我们可以使用cat命令将文件内容打印到控制台：\ntest@ubuntu-server:~$ cat &#x2F;etc&#x2F;passwd\nroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash\ndaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin\nbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin\nsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologin\nsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync\n\n格式为：注册名:口令:用户标识号:组标识号:用户名:用户主目录:命令解释程序 ，而我们的密码则存放在/etc/shadow中，是以加密形式存储的，并且需要root权限才能查看。\n\n常用命令接着我们来看一下Linux系统中一些比较常用的命令。\n文件操作文件是最基本的内容，我们可以使用ls命令列出当前目录中所有的文件，参数-a表示包含所有的隐藏文件，-l表示列出详细信息：\ntest@ubuntu-server:~$ ls -al\ntotal 44\ndrwxr-xr-x 4 test test 4096 Jan 24 08:55 .\ndrwxr-xr-x 4 root root 4096 Jan 24 04:24 ..\n-rw------- 1 test test 2124 Jan 24 04:29 .bash_history\n-rw-r--r-- 1 test test  220 Feb 25  2020 .bash_logout\n-rw-r--r-- 1 test test 3771 Feb 25  2020 .bashrc\ndrwx------ 2 test test 4096 Jan 21 15:48 .cache\ndrwx------ 3 test test 4096 Jan 23 14:49 .config\n-rw-r--r-- 1 test test  807 Feb 25  2020 .profile\n-rw------- 1 test test   34 Jan 24 04:17 .python_history\n-rw-r--r-- 1 test test    0 Jan 21 15:52 .sudo_as_admin_successful\n-rw------- 1 test test 7201 Jan 24 08:55 .viminfo\n\n可以看到当前目录下的整个文件列表，那么这些信息各种代表什么意思呢，尤其是最前面那一栏类似于drwxr-xr-x的字符串。\n它表示文件的属性，其中第1个字符表示此文件的类型：-表示普通文件，l为链接文件，d表示目录（文件夹），c表示字符设备、b表示块设备，还有p有名管道、f堆栈文件、s套接字等，这些一般都是用于进程之间通信使用的。\n第2-4个字符表示文件的拥有者（User）对该文件的权限，第5-7个字符表示文件所属用户组（Group）内用户对该文件的权限，最后8-10个字符表示其他用户（Other）对该文件的权限。其中r为读权限、w为写权限、x为执行权限，为了方便记忆，直接记UGO就行了。\n比如drwxr-xr-x就表示这是一个目录，文件的拥有者可以在目录中读、写和执行，而同一用户组的其他用户只能读和执行，其他用户也是一样。\n第二栏数据可以看到是一列数字，它表示文件创建的链接文件（快捷方式）数量，一般只有1表示只有当前文件，我们也可以尝试创建一个链接文件：\ntest@ubuntu-server:~$ ln .bash_logout kk\n\n创建后，会生成一个名为kk的文件，我们对此文件的操作相当于直接操作.bash_logout，跟Windows中的快捷方式比较类似，了解一下即可。再次执行ll命令，可以看到.bash_logout的链接数变成了2。\n第三栏数据为该文件或是目录的拥有者。\n第四栏数据表示所属的组。\n第五栏数据表示文件大小，以字节为单位。\n第六栏数据为文件的最后一次修改时间\n最后一栏就是文件名称了，就不多说了，再次提及..表示上级目录，.表示当前目录，最前面有一个.开头的文件为隐藏文件。可以看到上级目录（也就是&#x2F;home目录）所有者为root，并且非root用户无法进行写操作，只能执行读操作，而当前目录以及目录下所有文件则属于test用户，test用户可以随意进行修改。\n在了解了Linux的文件查看之后再去看Windows的文件管理，会觉得Windows的太拉了：\n\n那么，如果我们希望对文件的属性进行修改，比如我们现在希望将某个文件的写权限给关闭，可以使用chmod命令来进行文件属性修改，我们先创建一个test文件，使用touch命令来创建文件，使用mkdir命令来创建目录：\ntest@ubuntu-server:~$ touch test\ntest@ubuntu-server:~$ ll test\n-rw-rw-r-- 1 test test 0 Jan 24 09:32 test\n\n可以看到文件创建之后的默认权限为可读可写，接着我们来将其修改为只读，chmod的使用方法如下：\n\nchmod (u&#x2F;g&#x2F;o&#x2F;a)(+&#x2F;-)(r&#x2F;w&#x2F;x) 文件名称\n\n我们可以从ugo中选择或是直接a表示所有，+和-表示添加和删除权限，最后rwx不用我说了吧\ntest@ubuntu-server:~$ chmod a-w test\ntest@ubuntu-server:~$ ll test\n-r--r--r-- 1 test test 0 Jan 24 09:32 test\n\n除了这种方式之外，我们也可以使用数字来代替，比如现在我要给前两个添加读权限，那么：\n约定：r&#x3D;4，w&#x3D;2，x&#x3D;1，需要什么权限就让对应权限的数字相加，一个数字表示一个rwx的权限状态，比如我们想修改为-rw-rw-r--，那么对应的数字就是664，对应的命令为：\ntest@ubuntu-server:~$ chmod 664 test\ntest@ubuntu-server:~$ ll test\n-rw-rw-r-- 1 test test 0 Jan 24 09:32 test\n\n如果我们想修改文件的拥有者或是所属组，可以使用chown和chgrp命令：\ntest@ubuntu-server:~$ sudo chown root test \ntest@ubuntu-server:~$ ls -l\ntotal 0\n-rw-rw-r-- 1 root test 0 Jan 24 10:43 test\ntest@ubuntu-server:~$ sudo chgrp root test \ntest@ubuntu-server:~$ ls -l\ntotal 0\n-rw-rw-r-- 1 root root 0 Jan 24 10:43 test\n\n再次操作该文件，会发现没权限：\ntest@ubuntu-server:~$ chmod 777 test \nchmod: changing permissions of &#39;test&#39;: Operation not permitted\n\n接着我们来看文件的复制、移动和删除，这里我们先创建一个新的目录并进入到此目录用于操作：\ntest@ubuntu-server:~$ mkdir study\ntest@ubuntu-server:~$ cd study\ntest@ubuntu-server:~&#x2F;study$\n\n首先我们演示文件的复制操作，文件的复制使用cp命令，比如现在我们想把上一级目录中的test文件复制到当前目录中：\ntest@ubuntu-server:~&#x2F;study$ cp ..&#x2F;test test\ntest@ubuntu-server:~&#x2F;study$ ls\ntest\n\n那么如果我们想要将一整个目录进行复制呢？我们需要添加一个-r参数表示将目录中的文件递归复制：\ntest@ubuntu-server:~&#x2F;study$ cd ~\ntest@ubuntu-server:~$ cp -r study study_copied\ntest@ubuntu-server:~$ ls -l\ntotal 8\ndrwxrwxr-x 2 test test 4096 Jan 24 10:16 study\ndrwxrwxr-x 2 test test 4096 Jan 24 10:20 study_copied\n-rw-rw-r-- 1 test test    0 Jan 24 09:32 test\n\n可以看到我们的整个目录中所有的文件也一起被复制了。\n接着我们来看看移动操作，相当于是直接将一个文件转移到另一个目录中了，我们再创建一个目录用于文件的移动，并将test文件移动到此目录中，我们使用mv命令进行文件的移动：\ntest@ubuntu-server:~$ mkdir study2\ntest@ubuntu-server:~$ mv test study2\ntest@ubuntu-server:~$ ls\nstudy  study2  study_copied\ntest@ubuntu-server:~$ cd study2\ntest@ubuntu-server:~&#x2F;study2$ ls\ntest\n\n现在我们想要移动个目录到另一个目录中，比如我们想将study目录移动到study2目录中：\ntest@ubuntu-server:~$ mv study study2\ntest@ubuntu-server:~$ ls\nstudy2  study_copied\ntest@ubuntu-server:~$ cd study2\ntest@ubuntu-server:~&#x2F;study2$ ls\nstudy  test\n\nmv命令不仅能实现文件的移动，还可以实现对文件重命名操作，比如我们想将文件test重命名为yyds，那么直接将其进行移动操作即可：\ntest@ubuntu-server:~&#x2F;study2$ ls\nstudy  test\ntest@ubuntu-server:~&#x2F;study2$ mv test yyds\ntest@ubuntu-server:~&#x2F;study2$ ls\nstudy  yyds\n\n最后就是删除命令了，使用rm进行删除操作，比如现在我们想删除study2目录（注意需要添加-r参数表示递归删除文件夹中的内容）：\ntest@ubuntu-server:~$ rm -r study2\ntest@ubuntu-server:~$ ls\nstudy_copied\n\n而最常提到的rm -rf /*正是删除根目录下所有的文件（非常危险的操作），-f表示忽略不存在的文件，不进行任何提示，*是一个通配符，表示任意文件。这里我们演示一下删除所有.txt结尾的文件：\ntest@ubuntu-server:~$ touch 1.txt 2.txt 3.txt\ntest@ubuntu-server:~$ ls\n1.txt  2.txt  3.txt\ntest@ubuntu-server:~$ rm *.txt\ntest@ubuntu-server:~$ ls\ntest@ubuntu-server:~$ \n\n最后我们再来看文件的搜索，我们使用find命令来进行搜索，比如我想搜索&#x2F;etc目录下名为passwd的文件：\ntest@ubuntu-server:~$ sudo find &#x2F;etc -name passwd\n[sudo] password for test: \n&#x2F;etc&#x2F;pam.d&#x2F;passwd\n&#x2F;etc&#x2F;passwd\n\n它还支持通配符，比如搜索以s开头的文件：\ntest@ubuntu-server:~$ sudo find &#x2F;etc -name s*\n&#x2F;etc&#x2F;subuid\n&#x2F;etc&#x2F;screenrc\n&#x2F;etc&#x2F;sensors3.conf\n&#x2F;etc&#x2F;sysctl.conf\n&#x2F;etc&#x2F;sudoers\n&#x2F;etc&#x2F;shadow\n&#x2F;etc&#x2F;skel\n&#x2F;etc&#x2F;pam.d&#x2F;su\n&#x2F;etc&#x2F;pam.d&#x2F;sshd\n&#x2F;etc&#x2F;pam.d&#x2F;sudo\n...\n\n系统管理接着我们来查看一些系统管理相关的命令，比如我们Windows中的任务管理器，我们可以使用top命令来打开：\ntop - 10:48:46 up  5:52,  1 user,  load average: 0.00, 0.00, 0.00\nTasks: 191 total,   2 running, 189 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nMiB Mem :   3919.1 total,   2704.2 free,    215.0 used,    999.9 buff&#x2F;cache\nMiB Swap:   3923.0 total,   3923.0 free,      0.0 used.   3521.4 avail Mem \n\n    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       \n  10528 test      20   0    8944   3072   2652 R   0.7   0.1   0:00.07 top                           \n   9847 root      20   0       0      0      0 I   0.3   0.0   0:00.87 kworker&#x2F;0:0-events            \n      1 root      20   0  102760  10456   7120 S   0.0   0.3   0:02.02 systemd                       \n      2 root      20   0       0      0      0 S   0.0   0.0   0:00.01 kthreadd                      \n      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                        \n      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp                    \n      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker&#x2F;0:0H-kblockd          \n      8 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu_wq                  \n      9 root      20   0       0      0      0 S   0.0   0.0   0:00.15 ksoftirqd&#x2F;0                   \n     10 root      20   0       0      0      0 R   0.0   0.0   0:01.49 rcu_sched                     \n     11 root      rt   0       0      0      0 S   0.0   0.0   0:00.24 migration&#x2F;0                   \n     12 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject&#x2F;0                 \n     14 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp&#x2F;0                       \n     15 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp&#x2F;1                       \n     16 root     -51   0       0      0      0 S   0.0   0.0   0:00.00 idle_inject&#x2F;1                 \n     17 root      rt   0       0      0      0 S   0.0   0.0   0:00.30 migration&#x2F;1                   \n     18 root      20   0       0      0      0 S   0.0   0.0   0:00.07 ksoftirqd&#x2F;1                   \n     20 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker&#x2F;1:0H-kblockd  \n\n可以很清楚地看到当前CPU的使用情况以及内存的占用情况。\n按下数字键1，可以展示所有CPU核心的使用情况：\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n\n按下f键可以设置以哪一列进行排序或是显示那些参数：\nFields Management for window 1:Def, whose current sort field is %MEM\n   Navigate with Up&#x2F;Dn, Right selects for move then &lt;Enter&gt; or Left commits,\n   &#39;d&#39; or &lt;Space&gt; toggles display, &#39;s&#39; sets sort.  Use &#39;q&#39; or &lt;Esc&gt; to end!\n\n按下q键即可退出监控界面。\n我们可以直接输入free命令来查看当前系统的内存使用情况：\ntest@ubuntu-server:~$ free -m\n              total        used        free      shared  buff&#x2F;cache   available\nMem:           3919         212        2706           1         999        3523\nSwap:          3922           0        3922\n\n其中-m表示以M为单位，也可以-g表示以G为单位，默认是kb为单位。\n最后就是磁盘容量，我们可以使用lsblk来查看所有块设备的信息，其中就包括我们的硬盘、光驱等：\ntest@ubuntu-server:~$ lsblk\nNAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nloop0                       7:0    0 48.9M  1 loop &#x2F;snap&#x2F;core18&#x2F;2127\nloop1                       7:1    0 28.1M  1 loop &#x2F;snap&#x2F;snapd&#x2F;12707\nloop2                       7:2    0   62M  1 loop &#x2F;snap&#x2F;lxd&#x2F;21032\nsr0                        11:0    1 1024M  0 rom  \nnvme0n1                   259:0    0   20G  0 disk \n├─nvme0n1p1               259:1    0  512M  0 part &#x2F;boot&#x2F;efi\n├─nvme0n1p2               259:2    0    1G  0 part &#x2F;boot\n└─nvme0n1p3               259:3    0 18.5G  0 part \n  └─ubuntu--vg-ubuntu--lv 253:0    0 18.5G  0 lvm  &#x2F;\n\n可以看到nvme开头的就是我们的硬盘（这个因人而异，可能你们的是sda，磁盘类型不同名称就不同）可以看到nvme0n1  容量为20G，并且512M用作存放EFI文件，1G存放启动文件，剩余容量就是存放系统文件和我们的用户目录。\n这里要提到一个挂载的概念：\n\n\n\n\n\n\n\n\n\n挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。\n比如我们的主硬盘，挂载点就被设定为/根目录，而我们所有保存的文件都会存储在硬盘中，如果你有U盘（最好将U盘的文件格式改为ExFat，可以直接在Windows中进行格式化，然后随便放入一些文件即可）之类的东西，我们可以演示一下对U盘进行挂载：\ntest@ubuntu-server:~$ sudo fdisk -l\n...\nDisk &#x2F;dev&#x2F;sda: 60 GiB, 64424509440 bytes, 125829120 sectors\nDisk model: USB DISK        \nUnits: sectors of 1 * 512 &#x3D; 512 bytes\nSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes\nI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes\nDisklabel type: dos\nDisk identifier: 0x4a416279\n\nDevice     Boot     Start       End   Sectors  Size Id Type\n&#x2F;dev&#x2F;sda1  *       614400 125214719 124600320 59.4G  7 HPFS&#x2F;NTFS&#x2F;exFAT\n&#x2F;dev&#x2F;sda2       125214720 125825022    610303  298M  6 FAT16\n\n将U盘插入电脑，选择连接到Linux，输入sudo fdisk -l命令来查看硬盘实体情况，可以看到有一个USB DISK设备，注意观察一下是不是和自己的U盘容量一致，可以看到设备名称为/dev/sda1。\n接着我们设备挂载到一个目录下：\ntest@ubuntu-server:~$ mkdir u-test\ntest@ubuntu-server:~$ sudo mount &#x2F;dev&#x2F;sda1 u-test&#x2F;\ntest@ubuntu-server:~$ cd u-test&#x2F;\ntest@ubuntu-server:~&#x2F;u-test$ ls\n CGI\n cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso\n cn_windows_7_professional_x64_dvd_x15-65791.iso\n cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso\n cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso\n cn_windows_server_2019_updated_july_2020_x64_dvd_2c9b67da.iso\n&#39;System Volume Information&#39;\n zh-cn_windows_10_consumer_editions_version_21h1_updated_sep_2021_x64_dvd_991b822f.iso\n zh-cn_windows_11_consumer_editions_x64_dvd_904f13e4.iso\n\n最后进入到此目录中，就能看到你U盘中的文件了，如果你不想使用U盘了，可以直接取消挂载：\ntest@ubuntu-server:~&#x2F;u-test$ cd ..\ntest@ubuntu-server:~$ sudo umount &#x2F;dev&#x2F;sda1\n\n最后我们可以通过df命令查看当前磁盘使用情况：\ntest@ubuntu-server:~$ df -m\nFilesystem                        1M-blocks  Used Available Use% Mounted on\nudev                                   1900     0      1900   0% &#x2F;dev\ntmpfs                                   392     2       391   1% &#x2F;run\n&#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv     18515  6544     11009  38% &#x2F;\ntmpfs                                  1960     0      1960   0% &#x2F;dev&#x2F;shm\ntmpfs                                     5     0         5   0% &#x2F;run&#x2F;lock\ntmpfs                                  1960     0      1960   0% &#x2F;sys&#x2F;fs&#x2F;cgroup\n&#x2F;dev&#x2F;nvme0n1p2                          976   109       800  12% &#x2F;boot\n&#x2F;dev&#x2F;nvme0n1p1                          511     4       508   1% &#x2F;boot&#x2F;efi\n&#x2F;dev&#x2F;loop0                               49    49         0 100% &#x2F;snap&#x2F;core18&#x2F;2127\n&#x2F;dev&#x2F;loop1                               29    29         0 100% &#x2F;snap&#x2F;snapd&#x2F;12707\n&#x2F;dev&#x2F;loop2                               62    62         0 100% &#x2F;snap&#x2F;lxd&#x2F;21032\ntmpfs                                   392     0       392   0% &#x2F;run&#x2F;user&#x2F;1000\n\n输入ps可以查看当前运行的一些进程，其实和top有点类似，但是没有监控功能，只能显示当前的。\ntest@ubuntu-server:~$ ps\n    PID TTY          TIME CMD\n  11438 pts&#x2F;0    00:00:00 bash\n  11453 pts&#x2F;0    00:00:00 ps\n\n添加-ef查看所有的进程：\ntest@ubuntu-server:~$ ps -ef\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot           1       0  0 04:55 ?        00:00:02 &#x2F;sbin&#x2F;init\nroot           2       0  0 04:55 ?        00:00:00 [kthreadd]\nroot           3       2  0 04:55 ?        00:00:00 [rcu_gp]\nroot           4       2  0 04:55 ?        00:00:00 [rcu_par_gp]\nroot           6       2  0 04:55 ?        00:00:00 [kworker&#x2F;0:0H-kblockd]\n...\n\n我们可以找到对应的进程ID（PID），使用kill命令将其强制终止：\ntest@ubuntu-server:~$ ps\n    PID TTY          TIME CMD\n  11438 pts&#x2F;0    00:00:00 bash\n  11455 pts&#x2F;0    00:00:00 ps\ntest@ubuntu-server:~$ kill -9 11438\nConnection to 192.168.10.6 closed.\n\n比如我们可以将当前会话的bash给杀死，那么会导致我们的连接直接断开，其中-9是一个信号，表示杀死进程：\n\n1 (HUP)：重新加载进程。\n9 (KILL)：杀死一个进程。\n15 (TERM)：正常停止一个进程。\n\n最后如果我们想要正常关机，只需要输入shutdown即可，系统会创建一个关机计划，并在指定时间关机，或是添加now表示立即关机：\ntest@ubuntu-server:~$ sudo shutdown\n[sudo] password for test: \nShutdown scheduled for Mon 2022-01-24 11:46:18 UTC, use &#39;shutdown -c&#39; to cancel.\ntest@ubuntu-server:~$ sudo shutdown now\nConnection to 192.168.10.6 closed by remote host.\nConnection to 192.168.10.6 closed.\n\n压缩解压比较常用的压缩和解压也是重点，我们在Windows中经常需要下载一些压缩包，并且将压缩包解压才能获得里面的文件，而Linux中也支持文件的压缩和解压。\n这里我们使用tar命令来完成文件亚索和解压操作，在Linux中比较常用的是gzip格式，后缀名一般为.gz，tar命令的参数-c表示对文件进行压缩，创建新的压缩文件，-x表示进行解压操作，-z表示以gzip格式进行操作，-v可以在处理过程中输出一些日志信息，-f表示对普通文件进行操作，这里我们创建三个文件并对这三个文件进行打包：\ntest@ubuntu-server:~$ tar -zcvf test.tar.gz *.txt\n1.txt\n2.txt\n3.txt\ntest@ubuntu-server:~$ ls\n1.txt  2.txt  3.txt  test.tar.gz\ntest@ubuntu-server:~$ \n\n接着我们删除刚刚三个文件，再执行解压操作，得到压缩包中文件：\ntest@ubuntu-server:~$ rm *.txt\ntest@ubuntu-server:~$ ls\ntest.tar.gz\ntest@ubuntu-server:~$ tar -zxvf test.tar.gz \n1.txt\n2.txt\n3.txt\ntest@ubuntu-server:~$ ls\n1.txt  2.txt  3.txt  test.tar.gz\n\n同样的，我们也可以对一个文件夹进行打包：\ntest@ubuntu-server:~$ mv *.txt test\ntest@ubuntu-server:~$ tar -zcvf test.tar.gz test&#x2F;\ntest&#x2F;\ntest&#x2F;1.txt\ntest&#x2F;2.txt\ntest&#x2F;3.txt\ntest@ubuntu-server:~$ rm -r test\ntest@ubuntu-server:~$ ls\ntest.tar.gz \ntest@ubuntu-server:~$ tar -zxvf test.tar.gz \ntest&#x2F;\ntest&#x2F;1.txt\ntest&#x2F;2.txt\ntest&#x2F;3.txt\ntest@ubuntu-server:~$ ls\ntest  test.tar.gz\ntest@ubuntu-server:~$ ls test\n1.txt  2.txt  3.txt\n\n到此，Linux的一些基本命令就讲解为止。\n\nvim文本编辑器和Windows中的记事本一样，Linux中也有文本编辑器，叫做Vi编辑器，Ubuntu中内置了Vi编辑器的升级版Vim，我们这里就讲解Vim编辑器的使用。\n我们可以直接输入vim 文件名称来使用Vim编辑器对文本文件进行编辑：\ntest@ubuntu-server:~$ vim hello.txt\n\n进入编辑器之后，我们发现界面变成了：\n~                                                                                                                                                                                         \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n&quot;hello.txt&quot; [New File]                                                            0,0-1         All\n\n这时我们直接输入内容是无法完成的，因为默认进入之后为命令模式，Vim编辑器默认有三种模式：\n\n\n命令模式：此模式下可以输入任意的命令进行操作，所有的输入都被看做是命令输入，而不是文本编辑输入。\n编辑模式：此模式下输入的任何内容都会以文本编辑方式写入到文件中，就像我们直接在Windows的记事本中写内容一样。\n末行模式：此模式下用于输入一些复杂命令，会在最后一行进行复杂命令的输入。\n\n在命令模式下，我们可以直接按下键盘上的i，此命令表示进行插入操作，会自动切换到编辑模式，这时可以看到最下方变为：\n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n~                                                                                                   \n-- INSERT --                                                                      1,1           All\n\n而这时我们所有的输入内容都可以直接写到文件中了，如果我们想回到命令模式，按下Esc键即可。\n除了i以外，我们也可以按下a表示从当前光标所在位置之后继续写，与i不同的是，i会在光标之前继续写，o会直接跳到下一行，而A表示在当前行的最后继续写入，I表示在当前行的最前面继续写入。\n这里我们随便粘贴一段文本信息进去（不要用Ctrl+V，Linux中没这操作，XShell右键点粘贴）：\nI was hard on people sometimes, probably harder than I needed to be. \nI remember the time when Reed was six years old, coming home, and I had just fired somebody that day.\nAnd I imagined what it was like for that person to tell his family and his young son that he had lost his job. \nIt was hard. \nBut　somebody’s got to do it. \nI figured that it was always my job to make sure that the team was excellent, and if I didn’t do it, nobody was going to do it.\nYou always have to keep pushing to innovate.\nDylan could have sung protest songs forever and probably made a lot of money, but he didn’t. \nHe had to move on, and when he did, by going electric in 1965, he alienated a lot of people.\n\n在我们编辑完成之后，需要进入到末行模式进行文件的保存并退出，按下:进入末行模式，再输入wq即可保存退出。\n接着我们来看一些比较常用的命令，首先是命令模式下的光标移动命令：\n\n^   直接调到本行最前面\n$   直接跳到本行最后面\ngg  直接跳到第一行\n[N]G    跳转到第N行\n[N]方向键    向一个方向跳转N个字符\n\n在末行模式下，常用的复杂命令有：\n\n:set number    开启行号\n:w    保存\n:wq或:x    保存并关闭\n:q    关闭\n:q!    强制关闭\n\n我们可以输入/或是?在末行模式中使用搜索功能，比如我们要搜索单词it：\n&#x2F;it  \n\n接着会在文本中出现高亮，按n跳转到下一个搜索结果，?是从后向前搜索，&#x2F;是从前向后搜索。\n它还支持替换功能，但是使用起来稍微比较复杂，语法如下：\n:[addr]s&#x2F;源字符串&#x2F;目的字符串&#x2F;[option]\n\naddr表示第几行或是一个范围，option表示操作类型：\n\ng: globe,表示全局替换\nc: confirm,表示进行确认\np: 表示替代结果逐行显示(Ctrl + L恢复屏幕)\ni:  ignore,不区分大小写\n\n比如我们要将当前行中的it全部替换为he，那么可以这样写：\n:s&#x2F;it&#x2F;he&#x2F;g\n\n实际上除了以上三种模式外，还有一种模式叫做可视化模式，按下键盘上的v即可进入，它能够支持选取一段文本，选取后，我们可以对指定段落的文本内容快速进行复制、剪切、删除、插入等操作，非常方便。在此模式下，我们可以通过上下左右键进行选取，以进入可视化模式时的位置作为基本位置，通过移动另一端来进行选取。\n我们可以使用以下命令来对选中区域进行各种操作：\n\ny   复制选中区域\nd&#x2F;x   剪切（删除）选中区域\np  粘贴\nu  撤销上一步\n\n当然，这些命令在命令模式下也可以使用，但是可视化模式下使用更适合一些。\n\n环境安装和项目部署在学习完了Linux操作系统的一些基本操作之后，我们接着来看如何进行项目的环境安装和部署，包括安装JDK、Nginx服务器，以及上传我们的SpringBoot项目并运行。\n我们可以直接使用apt进行软件的安装，它是一个高级的安装包管理工具，我们可以直接寻找对应的软件进行安装，无需再去官网进行下载，非常方便，软件仓库中默认已经帮助我们存放了大量实用软件的安装包，只需要一个安装命令就可以进行安装了。\n实际上Ubuntu系统已经为我们自带了一些环境了，比如Python3：\ntest@ubuntu-server:~$ python3\nPython 3.8.10 (default, Nov 26 2021, 20:14:08) \n[GCC 9.3.0] on linux\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n&gt;&gt;&gt; print(&quot;HelloWorld！&quot;)\nHelloWorld！\n&gt;&gt;&gt; exit()\n\nC语言的编译工具GCC可以通过APT进行安装：\nsudo apt install gcc\n\n安装后，可以编写一个简单的C语言程序并且编译为可执行文件：\n#include&lt;stdio.h&gt;\n\nint main()&#123;\n        printf(&quot;Hello World!\\n&quot;);\n&#125;  \n\ntest@ubuntu-server:~$ vim hello.c\ntest@ubuntu-server:~$ gcc hello.c -o hello\ntest@ubuntu-server:~$ .&#x2F;hello \nHello World!\n\n而JDK实际上安装也非常简单，通过APT即可：\ntest@ubuntu-server:~$ sudo apt install openjdk-8-j\nopenjdk-8-jdk           openjdk-8-jre           openjdk-8-jre-zero      \nopenjdk-8-jdk-headless  openjdk-8-jre-headless  \ntest@ubuntu-server:~$ sudo apt install openjdk-8-jdk\n\n接着我们来测试一下编译和运行，首先编写一个Java程序：\ntest@ubuntu-server:~$ vim Main.java\n\npublic class Main&#123;\n        public static void main(String[] args)&#123;\n                System.out.println(&quot;Hello World！&quot;);\n        &#125;\n&#125;\n\ntest@ubuntu-server:~$ javac Main.java \ntest@ubuntu-server:~$ ls\nMain.class  Main.java\ntest@ubuntu-server:~$ java Main \nHello World！\n\n接着我们来部署一下Redis服务器：\ntest@ubuntu-server:~$ sudo apt install redis\n\n安装完成后，可以直接使用redis-cli命令打开Redis客户端连接本地的服务器：\ntest@ubuntu-server:~$ redis-cli\n127.0.0.1:6379&gt; keys *\n(empty list or set)\n\n使用和之前Windows下没有区别。\n接着我们安装一下MySQL服务器，同样的，直接使用apt即可：\nsudo apt install mysql-server-8.0 \n\n我们直接直接登录MySQL服务器，注意要在root权限下使用，这样就不用输入密码了：\nsudo mysql -u root -p\nEnter password: \nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 11\nServer version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)\n\nCopyright (c) 2000, 2021, Oracle and&#x2F;or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and&#x2F;or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt; exit\n\n可以发现实际上就是我们之前在Windows的CMD中使用的样子，接着我们就创建一个生产环境下使用的数据库：\nmysql&gt; create database book_manage;\nmysql&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| book_manage        |\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n5 rows in set (0.01 sec)\n\n接着我们创建一个用户来使用这个数据，一会我们就可以将SpringBoot配置文件进行修改并直接放到此服务器上进行部署。\nmysql&gt; create user test identified by &#39;123456&#39;;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; grant all on book_manage.* to test;\nQuery OK, 0 rows affected (0.00 sec)\n\n如果觉得这样很麻烦不是可视化的，可以使用Navicat连接进行操作，注意开启一下MySQL的外网访问。\ntest@ubuntu-server:~$ mysql -u test -p\nEnter password: \nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 13\nServer version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)\n\nCopyright (c) 2000, 2021, Oracle and&#x2F;or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and&#x2F;or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| book_manage        |\n| information_schema |\n+--------------------+\n2 rows in set (0.01 sec)\n\n使用test用户登录之后，查看数据库列表，有book_manage就OK了。\n最后我们修改一下SpringBoot项目的生产环境配置即可：\nspring:\n  mail:\n    host: smtp.163.com\n    username: javastudy111@163.com\n    password: TKPGLAPDSWKGJOWK\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;book_manage\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: test\n    password: 123456\n  jpa:\n    show-sql: false\n    hibernate:\n      ddl-auto: update\nspringfox:\n  documentation:\n    enabled: false\n\n然后启动我们的项目：\ntest@ubuntu-server:~$ java -jar springboot-project-0.0.1-SNAPSHOT.jar \n\n现在我们将前端页面的API访问地址修改为我们的SpringBoot服务器地址，即可正常使用了。\n我们也可以将我们的静态资源使用Nginx服务器进行代理：\n\n\n\n\n\n\n\n\n\nNginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。\nNginx非常强大，它能够通提供非常方便的反向代理服务，并且支持负载均衡，不过我们这里用一下反向代理就可以了，实际上就是代理我们的前端页面，然后我们访问Nginx服务器即可访问到静态资源，这样我们前后端都放在了服务器上（你也可以搞两台服务器，一台挂静态资源一台挂SpringBoot服务器，实现真正意义上的分离，有条件的还能上个域名和证书啥的）。\n安装如下：\ntest@ubuntu-server:~$ sudo apt install nginx\n\n安装完成后，我们可以直接访问：http://192.168.10.4/，能够出现Nginx页面表示安装成功！\n接着我们将静态资源上传到Linux服务器中，然后对Nginx进行反向代理配置：\ntest@ubuntu-server:~$ cd &#x2F;etc&#x2F;nginx&#x2F;\ntest@ubuntu-server:&#x2F;etc&#x2F;nginx$ ls\nconf.d\t\tkoi-utf     modules-available  proxy_params\tsites-enabled  win-utf\nfastcgi.conf\tkoi-win     modules-enabled    scgi_params\tsnippets\nfastcgi_params\tmime.types  nginx.conf\t       sites-available\tuwsgi_params\ntest@ubuntu-server:&#x2F;etc&#x2F;nginx$ sudo vim nginx.conf\n\nserver &#123;\n                listen       80;\n                server_name  192.168.10.4;\n                add_header Access-Control-Allow-Origin *;\n                location &#x2F; &#123;\n                        root &#x2F;home&#x2F;test&#x2F;static;\n                        charset utf-8;\n                        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;\n                        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;\n                        add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;;\n                        add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,*&#39;;\n                &#125;\n        &#125;\n\n然后就可以直接访问到我们的前端页面了，这时再开启SpringBoot服务器即可，可以在最后添加&amp;符号表示后台启动。\n","slug":"SpringBoot笔记（五）","date":"2022-03-05T14:39:15.395Z","categories_index":"SpringBoot笔记","tags_index":"SpringBoot笔记","author_index":"YangChao"},{"id":"1c189d12d9b261f21a36bc9b6f4c2deb","title":"SpringBoot笔记（四）","content":"SpringBoot其他框架通过了解其他的SpringBoot框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能。\n邮件发送：Mail我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。\n那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n邮件发送在学习邮件发送之前，我们需要先了解一下什么是电子邮件。\n电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。\n虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。\n要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。\n所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。\n\n比较常用的协议有两种：\n\nSMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）\nPOP3协议（主要用于接收邮件 Post Office Protocol 3）\n\n整个发送&#x2F;接收流程大致如下：\n\n实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。\n而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。\n这里以163邮箱 https://mail.163.com 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp&#x2F;pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。\nspring:\n  mail:\n  \t# 163邮箱的地址为smtp.163.com，直接填写即可\n    host: smtp.163.com\n    # 你申请的163邮箱\n    username: javastudy111@163.com\n    # 注意密码是在开启smtp&#x2F;pop3时自动生成的，记得保存一下，不然就找不到了\n    password: AZJTOAWZESLMHTNI\n\n配置完成后，接着我们来进行一下测试：\n@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n  \t&#x2F;&#x2F;JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean\n    @Autowired\n    JavaMailSender sender;\n\n    @Test\n    void contextLoads() &#123;\n      \t&#x2F;&#x2F;SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容\n        SimpleMailMessage message &#x3D; new SimpleMailMessage();\n      \t&#x2F;&#x2F;设置邮件标题\n        message.setSubject(&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;);\n      \t&#x2F;&#x2F;设置邮件内容\n        message.setText(&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot; +\n                &quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;);\n      \t&#x2F;&#x2F;设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱\n        message.setTo(&quot;你的QQ号@qq.com&quot;);\n      \t&#x2F;&#x2F;邮件发送者，这里要与配置文件中的保持一致\n        message.setFrom(&quot;javastudy111@163.com&quot;);\n      \t&#x2F;&#x2F;OK，万事俱备只欠发送\n        sender.send(message);\n    &#125;\n\n&#125;\n\n如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：\n@Test\nvoid contextLoads() throws MessagingException &#123;\n  \t&#x2F;&#x2F;创建一个MimeMessage\n    MimeMessage message &#x3D; sender.createMimeMessage();\n  \t&#x2F;&#x2F;使用MimeMessageHelper来帮我们修改MimeMessage中的信息\n    MimeMessageHelper helper &#x3D; new MimeMessageHelper(message, true);\n    helper.setSubject(&quot;Test&quot;);\n    helper.setText(&quot;lbwnb&quot;);\n    helper.setTo(&quot;你的QQ号@qq.com&quot;);\n    helper.setFrom(&quot;javastudy111@163.com&quot;);\n  \t&#x2F;&#x2F;发送修改好的MimeMessage\n    sender.send(message);\n&#125;\n\n邮件注册既然我们已经了解了邮件发送，那么我们接着来看如何在我们的项目中实现邮件验证。\n首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！\n\n\n持久层框架：JPA\n用了Mybatis之后，你看那个JDBC，真是太逊了。\n这么说，你的项目很勇哦？\n开玩笑，我的写代码超勇的好不好。\n阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？\n不再有SQL语句？那我怎么和数据库交互啊？\n我看你是完全不懂哦\n懂，懂什么啊？\n你想懂？来，到我项目里来，我给你看点好康的。\n好康？是什么新框架哦？\n什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。\n哇，杰哥，你项目里面都没SQL语句诶，这是用的什么框架啊？\n\n在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。\n但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路select * from xxx where xxx=xxx，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。\n认识SpringDataJPA首先我们来看一个国外的统计：\n![image-20220119140326867](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220119140326867.png)\n不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有。\n至于为啥SSM阶段不讲这个，而是放到现在来讲也是因为，在微服务场景下它的优势才能更多的发挥出来。\n那么，什么是JPA？\nJPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。\n在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。\n而实现JPA规范的框架一般最常用的就是Hibernate，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。\n官网：https://spring.io/projects/spring-data-jpa\n使用JPA同样的，我们只需要导入stater依赖即可：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n接着我们可以直接创建一个类，比如账户类，我们只需要把一个账号对应的属性全部定义好即可：\n@Data\npublic class Account &#123;\n    int id;\n    String username;\n    String password;\n&#125;\n\n接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样。\n@Data\n@Entity   &#x2F;&#x2F;表示这个类是一个实体类\n@Table(name &#x3D; &quot;users&quot;)    &#x2F;&#x2F;对应的数据库中表名称\npublic class Account &#123;\n\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)   &#x2F;&#x2F;生成策略，这里配置为自增\n    @Column(name &#x3D; &quot;id&quot;)    &#x2F;&#x2F;对应表中id这一列\n    @Id     &#x2F;&#x2F;此属性为主键\n    int id;\n\n    @Column(name &#x3D; &quot;username&quot;)   &#x2F;&#x2F;对应表中username这一列\n    String username;\n\n    @Column(name &#x3D; &quot;password&quot;)   &#x2F;&#x2F;对应表中password这一列\n    String password;\n&#125;\n\n接着我们来修改一下配置文件：\nspring:\n  jpa:\n\t\t#开启SQL语句执行日志信息\n    show-sql: true\n    hibernate:\n    \t#配置为自动创建\n      ddl-auto: create\n\nddl-auto属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有4种\n\ncreate 启动时删数据库中的表，然后创建，退出时不删除数据表 \ncreate-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错 \nupdate 如果启动时表格式不一致则更新表，原有数据保留 \nvalidate 项目启动表结构进行校验 如果不一致则报错\n\n我们可以在日志中发现，在启动时执行了如下SQL语句：\nHibernate: create table users (id integer not null auto_increment, password varchar(255), username varchar(255), primary key (id)) engine&#x3D;InnoDB\n\n而我们的数据库中对应的表已经创建好了。\n我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：\n@Repository\npublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;\n    \n&#125;\n\n注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：\n@SpringBootTest\nclass JpaTestApplicationTests &#123;\n\n    @Resource\n    AccountRepository repository;\n\n    @Test\n    void contextLoads() &#123;\n      \t&#x2F;&#x2F;直接根据ID查找\n        repository.findById(1).ifPresent(System.out::println);\n    &#125;\n\n&#125;\n\n运行后，成功得到查询结果。我们接着来测试增删操作：\n@Test\nvoid addAccount()&#123;\n    Account account &#x3D; new Account();\n    account.setUsername(&quot;Admin&quot;);\n    account.setPassword(&quot;123456&quot;);\n    account &#x3D; repository.save(account);  &#x2F;&#x2F;返回的结果会包含自动生成的主键值\n    System.out.println(&quot;插入时，自动生成的主键ID为：&quot;+account.getId());\n&#125;\n\n@Test\nvoid deleteAccount()&#123;\n    repository.deleteById(2);   &#x2F;&#x2F;根据ID删除对应记录\n&#125;\n\n@Test\nvoid pageAccount() &#123;\n    repository.findAll(PageRequest.of(0, 1)).forEach(System.out::println);  &#x2F;&#x2F;直接分页\n&#125;\n\n我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。\n相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。\n方法名称拼接自定义SQL虽然接口预置的方法使用起来非常方便，但是如果我们需要进行条件查询等操作或是一些判断，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：\n\n\n\nDistinct\nfindDistinctByLastnameAndFirstname\nselect distinct … where x.lastname = ?1 and x.firstname = ?2\n\n\n\nAnd\nfindByLastnameAndFirstname\n… where x.lastname = ?1 and x.firstname = ?2\n\n\nOr\nfindByLastnameOrFirstname\n… where x.lastname = ?1 or x.firstname = ?2\n\n\nIs，Equals\nfindByFirstname,findByFirstnameIs,findByFirstnameEquals\n… where x.firstname = ?1\n\n\nBetween\nfindByStartDateBetween\n… where x.startDate between ?1 and ?2\n\n\nLessThan\nfindByAgeLessThan\n… where x.age &lt; ?1\n\n\nLessThanEqual\nfindByAgeLessThanEqual\n… where x.age &lt;= ?1\n\n\nGreaterThan\nfindByAgeGreaterThan\n… where x.age &gt; ?1\n\n\nGreaterThanEqual\nfindByAgeGreaterThanEqual\n… where x.age &gt;= ?1\n\n\nAfter\nfindByStartDateAfter\n… where x.startDate &gt; ?1\n\n\nBefore\nfindByStartDateBefore\n… where x.startDate &lt; ?1\n\n\nIsNull，Null\nfindByAge(Is)Null\n… where x.age is null\n\n\nIsNotNull，NotNull\nfindByAge(Is)NotNull\n… where x.age not null\n\n\nLike\nfindByFirstnameLike\n… where x.firstname like ?1\n\n\nNotLike\nfindByFirstnameNotLike\n… where x.firstname not like ?1\n\n\nStartingWith\nfindByFirstnameStartingWith\n… where x.firstname like ?1（参数与附加%绑定）\n\n\nEndingWith\nfindByFirstnameEndingWith\n… where x.firstname like ?1（参数与前缀%绑定）\n\n\nContaining\nfindByFirstnameContaining\n… where x.firstname like ?1（参数绑定以%包装）\n\n\nOrderBy\nfindByAgeOrderByLastnameDesc\n… where x.age = ?1 order by x.lastname desc\n\n\nNot\nfindByLastnameNot\n… where x.lastname &lt;&gt; ?1\n\n\nIn\nfindByAgeIn(Collection&lt;Age&gt; ages)\n… where x.age in ?1\n\n\nNotIn\nfindByAgeNotIn(Collection&lt;Age&gt; ages)\n… where x.age not in ?1\n\n\nTrue\nfindByActiveTrue()\n… where x.active = true\n\n\nFalse\nfindByActiveFalse()\n… where x.active = false\n\n\nIgnoreCase\nfindByFirstnameIgnoreCase\n… where UPPER(x.firstname) = UPPER(?1)\n\n\n比如我们想要实现根据用户名模糊匹配查找用户：\n@Repository\npublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;\n\t\t&#x2F;&#x2F;按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示\n    List&lt;Account&gt; findAllByUsernameLike(String str);\n&#125;\n\n@Test\nvoid test() &#123;\n    repository.findAllByUsernameLike(&quot;%T%&quot;).forEach(System.out::println);\n&#125;\n\n又比如我们想同时根据用户名和ID一起查询：\n@Repository\npublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;\n\n    Account findByIdAndUsername(int id, String username);\n  &#x2F;&#x2F;可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);\n    \n    List&lt;Account&gt; findAllByUsernameLike(String str);\n&#125;\n\n@Test\nvoid test() &#123;\n    System.out.println(repository.findByIdAndUsername(1, &quot;Test&quot;));\n&#125;\n\n比如我们想判断数据库中是否存在某个ID的用户：\n@Repository\npublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;\n\n    Account findByIdAndUsername(int id, String username);\n\n    List&lt;Account&gt; findAllByUsernameLike(String str);\n\n    boolean existsAccountById(int id);\n&#125;\n\n@Test\nvoid test() &#123;\n    System.out.println(repository.existsAccountByUsername(&quot;Test&quot;));\n&#125;\n\n注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：\nCaused by: org.springframework.data.repository.query.QueryCreationException: Could not create query for public abstract  ...\n\n关联查询在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。\n\n我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：\n@Data\n@Entity\n@Table(name &#x3D; &quot;users_detail&quot;)\npublic class AccountDetail &#123;\n\n    @Column(name &#x3D; &quot;id&quot;)\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)\n    @Id\n    int id;\n\n    @Column(name &#x3D; &quot;address&quot;)\n    String address;\n\n    @Column(name &#x3D; &quot;email&quot;)\n    String email;\n\n    @Column(name &#x3D; &quot;phone&quot;)\n    String phone;\n\n    @Column(name &#x3D; &quot;real_name&quot;)\n    String realName;\n&#125;\n\n而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：\n@Data\n@Entity\n@Table(name &#x3D; &quot;users&quot;)\npublic class Account &#123;\n\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)\n    @Column(name &#x3D; &quot;id&quot;)\n    @Id\n    int id;\n\n    @Column(name &#x3D; &quot;username&quot;)\n    String username;\n\n    @Column(name &#x3D; &quot;password&quot;)\n    String password;\n\n    @JoinColumn(name &#x3D; &quot;detail_id&quot;)   &#x2F;&#x2F;指定存储外键的字段名称\n    @OneToOne    &#x2F;&#x2F;声明为一对一关系\n    AccountDetail detail;\n&#125;\n\n在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：\nHibernate: alter table users add column detail_id integer\nHibernate: create table users_detail (id integer not null auto_increment, address varchar(255), email varchar(255), phone varchar(255), real_name varchar(255), primary key (id)) engine&#x3D;InnoDB\nHibernate: alter table users add constraint FK7gb021edkxf3mdv5bs75ni6jd foreign key (detail_id) references users_detail (id)\n\n是不是感觉非常方便！都懒得去手动改表结构了。\n接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：\n@Test\nvoid pageAccount() &#123;\n    repository.findById(1).ifPresent(System.out::println);\n&#125;\n\n查询后，可以发现，得到如下结果：\nHibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, accountdet1_.id as id1_1_1_, accountdet1_.address as address2_1_1_, accountdet1_.email as email3_1_1_, accountdet1_.phone as phone4_1_1_, accountdet1_.real_name as real_nam5_1_1_ from users account0_ left outer join users_detail accountdet1_ on account0_.detail_id&#x3D;accountdet1_.id where account0_.id&#x3D;?\nAccount(id&#x3D;1, username&#x3D;Test, password&#x3D;123456, detail&#x3D;AccountDetail(id&#x3D;1, address&#x3D;四川省成都市青羊区, email&#x3D;8371289@qq.com, phone&#x3D;1234567890, realName&#x3D;本伟))\n\n也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。\n那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：\n@JoinColumn(name &#x3D; &quot;detail_id&quot;)\n@OneToOne(fetch &#x3D; FetchType.LAZY)    &#x2F;&#x2F;将获取类型改为LAZY\nAccountDetail detail;\n\n接着我们测试一下：\n@Transactional   &#x2F;&#x2F;懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭\n@Test\nvoid pageAccount() &#123;\n    repository.findById(1).ifPresent(account -&gt; &#123;\n        System.out.println(account.getUsername());   &#x2F;&#x2F;获取用户名\n        System.out.println(account.getDetail());  &#x2F;&#x2F;获取详细信息（懒加载）\n    &#125;);\n&#125;\n\n接着我们来看看控制台输出了什么：\nHibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ from users account0_ where account0_.id&#x3D;?\nTest\nHibernate: select accountdet0_.id as id1_1_0_, accountdet0_.address as address2_1_0_, accountdet0_.email as email3_1_0_, accountdet0_.phone as phone4_1_0_, accountdet0_.real_name as real_nam5_1_0_ from users_detail accountdet0_ where accountdet0_.id&#x3D;?\nAccountDetail(id&#x3D;1, address&#x3D;四川省成都市青羊区, email&#x3D;8371289@qq.com, phone&#x3D;1234567890, realName&#x3D;卢本)\n\n可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。\n那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：\n@JoinColumn(name &#x3D; &quot;detail_id&quot;)\n@OneToOne(fetch &#x3D; FetchType.LAZY, cascade &#x3D; CascadeType.ALL) &#x2F;&#x2F;设置关联操作为ALL\nAccountDetail detail;\n\n\nALL：所有操作都进行关联操作\nPERSIST：插入操作时才进行关联操作\nREMOVE：删除操作时才进行关联操作\nMERGE：修改操作时才进行关联操作\n\n可以多个并存，接着我们来进行一下测试：\n@Test\nvoid addAccount()&#123;\n    Account account &#x3D; new Account();\n    account.setUsername(&quot;Nike&quot;);\n    account.setPassword(&quot;123456&quot;);\n    AccountDetail detail &#x3D; new AccountDetail();\n    detail.setAddress(&quot;重庆市渝中区解放碑&quot;);\n    detail.setPhone(&quot;1234567890&quot;);\n    detail.setEmail(&quot;73281937@qq.com&quot;);\n    detail.setRealName(&quot;张三&quot;);\n  \taccount.setDetail(detail);\n    account &#x3D; repository.save(account);\n    System.out.println(&quot;插入时，自动生成的主键ID为：&quot;+account.getId()+&quot;，外键ID为：&quot;+account.getDetail().getId());\n&#125;\n\n可以看到日志结果：\nHibernate: insert into users_detail (address, email, phone, real_name) values (?, ?, ?, ?)\nHibernate: insert into users (detail_id, password, username) values (?, ?, ?)\n插入时，自动生成的主键ID为：6，外键ID为：3\n\n结束后会发现数据库中两张表都同时存在数据。\n接着我们来看一对多关联，比如每个用户的成绩信息：\n@JoinColumn(name &#x3D; &quot;uid&quot;)  &#x2F;&#x2F;注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键\n@OneToMany(fetch &#x3D; FetchType.LAZY, cascade &#x3D; CascadeType.REMOVE)   &#x2F;&#x2F;在移除Account时，一并移除所有的成绩信息，依然使用懒加载\nList&lt;Score&gt; scoreList;\n\n@Data\n@Entity\n@Table(name &#x3D; &quot;users_score&quot;)   &#x2F;&#x2F;成绩表，注意只存成绩，不存学科信息，学科信息id做外键\npublic class Score &#123;\n\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)\n    @Column(name &#x3D; &quot;id&quot;)\n    @Id\n    int id;\n\n    @OneToOne   &#x2F;&#x2F;一对一对应到学科上\n    @JoinColumn(name &#x3D; &quot;cid&quot;)\n    Subject subject;\n\n    @Column(name &#x3D; &quot;socre&quot;)\n    double score;\n\n    @Column(name &#x3D; &quot;uid&quot;)\n    int uid;\n&#125;\n\n@Data\n@Entity\n@Table(name &#x3D; &quot;subjects&quot;)   &#x2F;&#x2F;学科信息表\npublic class Subject &#123;\n\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)\n    @Column(name &#x3D; &quot;cid&quot;)\n    @Id\n    int cid;\n\n    @Column(name &#x3D; &quot;name&quot;)\n    String name;\n\n    @Column(name &#x3D; &quot;teacher&quot;)\n    String teacher;\n\n    @Column(name &#x3D; &quot;time&quot;)\n    int time;\n&#125;\n\n在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：\n@Transactional\n@Test\nvoid test() &#123;\n    repository.findById(1).ifPresent(account -&gt; &#123;\n        account.getScoreList().forEach(System.out::println);\n    &#125;);\n&#125;\n\n成功得到用户所有的成绩信息，包括得分和学科信息。\n同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：\n@ManyToOne(fetch &#x3D; FetchType.LAZY)\n@JoinColumn(name &#x3D; &quot;tid&quot;)   &#x2F;&#x2F;存储教师ID的字段，和一对一是一样的，也会当前表中创个外键\nTeacher teacher;\n\n接着就是教师实体类了：\n@Data\n@Entity\n@Table(name &#x3D; &quot;teachers&quot;)\npublic class Teacher &#123;\n\n    @Column(name &#x3D; &quot;id&quot;)\n    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)\n    @Id\n    int id;\n\n    @Column(name &#x3D; &quot;name&quot;)\n    String name;\n\n    @Column(name &#x3D; &quot;sex&quot;)\n    String sex;\n&#125;\n\n最后我们再进行一下测试：\n@Transactional\n@Test\nvoid test() &#123;\n    repository.findById(3).ifPresent(account -&gt; &#123;\n        account.getScoreList().forEach(score -&gt; &#123;\n            System.out.println(&quot;课程名称：&quot;+score.getSubject().getName());\n            System.out.println(&quot;得分：&quot;+score.getScore());\n            System.out.println(&quot;任课教师：&quot;+score.getSubject().getTeacher().getName());\n        &#125;);\n    &#125;);\n&#125;\n\n成功得到多对一的教师信息。\n最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：\n@ManyToMany(fetch &#x3D; FetchType.LAZY)   &#x2F;&#x2F;多对多场景\n@JoinTable(name &#x3D; &quot;teach_relation&quot;,     &#x2F;&#x2F;多对多中间关联表\n        joinColumns &#x3D; @JoinColumn(name &#x3D; &quot;cid&quot;),    &#x2F;&#x2F;当前实体主键在关联表中的字段名称\n        inverseJoinColumns &#x3D; @JoinColumn(name &#x3D; &quot;tid&quot;)   &#x2F;&#x2F;教师实体主键在关联表中的字段名称\n)\nList&lt;Teacher&gt; teacher;\n\n接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。\nJPQL自定义SQL语句虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。\n使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是JPQL语言，与原生SQL语句很类似，但是它是面向对象的，当然我们也可以编写原生SQL语句。\n比如我们要更新用户表中指定ID用户的密码：\n@Repository\npublic interface AccountRepository extends JpaRepository&lt;Account, Integer&gt; &#123;\n\n    @Transactional    &#x2F;&#x2F;DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下\n    @Modifying     &#x2F;&#x2F;表示这是一个DML操作\n    @Query(&quot;update Account set password &#x3D; ?2 where id &#x3D; ?1&quot;) &#x2F;&#x2F;这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数\n    int updatePasswordById(int id, String newPassword);\n&#125;\n\n@Test\nvoid updateAccount()&#123;\n    repository.updatePasswordById(1, &quot;654321&quot;);\n&#125;\n\n现在我想使用原生SQL来实现根据用户名称修改密码：\n@Transactional\n@Modifying\n@Query(value &#x3D; &quot;update users set password &#x3D; :pwd where username &#x3D; :name&quot;, nativeQuery &#x3D; true) &#x2F;&#x2F;使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。\nint updatePasswordByUsername(@Param(&quot;name&quot;) String username,   &#x2F;&#x2F;我们可以使用@Param指定名称\n                             @Param(&quot;pwd&quot;) String newPassword);\n\n@Test\nvoid updateAccount()&#123;\n    repository.updatePasswordByUsername(&quot;Admin&quot;, &quot;654321&quot;);\n&#125;\n\n通过编写原生SQL，在一定程度上弥补了SQL不可控的问题。\n虽然JPA能够为我们带来非常便捷的开发体验，但是正式因为太便捷了，保姆级的体验有时也会适得其反，可能项目开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，而JPA的劣势并没有太明显地体现出来。\n有关Mybatis和JPA的对比，可以参考：https://blog.csdn.net/u010253246/article/details/105731204\n\nExtra. 前后端分离跨域处理我们的项目已经处于前后端分离状态了，那么前后端分离状态和我们之前的状态有什么区别的呢？\n\n不分离：前端页面看到的都是由后端控制，由后端渲染页面或重定向，后端需要控制前端的展示，前端与后端的耦合度很高。比如我们之前都是使用后端来执行重定向操作或是使用Thymeleaf来填充数据，而最终返回的是整个渲染好的页。\n\n\n\n分离：后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端通过JS等进行动态数据填充和渲染。这样后端只返回JSON数据，前端处理JSON数据并展示，这样前后端的职责就非常明确了。\n\n\n实现前后端分离有两种方案，一种是直接放入SpringBoot的资源文件夹下，但是这样实际上还是在依靠SpringBoot内嵌的Tomcat服务器进行页面和静态资源的发送，我们现在就是这种方案。\n另一种方案就是直接将所有的页面和静态资源单独放到代理服务器上（如Nginx），这样我们后端服务器就不必再处理静态资源和页面了，专心返回数据即可，而前端页面就需要访问另一个服务器来获取，虽然逻辑和明确，但是这样会出现跨域问题，实际上就是我们之前所说的跨站请求伪造，为了防止这种不安全的行为发生，所以对异步请求会进行一定的限制。\n这里，我们将前端页面和后端页面直接分离进行测试，在登陆时得到如下错误：\nAccess to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;auth&#x2F;login&#39; from origin &#39;http:&#x2F;&#x2F;localhost:63342&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.\n\n可以很清楚地看到，在Ajax发送异步请求时，我们的请求被阻止，原因是在响应头中没有包含Access-Control-Allow-Origin，也就表示，如果服务端允许跨域请求，那么会在响应头中添加一个Access-Control-Allow-Origin字段，如果不允许跨域，就像现在这样。那么，什么才算是跨域呢：\n\n请求协议如http、https不同\n请求的地址&#x2F;域名不同\n端口不同\n\n因为我们现在相当于前端页面访问的是静态资源服务器，而后端数据是由我们的SpringBoot项目提供，它们是两个不同的服务器，所以在垮服务器请求资源时，会被判断为存在安全风险。\n但是现在，由于我们前后端是分离状态，我们希望的是能够实现跨域请求，这时我们就需要添加一个过滤器来处理跨域问题：\n@Bean\npublic CorsFilter corsFilter() &#123;\n    &#x2F;&#x2F;创建CorsConfiguration对象后添加配置\n    CorsConfiguration config &#x3D; new CorsConfiguration();\n    &#x2F;&#x2F;设置放行哪些原始域，这里直接设置为所有\n    config.addAllowedOriginPattern(&quot;*&quot;);\n  \t&#x2F;&#x2F;你可以单独设置放行哪些原始域 config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;localhost:2222&quot;);\n    &#x2F;&#x2F;放行哪些原始请求头部信息\n    config.addAllowedHeader(&quot;*&quot;);\n    &#x2F;&#x2F;放行哪些请求方式，*代表所有\n    config.addAllowedMethod(&quot;*&quot;);\n    &#x2F;&#x2F;是否允许发送Cookie，必须要开启，因为我们的JSESSIONID需要在Cookie中携带\n    config.setAllowCredentials(true);\n    &#x2F;&#x2F;映射路径\n    UrlBasedCorsConfigurationSource corsConfigurationSource &#x3D; new UrlBasedCorsConfigurationSource();\n    corsConfigurationSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);\n    &#x2F;&#x2F;返回CorsFilter\n    return new CorsFilter(corsConfigurationSource);\n&#125;\n\n这样，我们的SpringBoot项目就支持跨域访问了，接着我们再来尝试进行登陆，可以发现已经能够正常访问了，并且响应头中包含了以下信息：\nVary: Access-Control-Request-Method\nVary: Access-Control-Request-Headers\nAccess-Control-Allow-Origin: http:&#x2F;&#x2F;localhost:63342\nAccess-Control-Expose-Headers: *\nAccess-Control-Allow-Credentials: true\n\n可以看到我们当前访问的原始域已经被放行了。\n但是还有一个问题，我们的Ajax请求中没有携带Cookie信息（这个按理说属于前端知识了）这里我们稍微改一下，不然我们的请求无法确认身份：\nfunction get(url, success)&#123;\n    $.ajax(&#123;\n        type: &quot;get&quot;,\n        url: url,\n        async: true,\n        dataType: &#39;json&#39;,\n        xhrFields: &#123;\n            withCredentials: true\n        &#125;,\n        success: success\n    &#125;);\n&#125;\n\nfunction post(url, data, success)&#123;\n    $.ajax(&#123;\n        type: &quot;post&quot;,\n        url: url,\n        async: true,\n        data: data,\n        dataType: &#39;json&#39;,\n        xhrFields: &#123;\n            withCredentials: true\n        &#125;,\n        success: success\n    &#125;);\n&#125;\n\n添加两个封装好的方法，并且将withCredentials开启，这样在发送异步请求时，就会携带Cookie信息了。\n 在学习完成Linux之后，我们会讲解如何在Linux服务器上部署Nginx反向代理服务器。\n\n接口管理：Swagger在前后端分离项目中，前端人员需要知道我们后端会提供什么数据，根据后端提供的数据来进行前端页面渲染（在之前我们也演示过）这个时候，我们就需要编写一个API文档，以便前端人员随时查阅。\n但是这样的一个文档，我们也不可能单独写一个项目去进行维护，并且随着我们的后端项目不断更新，文档也需要跟随更新，这显然是很麻烦的一件事情，那么有没有一种比较好的解决方案呢？\n当然有，那就是丝袜哥：Swagger\n走进SwaggerSwagger的主要功能如下：\n\n支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。\n提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。\n\n结合Spring框架（Spring-fox），Swagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。依赖如下：\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springfox-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.0.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nSpringBoot 2.6以上版本修改了路径匹配规则，但是Swagger3还不支持，这里换回之前的，不然启动直接报错：\nspring:\n\tmvc:\n\t\tpathmatch:\n      matching-strategy: ant_path_matcher\n\n项目启动后，我们可以直接打开：http://localhost:8080/swagger-ui/index.html，这个页面（要是觉得丑，UI是可以换的，支持第三方）会显示所有的API文档，包括接口的路径、支持的方法、接口的描述等，并且我们可以直接对API接口进行测试，非常方便。\n我们可以创建一个配置类去配置页面的相关信息：\n@Configuration\npublic class SwaggerConfiguration &#123;\n\n    @Bean\n    public Docket docket() &#123;\n        return new Docket(DocumentationType.OAS_30).apiInfo(\n                new ApiInfoBuilder()\n                        .contact(new Contact(&quot;你的名字&quot;, &quot;https:&#x2F;&#x2F;www.bilibili.com&quot;, &quot;javastudy111*@163.com&quot;))\n                        .title(&quot;图书管理系统 - 在线API接口文档&quot;)\n                        .build()\n        );\n    &#125;\n&#125;\n\n接口信息配置虽然Swagger的UI界面已经可以很好地展示后端提供的接口信息了，但是非常的混乱，我们来看看如何配置接口的一些描述信息。\n首先我们的页面中完全不需要显示ErrorController相关的API，所以我们配置一下选择哪些Controller才会生成API信息：\n@Bean\npublic Docket docket() &#123;\n    ApiInfo info &#x3D; new ApiInfoBuilder()\n            .contact(new Contact(&quot;你的名字&quot;, &quot;https:&#x2F;&#x2F;www.bilibili.com&quot;, &quot;javastudy111@163.com&quot;))\n            .title(&quot;图书管理系统 - 在线API接口文档&quot;)\n            .description(&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;)\n            .build();\n    return new Docket(DocumentationType.OAS_30)\n            .apiInfo(info)\n            .select()       &#x2F;&#x2F;对项目中的所有API接口进行选择\n            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;))\n            .build();\n&#125;\n\n接着我们来看看如何为一个Controller编写API描述信息：\n@Api(tags &#x3D; &quot;账户验证接口&quot;, description &#x3D; &quot;包括用户登录、注册、验证码请求等操作。&quot;)\n@RestController\n@RequestMapping(&quot;&#x2F;api&#x2F;auth&quot;)\npublic class AuthApiController &#123;\n\n我们可以直接在类名称上面添加@Api注解，并填写相关信息，来为当前的Controller设置描述信息。\n接着我们可以为所有的请求映射配置描述信息：\n@ApiResponses(&#123;\n        @ApiResponse(code &#x3D; 200, message &#x3D; &quot;邮件发送成功&quot;),  \n        @ApiResponse(code &#x3D; 500, message &#x3D; &quot;邮件发送失败&quot;)   &#x2F;&#x2F;不同返回状态码描述\n&#125;)\n@ApiOperation(&quot;请求邮件验证码&quot;)   &#x2F;&#x2F;接口描述\n@GetMapping(&quot;&#x2F;verify-code&quot;)\npublic RestBean&lt;Void&gt; verifyCode(@ApiParam(&quot;邮箱地址&quot;)   &#x2F;&#x2F;请求参数的描述\n                                 @RequestParam(&quot;email&quot;) String email)&#123;\n\n@ApiIgnore     &#x2F;&#x2F;忽略此请求映射\n@PostMapping(&quot;&#x2F;login-success&quot;)\npublic RestBean&lt;Void&gt; loginSuccess()&#123;\n    return new RestBean&lt;&gt;(200, &quot;登陆成功&quot;);\n&#125;\n\n我们也可以为实体类配置相关的描述信息：\n@Data\n@ApiModel(description &#x3D; &quot;响应实体封装类&quot;)\n@AllArgsConstructor\npublic class RestBean&lt;T&gt; &#123;\n\n    @ApiModelProperty(&quot;状态码&quot;)\n    int code;\n    @ApiModelProperty(&quot;状态码描述&quot;)\n    String reason;\n    @ApiModelProperty(&quot;数据实体&quot;)\n    T data;\n\n    public RestBean(int code, String reason) &#123;\n        this.code &#x3D; code;\n        this.reason &#x3D; reason;\n    &#125;\n&#125;\n\n这样，我们就可以在文档中查看实体类简介以及各个属性的介绍了。\n最后我们再配置一下多环境：\n&lt;profiles&gt;\n    &lt;profile&gt;\n        &lt;id&gt;dev&lt;&#x2F;id&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n        &lt;properties&gt;\n            &lt;environment&gt;dev&lt;&#x2F;environment&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n    &lt;profile&gt;\n        &lt;id&gt;prod&lt;&#x2F;id&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;false&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n        &lt;properties&gt;\n            &lt;environment&gt;prod&lt;&#x2F;environment&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n&lt;&#x2F;profiles&gt;\n\n&lt;resources&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n        &lt;excludes&gt;\n            &lt;exclude&gt;application*.yaml&lt;&#x2F;exclude&gt;\n        &lt;&#x2F;excludes&gt;\n    &lt;&#x2F;resource&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n        &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;includes&gt;\n            &lt;include&gt;application.yaml&lt;&#x2F;include&gt;\n            &lt;include&gt;application-$&#123;environment&#125;.yaml&lt;&#x2F;include&gt;\n        &lt;&#x2F;includes&gt;\n    &lt;&#x2F;resource&gt;\n&lt;&#x2F;resources&gt;\n\n首先在Maven中添加两个环境，接着我们配置一下不同环境的配置文件：\n  jpa:\n    show-sql: false\n    hibernate:\n      ddl-auto: update\nspringfox:\n  documentation:\n    enabled: false\n\n在生产环境下，我们选择不开启Swagger文档以及JPA的数据库操作日志，这样我们就可以根据情况选择两套环境了。\n","slug":"SpringBoot笔记（四）","date":"2022-03-05T14:39:01.865Z","categories_index":"SpringBoot笔记","tags_index":"SpringBoot笔记","author_index":"YangChao"},{"id":"25a60a06ed42cd757ab0410c2846114a","title":"SpringBoot笔记（三）","content":"\nRedis数据库灵魂拷问：不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？\n在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。\n因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。\nNoSQL概论NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它：\n\n不保证关系数据的ACID特性\n并不遵循SQL标准\n消除数据之间关联性\n\n乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势：\n\n远超传统关系型数据库的性能\n非常易于扩展\n数据模型更加灵活\n高可用\n\n这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！\nNoSQL数据库分为以下几种：\n\n键值存储数据库：所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。\n列存储数据库：这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。\n文档型数据库：它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。\n图形数据库：利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。\n\n其中我们要学习的Redis数据库，就是一个开源的键值存储数据库，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。\n实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。\nRedis安装和部署我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找：\n\n官网地址：https://redis.io\nGitHub Windows版本维护地址：https://github.com/tporadowski/redis/releases\n\n\n基本操作在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过insert语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据）\n在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。\n我们可以通过select语句进行切换：\nselect 序号;\n\n数据操作我们来看看，如何向Redis数据库中添加数据：\nset &lt;key&gt; &lt;value&gt;\n-- 一次性多个\nmset [&lt;key&gt; &lt;value&gt;]...\n\n所有存入的数据默认会以字符串的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据：\n-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw\nset user:info:用户ID:name lbw\n\n我们可以通过键值获取存入的值：\nget &lt;key&gt;\n\n你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定：\nset &lt;key&gt; &lt;value&gt; EX 秒\nset &lt;key&gt; &lt;value&gt; PX 毫秒\n\n当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间：\nexpire &lt;key&gt; 秒\n\n通过下面的命令来查询某个键值对的过期时间还剩多少：\nttl &lt;key&gt;\n-- 毫秒显示\npttl &lt;key&gt;\n-- 转换为永久\npersist &lt;key&gt;\n\n那么当我们想直接删除这个数据时呢？直接使用：\ndel &lt;key&gt;...\n\n删除命令可以同时拼接多个键值一起删除。\n当我们想要查看数据库中所有的键值时：\nkeys *\n\n也可以查询某个键是否存在：\nexists &lt;key&gt;...\n\n还可以随机拿一个键：\nrandomkey\n\n我们可以将一个数据库中的内容移动到另一个数据库中：\nmove &lt;key&gt; 数据库序号\n\n修改一个键为另一个键：\nrename &lt;key&gt; &lt;新的名称&gt;\n-- 下面这个会检查新的名称是否已经存在\nrenamex &lt;key&gt; &lt;新的名称&gt;\n\n如果存放的数据是一个数字，我们还可以对其进行自增自减操作：\n-- 等价于a &#x3D; a + 1\nincr &lt;key&gt;\n-- 等价于a &#x3D; a + b\nincrby &lt;key&gt; b\n-- 等价于a &#x3D; a - 1\ndecr &lt;key&gt;\n\n最后就是查看值的数据类型：\ntype &lt;key&gt;\n\nRedis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。\n数据类型介绍一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。\nHash这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样：\n#Redis默认存String类似于这样：\nMap&lt;String, String&gt; hash &#x3D; new HashMap&lt;&gt;();\n#Redis存Hash类型的数据类似于这样：\nMap&lt;String, Map&lt;String, String&gt;&gt; hash &#x3D; new HashMap&lt;&gt;();\n\n它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。\n我们可以像这样来添加一个Hash类型的数据：\nhset &lt;key&gt; [&lt;字段&gt; &lt;值&gt;]...\n\n我们可以直接获取：\nhget &lt;key&gt; &lt;字段&gt;\n-- 如果想要一次性获取所有的字段和值\nhgetall &lt;key&gt;\n\n同样的，我们也可以判断某个字段是否存在：\nhexists &lt;key&gt; &lt;字段&gt;\n\n删除Hash中的某个字段：\nhdel &lt;key&gt;\n\n我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个h，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。\n我们现在想要知道Hash中一共存了多少个键值对：\nhlen &lt;key&gt;\n\n我们也可以一次性获取所有字段的值：\nhvals &lt;key&gt;\n\n唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。\nList我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。\n我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：\n-- 向列表头部添加元素\nlpush &lt;key&gt; &lt;element&gt;...\n-- 向列表尾部添加元素\nrpush &lt;key&gt; &lt;element&gt;...\n-- 在指定元素前面&#x2F;后面插入元素\nlinsert &lt;key&gt; before&#x2F;after &lt;指定元素&gt; &lt;element&gt;\n\n同样的，获取元素也非常简单：\n-- 根据下标获取元素\nlindex &lt;key&gt; &lt;下标&gt;\n-- 获取并移除头部元素\nlpop &lt;key&gt;\n-- 获取并移除尾部元素\nrpop &lt;key&gt;\n-- 获取指定范围内的\nlrange &lt;key&gt; start stop\n\n注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）:\n-- 获取列表a中的全部元素\nlrange a 0 -1\n\n没想到吧，push和pop还能连着用呢：\n-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素\nrpoplpush 当前数组 目标数组\n\n它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作：\n-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行\nblpop &lt;key&gt;... timeout\n\nSet和SortedSetSet集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。\n向Set中添加一个或多个值：\nsadd &lt;key&gt; &lt;value&gt;...\n\n查看Set集合中有多少个值：\nscard &lt;key&gt;\n\n判断集合中是否包含：\n-- 是否包含指定值\nsismember &lt;key&gt; &lt;value&gt;\n-- 列出所有值\nsmembers &lt;key&gt;\n\n集合之间的运算：\n-- 集合之间的差集\nsdiff &lt;key1&gt; &lt;key2&gt;\n-- 集合之间的交集\nsinter &lt;key1&gt; &lt;key2&gt;\n-- 求并集\nsunion &lt;key1&gt; &lt;key2&gt;\n-- 将集合之间的差集存到目标集合中\nsdiffstore 目标 &lt;key1&gt; &lt;key2&gt;\n-- 同上\nsinterstore 目标 &lt;key1&gt; &lt;key2&gt;\n-- 同上\nsunionstore 目标 &lt;key1&gt; &lt;key2&gt;\n\n移动指定值到另一个集合中：\nsmove &lt;key&gt; 目标 value \n\n移除操作：\n-- 随机移除一个幸运儿\nspop &lt;key&gt;\n-- 移除指定\nsrem &lt;key&gt; &lt;value&gt;...\n\n那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。\n我们可以添加一个带分数的值：\nzadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]...\n\n同样的：\n-- 查询有多少个值\nzcard &lt;key&gt;\n-- 移除\nzrem &lt;key&gt; &lt;value&gt;...\n-- 获取区间内的所有\nzrange &lt;key&gt; start stop\n\n由于所有的值都有一个分数，我们也可以根据分数段来获取：\n-- 通过分数段查看\nzrangebyscore &lt;key&gt; start stop [withscores] [limit]\n-- 统计分数段内的数量\nzcount &lt;key&gt;  start stop\n-- 根据分数获取指定值的排名\nzrank &lt;key&gt; &lt;value&gt;\n\nhttps://www.jianshu.com/p/32b9fe8c20e1\n有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。\n\n持久化我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。\n这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。\n持久化的实现方式有两种方案：一种是直接保存当前已经存储的数据，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的所有过程，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。\nRDBRDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令：\nsave\n-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存\nbgsave\n\n执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：\nshutdown\n\n重启后可以看到数据依然存在。\n\n虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。\n我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作：\nsave 300 10 # 300秒（5分钟）内有10个写入\nsave 60 10000 # 60秒（1分钟）内有10000个写入\n\n配置的save使用的都是bgsave后台执行。\nAOF虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。\n而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。\n\n但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：\n\nalways：每次执行写操作都会保存一次\neverysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据\nno：看系统心情保存\n\n可以在配置文件中配置：\n# 注意得改成也是\nappendonly yes\n\n# appendfsync always\nappendfsync everysec\n# appendfsync no\n\n重启服务器后，可以看到服务器目录下多了一个appendonly.aof文件，存储的就是我们执行的命令。\n AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。\nRedis有一个AOF重写机制进行优化，比如我们执行了这样的语句：\nlpush test 666\nlpush test 777\nlpush test 888\n\n实际上用一条语句也可以实现：\nlpush test 666 777 888\n\n正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。\n我们可以输入命令来手动执行重写操作：\nbgrewriteaof\n\n或是在配置文件中配置自动重写：\n# 百分比计算，这里不多介绍\nauto-aof-rewrite-percentage 100\n# 当达到这个大小时，触发自动重写\nauto-aof-rewrite-min-size 64mb\n\n至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结：\n\nAOF：\n优点：存储速度快、消耗资源少、支持实时存储\n缺点：加载速度慢、数据体积大\n\n\nRDB：\n优点：加载速度快、数据体积小\n缺点：存储速度慢大量消耗资源、会发生数据丢失\n\n\n\n\n事务和锁机制和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。\n我们可以使用命令来直接开启事务：\nmulti\n\n当我们输入完所有要执行的命令时，可以使用命令来立即执行事务：\nexec\n\n我们也可以中途取消事务：\ndiscard\n\n实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。\n锁又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。\n虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？\n\n悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。\n乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。\n\nRedis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：\nwatch\n\n我们可以开两个客户端进行测试。\n取消监视可以使用：\nunwatch\n\n至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。\n\n使用Java与Redis交互既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？\n这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖：\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;4.0.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n基本操作我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;创建Jedis对象\n    Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;, 6379);\n  \t\n  \t&#x2F;&#x2F;使用之后关闭连接\n  \tjedis.close();\n&#125;\n\n通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如：\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;直接使用try-with-resouse，省去close\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.set(&quot;test&quot;, &quot;lbwnb&quot;);   &#x2F;&#x2F;等同于 set test lbwnb 命令\n        System.out.println(jedis.get(&quot;test&quot;));  &#x2F;&#x2F;等同于 get test 命令\n    &#125;\n&#125;\n\nHash类型的数据也是这样：\npublic static void main(String[] args) &#123;\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.hset(&quot;hhh&quot;, &quot;name&quot;, &quot;sxc&quot;);   &#x2F;&#x2F;等同于 hset hhh name sxc\n        jedis.hset(&quot;hhh&quot;, &quot;sex&quot;, &quot;19&quot;);    &#x2F;&#x2F;等同于 hset hhh age 19\n        jedis.hgetAll(&quot;hhh&quot;).forEach((k, v) -&gt; System.out.println(k+&quot;: &quot;+v));\n    &#125;\n&#125;\n\n我们接着来看看列表操作：\npublic static void main(String[] args) &#123;\n    try(Jedis jedis &#x3D; new Jedis(&quot;192.168.10.3&quot;, 6379))&#123;\n        jedis.lpush(&quot;mylist&quot;, &quot;111&quot;, &quot;222&quot;, &quot;333&quot;);  &#x2F;&#x2F;等同于 lpush mylist 111 222 333 命令\n        jedis.lrange(&quot;mylist&quot;, 0, -1)\n                .forEach(System.out::println);    &#x2F;&#x2F;等同于 lrange mylist 0 -1\n    &#125;\n&#125;\n\n实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。\nSpringBoot整合Redis我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nstarter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：\nspring:\n  redis:\n  \t#Redis服务器地址\n    host: 192.168.10.3\n    #端口\n    port: 6379\n    #使用几号数据库\n    database: 0\n\nstarter已经给我们提供了两个默认的模板类：\n@Configuration(\n    proxyBeanMethods &#x3D; false\n)\n@ConditionalOnClass(&#123;RedisOperations.class&#125;)\n@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)\n@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)\npublic class RedisAutoConfiguration &#123;\n    public RedisAutoConfiguration() &#123;\n    &#125;\n\n    @Bean\n    @ConditionalOnMissingBean(\n        name &#x3D; &#123;&quot;redisTemplate&quot;&#125;\n    )\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    &#125;\n\n    @Bean\n    @ConditionalOnMissingBean\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;\n        return new StringRedisTemplate(redisConnectionFactory);\n    &#125;\n&#125;\n\n那么如何去使用这两个模板类呢？我们可以直接注入StringRedisTemplate来使用模板：\n@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n    @Autowired\n    StringRedisTemplate template;\n\n    @Test\n    void contextLoads() &#123;\n        ValueOperations&lt;String, String&gt; operations &#x3D; template.opsForValue();\n        operations.set(&quot;c&quot;, &quot;xxxxx&quot;);   &#x2F;&#x2F;设置值\n        System.out.println(operations.get(&quot;c&quot;));   &#x2F;&#x2F;获取值\n      \t\n        template.delete(&quot;c&quot;);    &#x2F;&#x2F;删除键\n        System.out.println(template.hasKey(&quot;c&quot;));   &#x2F;&#x2F;判断是否包含键\n    &#125;\n\n&#125;\n\n实际上所有的值的操作都被封装到了ValueOperations对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。\n我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n@Service\npublic class RedisService &#123;\n\n    @Resource\n    StringRedisTemplate template;\n\n    @PostConstruct\n    public void init()&#123;\n        template.setEnableTransactionSupport(true);   &#x2F;&#x2F;需要开启事务\n    &#125;\n\n    @Transactional    &#x2F;&#x2F;需要添加此注解\n    public void test()&#123;\n        template.multi();\n        template.opsForValue().set(&quot;d&quot;, &quot;xxxxx&quot;);\n        template.exec();\n    &#125;\n&#125;\n\n我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储：\n@Test\nvoid contextLoad2() &#123;\n    &#x2F;&#x2F;注意Student需要实现序列化接口才能存入Redis\n    template.opsForValue().set(&quot;student&quot;, new Student());\n    System.out.println(template.opsForValue().get(&quot;student&quot;));\n&#125;\n\n\n使用Redis做缓存我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。\nMybatis二级缓存还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。\n\n我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下：\n&#x2F;&#x2F;实现Mybatis的Cache接口\npublic class RedisMybatisCache implements Cache &#123;\n\n    private final String id;\n    private static RedisTemplate&lt;Object, Object&gt; template;\n\n   \t&#x2F;&#x2F;注意构造方法必须带一个String类型的参数接收id\n    public RedisMybatisCache(String id)&#123;\n        this.id &#x3D; id;\n    &#125;\n\n  \t&#x2F;&#x2F;初始化时通过配置类将RedisTemplate给过来\n    public static void setTemplate(RedisTemplate&lt;Object, Object&gt; template) &#123;\n        RedisMybatisCache.template &#x3D; template;\n    &#125;\n\n    @Override\n    public String getId() &#123;\n        return id;\n    &#125;\n\n    @Override\n    public void putObject(Object o, Object o1) &#123;\n      \t&#x2F;&#x2F;这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间\n        template.opsForValue().set(o, o1, 60, TimeUnit.SECONDS);\n    &#125;\n\n    @Override\n    public Object getObject(Object o) &#123;\n      \t&#x2F;&#x2F;这里根据Key直接从Redis数据库中获取值即可\n        return template.opsForValue().get(o);\n    &#125;\n\n    @Override\n    public Object removeObject(Object o) &#123;\n      \t&#x2F;&#x2F;根据Key删除\n        return template.delete(o);\n    &#125;\n\n    @Override\n    public void clear() &#123;\n      \t&#x2F;&#x2F;由于template中没封装清除操作，只能通过connection来执行\n\t\t\t\ttemplate.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;\n          \t&#x2F;&#x2F;通过connection对象执行清空操作\n            connection.flushDb();\n            return null;\n        &#125;);\n    &#125;\n\n    @Override\n    public int getSize() &#123;\n      \t&#x2F;&#x2F;这里也是使用connection对象来获取当前的Key数量\n        return template.execute(RedisServerCommands::dbSize).intValue();\n    &#125;\n&#125;\n\n缓存类编写完成后，我们接着来编写配置类：\n@Configuration\npublic class MainConfiguration &#123;\n    @Resource\n    RedisTemplate&lt;Object, Object&gt; template;\n\n    @PostConstruct\n    public void init()&#123;\n      \t&#x2F;&#x2F;把RedisTemplate给到RedisMybatisCache\n        RedisMybatisCache.setTemplate(template);\n    &#125;\n&#125;\n\n最后我们在Mapper上启用此缓存即可：\n&#x2F;&#x2F;只需要修改缓存实现类implementation为我们的RedisMybatisCache即可\n@CacheNamespace(implementation &#x3D; RedisMybatisCache.class)\n@Mapper\npublic interface MainMapper &#123;\n\n    @Select(&quot;select name from student where sid &#x3D; 1&quot;)\n    String getSid();\n&#125;\n\n最后我们提供一个测试用例来查看当前的二级缓存是否生效：\n@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n\n    @Resource\n    MainMapper mapper;\n\n    @Test\n    void contextLoads() &#123;\n        System.out.println(mapper.getSid());\n        System.out.println(mapper.getSid());\n        System.out.println(mapper.getSid());\n    &#125;\n\n&#125;\n\n手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。\nToken持久化存储我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个：\n&#x2F;&#x2F;实现PersistentTokenRepository接口\n@Component\npublic class RedisTokenRepository implements PersistentTokenRepository &#123;\n  \t&#x2F;&#x2F;Key名称前缀，用于区分\n    private final static String REMEMBER_ME_KEY &#x3D; &quot;spring:security:rememberMe:&quot;;\n    @Resource\n    RedisTemplate&lt;Object, Object&gt; template;\n\n    @Override\n    public void createNewToken(PersistentRememberMeToken token) &#123;\n      \t&#x2F;&#x2F;这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除\n        template.opsForValue().set(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), token.getSeries());\n        template.expire(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), 1, TimeUnit.DAYS);\n        this.setToken(token);\n    &#125;\n\n  \t&#x2F;&#x2F;先获取，然后修改创建一个新的，再放入\n    @Override\n    public void updateToken(String series, String tokenValue, Date lastUsed) &#123;\n        PersistentRememberMeToken token &#x3D; this.getToken(series);\n        if(token !&#x3D; null)\n           this.setToken(new PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed));\n    &#125;\n\n    @Override\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) &#123;\n        return this.getToken(seriesId);\n    &#125;\n\n  \t&#x2F;&#x2F;通过username找seriesId直接删除这两个\n    @Override\n    public void removeUserTokens(String username) &#123;\n        String series &#x3D; (String) template.opsForValue().get(REMEMBER_ME_KEY+&quot;username:&quot;+username);\n        template.delete(REMEMBER_ME_KEY+series);\n        template.delete(REMEMBER_ME_KEY+&quot;username:&quot;+username);\n    &#125;\n\n  \n  \t&#x2F;&#x2F;由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作\n    private PersistentRememberMeToken getToken(String series)&#123;\n        Map&lt;Object, Object&gt; map &#x3D; template.opsForHash().entries(REMEMBER_ME_KEY+series);\n        if(map.isEmpty()) return null;\n        return new PersistentRememberMeToken(\n                (String) map.get(&quot;username&quot;),\n                (String) map.get(&quot;series&quot;),\n                (String) map.get(&quot;tokenValue&quot;),\n                new Date(Long.parseLong((String) map.get(&quot;date&quot;))));\n    &#125;\n\n    private void setToken(PersistentRememberMeToken token)&#123;\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;username&quot;, token.getUsername());\n        map.put(&quot;series&quot;, token.getSeries());\n        map.put(&quot;tokenValue&quot;, token.getTokenValue());\n        map.put(&quot;date&quot;, &quot;&quot;+token.getDate().getTime());\n        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);\n        template.expire(REMEMBER_ME_KEY+token.getSeries(), 1, TimeUnit.DAYS);\n    &#125;\n&#125;\n\n接着把验证Service实现了：\n@Service\npublic class AuthService implements UserDetailsService &#123;\n\n    @Resource\n    UserMapper mapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        Account account &#x3D; mapper.getAccountByUsername(username);\n        if(account &#x3D;&#x3D; null) throw new UsernameNotFoundException(&quot;&quot;);\n        return User\n                .withUsername(username)\n                .password(account.getPassword())\n                .roles(account.getRole())\n                .build();\n    &#125;\n&#125;\n\nMapper也安排上：\n@Data\npublic class Account implements Serializable &#123;\n    int id;\n    String username;\n    String password;\n    String role;\n&#125;\n\n@CacheNamespace(implementation &#x3D; MybatisRedisCache.class)\n@Mapper\npublic interface UserMapper &#123;\n\n    @Select(&quot;select * from users where username &#x3D; #&#123;username&#125;&quot;)\n    Account getAccountByUsername(String username);\n&#125;\n\n最后配置文件配一波：\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            .authorizeRequests()\n            .anyRequest().authenticated()\n            .and()\n            .formLogin()\n            .and()\n            .rememberMe()\n            .tokenRepository(repository);\n&#125;\n\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth\n            .userDetailsService(service)\n            .passwordEncoder(new BCryptPasswordEncoder());\n&#125;\n\nOK，启动服务器验证一下吧。\n\n三大缓存问题注意：这部分内容作为选学内容。\n虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。\n缓存穿透\n当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？\n这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的）\n\n使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。\n布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。\n接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。\n缓存击穿\n某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。\n这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。\n缓存雪崩\n当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。\n解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。\n","slug":"SpringBoot笔记（三）","date":"2022-03-05T14:38:57.839Z","categories_index":"SpringBoot笔记","tags_index":"SpringBoot笔记","author_index":"YangChao"},{"id":"8a03b6cf044356a33316079da4b482e4","title":"SpringBoot笔记（二）","content":"Git版本控制注意：开始学习之前，确保自己的网络可以畅通的连接Github：https://github.com，这个是一个国外网站，连起来特别卡，至于用什么方式实现流畅访问，懂的都懂。\n其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不满意，你的老师可能会让你改了又改，于是就会出现下面这种情况：\n\n我们手里的论文可能会经过多次版本迭代，最终我们会选取一个最好的版本作为最终提交的论文。使用版本控制不仅仅是为了去记录版本迭代历史，更是为了能够随时回退到之前的版本，实现时间回溯。同时，可能我们的论文是多个人一同完成，那么多个人如何去实现同步，如何保证每个人提交的更改都能够正常汇总，如何解决冲突，这些问题都需要一个优秀的版本控制系统来解决。\n走进Git我们开发的项目，也需要一个合适的版本控制系统来协助我们更好地管理版本迭代，而Git正是因此而诞生的（有关Git的历史，这里就不多做阐述了，感兴趣的小伙伴可以自行了解，是一位顶级大佬在一怒之下只花了2周时间用C语言开发的，之后的章节还会遇到他）\n首先我们来了解一下Git是如何工作的：\n\n可以看到，它大致分为4个板块：\n\n工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）\n暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）\n本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）\n远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）\n\n它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。\n通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。\n安装Git首先请前往Git官网去下载最新的安装包：https://git-scm.com/download/win\n这手把手演示一下如何安装Git环境。\n安装完成后，需要设定用户名和邮箱来区分不同的用户：\ngit config --global user.name &quot;Your Name&quot;\ngit config --global user.email &quot;email@example.com&quot;\n\n基本命令介绍创建本地仓库我们可以将任意一个文件夹作为一个本地仓库，输入：\ngit init\n\n输入后，会自动生成一个.git目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。\n创建成功后，我们可以查看一下当前的一个状态，输入：\ngit status\n\n如果已经成功配置为Git本地仓库，那么输入后可以看到：\nOn branch master\n\nNo commits yet\n\n这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。\n添加和提交接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：\ngit status\n\n我们会得到如下提示：\nUntracked files:\n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\n\thello.txt\n\nnothing added to commit but untracked files present (use &quot;git add&quot; to track)\n\n其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：\ngit add hello.txt #也可以 add . 一次性添加目录下所有的\n\n再次查看当前状态：\nChanges to be committed:\n  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)\n\tnew file:   hello.txt\n\n现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。\n接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：\ngit commit -m &#39;Hello World&#39;\n\n接着我们可以查看我们的提交记录：\ngit log\ngit log --graph\n\n我们还可以查看最近一次变更的详细内容：\ngit show [也可以加上commit ID查看指定的提交记录]\n\n再次查看当前状态，已经是清空状态了：\nOn branch master\nnothing to commit, working tree clean\n\n接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\n\tmodified:   hello.txt\n\n也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：\ngit add .\ngit commit -m &#39;Modify Text&#39;\n\n接着我们来查询一下提交记录，可以看到一共有两次提交记录。\n我们可以创建一个.gitignore文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：\n# 这样就会匹配所有以txt结尾的文件\n*.txt\n# 虽然上面排除了所有txt结尾的文件，但是这个不排除\n!666.txt\n# 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略\ntest&#x2F;\n# 目录中所有以txt结尾的文件，但不包括子目录\nxxx&#x2F;*.txt\n# 目录中所有以txt结尾的文件，包括子目录\nxxx&#x2F;**&#x2F;*.txt\n\n创建后，我们来看看是否还会检测到我们忽略的文件。\n回滚当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：\ngit reset --hard commitID\n\n执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。\n那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：\ngit reflog\n\n这样就能找到之前的commitID，再次重置即可。\n分支分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。\n因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。\n创建分支我们可以通过以下命令来查看当前仓库中存在的分支：\ngit branch\n\n我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：\ngit branch test\n# 对应的删除分支是\ngit branch -d yyds\n\n现在我们修改一下文件，提交，再查看一下提交日志：\ngit commit -a -m &#39;branch master commit&#39;\n\n通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。\n我们将分支切换到另一个分支：\ngit checkout test\n\n我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。\n我们现在再来提交一次变更，会发现它只生效在yyds分支上。我们可以看看当前的分支状态：\ngit log --all --graph\n\n合并分支我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：\ngit checkout master\n\n接着使用分支合并命令：\ngit merge test\n\n会得到如下提示：\nAuto-merging hello.txt\nCONFLICT (content): Merge conflict in hello.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n\n在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？\n我们可以查看一下是哪里发生了冲突：\ngit diff\n\n因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。\n变基分支除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：\ngit rebase master\n\n变基后，yyds分支相当于同步了此前master分支的全部提交。\n优选我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：\ngit cherry-pick &lt;commit id&gt;:单独合并一个提交\n\n这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。\n\n使用IDEA版本控制虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）\n打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。\n我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。\n接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。\n接着我们来演示一下分支创建和分支管理。\n\n远程仓库远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。\n远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。\n这里我们以GitHub做讲解，官网：https://github.com，首先完成用户注册。\n远程账户认证和推送接着我们就可以创建一个自定义的远程仓库了。\n创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。\ngit remote add 名称 远程仓库地址\ngit push 远程仓库名称 本地分支名称[:远端分支名称]\n\n注意push后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。\n推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。\n但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：\nssh-keygen -t rsa\ncat ~&#x2F;.ssh&#x2F;github.pub\n\n接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。\n接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：\ngit commit -a -m &#39;Modify files&#39;\ngit log --all --oneline --graph\ngit push origin master \ngit log --all --oneline --graph\n\n我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：\ngit push --set-upstream origin master:master\ngit push origin\n\n在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）\n克隆项目如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？\n我们可以使用克隆操作来将远端仓库的内容全部复制到本地：\ngit clone 远程仓库地址\n\n这样本地就能够直接与远程保持同步。\n抓取、拉取和冲突解决我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。\n比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：\ngit fetch 远程仓库 #抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交\ngit pull 远程仓库 #拉取：获取+合并\n\n在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。\n如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：\nTo https:&#x2F;&#x2F;github.com&#x2F;xx&#x2F;xxx.git\n ! [rejected]        master -&gt; master (fetch first)\nerror: failed to push some refs to &#39;https:&#x2F;&#x2F;github.com&#x2F;xx&#x2F;xxx.git&#39;\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., &#39;git pull ...&#39;) before pushing again.\nhint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.\n\n一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。\n如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：\ngit pull 远程仓库\n\n拉取后会自动进行合并，合并完成之后我们再提交即可。\n但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。\n我们可以在IDEA中演示一下，实际开发场景下可能会遇到的问题。\n\n至此，Git版本控制就讲解到这里，下一章我们会继续认识一个全新的数据库：Redis。\n\n","slug":"SpringBoot笔记（二）","date":"2022-03-05T14:38:53.811Z","categories_index":"SpringBoot笔记","tags_index":"SpringBoot笔记","author_index":"YangChao"},{"id":"0437f348450cd4420692493db6677cff","title":"SpringBoot笔记（一）","content":"\nSpringBoot一站式开发官网：https://spring.io/projects/spring-boot\n\n\n\n\n\n\n\n\n\nSpring Boot可以轻松创建独立的、基于Spring的生产级应用程序，它可以让你“运行即可”。大多数Spring Boot应用程序只需要少量的Spring配置。\nSpringBoot功能：\n\n创建独立的Spring应用程序\n直接嵌入Tomcat、Jetty或Undertow（无需部署WAR包，打包成Jar本身就是一个可以运行的应用程序）\n提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）\n尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要你进行什么配置）\n提供生产就绪功能，如指标、运行状况检查和外部化配置\n没有代码生成，也没有XML配置的要求（XML是什么，好吃吗）\n\nSpringBoot是现在最主流的开发框架，它提供了一站式的开发体验，大幅度提高了我们的开发效率。\n走进SpringBoot在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！\n而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。\n完成本阶段的学习，基本能够胜任部分网站系统的后端开发工作，也建议同学们学习完SpringBoot之后寻找合适的队友去参加计算机项目相关的高校竞赛。\n我们可以通过IDEA来演示如何快速创建一个SpringBoot项目，并且无需任何配置，就可以实现Bean注册。\nSpringBoot项目文件结构我们在创建SpringBoot项目之后，首先会自动生成一个主类，而主类中的main方法中调用了SpringApplication类的静态方法来启动整个SpringBoot项目，并且我们可以看到主类的上方有一个@SpringBootApplication注解：\n@SpringBootApplication\npublic class SpringBootTestApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringBootTestApplication.class, args);\n    &#125;\n\n&#125;\n\n同时还自带了一个测试类，测试类的上方仅添加了一个@SpringBootTest注解：\n@SpringBootTest\nclass SpringBootTestApplicationTests &#123;\n\n    @Test\n    void contextLoads() &#123;\n        \n    &#125;\n\n&#125;\n\n我们接着来看Maven中写了哪些内容：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n  \t&lt;!--  父工程  --&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.6.2&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;springboot-study&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;SpringBootTest&lt;&#x2F;name&gt;\n    &lt;description&gt;SpringBootTest&lt;&#x2F;description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n    &lt;&#x2F;properties&gt;\n    &lt;dependencies&gt;\n        &lt;!--  spring-boot-starter SpringBoot核心启动器  --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!--  spring-boot-starter-test SpringBoot测试模块启动器  --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;!--  SpringBoot Maven插件，打包Jar都不用你操心了   --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n\n&lt;&#x2F;project&gt;\n\n除了以上这些文件以外，我们的项目目录下还有：\n\n.gitignore  -  Git忽略名单，下一章我们会专门讲解Git版本控制。\napplication.properties   -    SpringBoot的配置文件，所有依赖的配置都在这里编写，但是一般情况下只需要配置必要项即可。\n\n\n整合Web相关框架我们来看一下，既然我们前面提到SpringBoot会内嵌一个Tomcat服务器，也就是说我们的Jar打包后，相当于就是一个可以直接运行的应用程序，我们来看一下如何创建一个SpringBootWeb项目。\n这里我们演示使用IDEA来创建一个基于SpringBoot的Web应用程序。\n它是真的快创建完成后，直接开启项目，我们就可以直接访问：http://localhost:8080/，我们可以看到，但是由于我们没有编写任何的请求映射，所以没有数据。我们可以来看看日志：\n2022-01-06 22:17:46.308  INFO 853 --- [           main] c.example.SpringBootWebTestApplication   : Starting SpringBootWebTestApplication using Java 1.8.0_312 on NagodeMacBook-Pro.local with PID 853 (&#x2F;Users&#x2F;nagocoler&#x2F;Downloads&#x2F;SpringBootWebTest&#x2F;target&#x2F;classes started by nagocoler in &#x2F;Users&#x2F;nagocoler&#x2F;Downloads&#x2F;SpringBootWebTest)\n2022-01-06 22:17:46.309  INFO 853 --- [           main] c.example.SpringBootWebTestApplication   : No active profile set, falling back to default profiles: default\n2022-01-06 22:17:46.629  INFO 853 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2022-01-06 22:17:46.632  INFO 853 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2022-01-06 22:17:46.632  INFO 853 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat&#x2F;9.0.56]\n2022-01-06 22:17:46.654  INFO 853 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;]       : Initializing Spring embedded WebApplicationContext\n2022-01-06 22:17:46.654  INFO 853 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 325 ms\n2022-01-06 22:17:46.780  INFO 853 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;\n2022-01-06 22:17:46.785  INFO 853 --- [           main] c.example.SpringBootWebTestApplication   : Started SpringBootWebTestApplication in 0.62 seconds (JVM running for 0.999)\n2022-01-06 22:18:02.979  INFO 853 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;\n2022-01-06 22:18:02.979  INFO 853 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;\n2022-01-06 22:18:02.980  INFO 853 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms\n\n我们可以看到，日志中除了最基本的SpringBoot启动日志以外，还新增了内嵌Web服务器（Tomcat）的启动日志，并且显示了当前Web服务器所开放的端口，并且自动帮助我们初始化了DispatcherServlet，但是我们只是创建了项目，导入了web相关的starter依赖，没有进行任何的配置，实际上它使用的是starter提供的默认配置进行初始化的。\n由于SpringBoot是自动扫描的，因此我们直接创建一个Controller即可被加载：\n@Controller\npublic class MainController &#123;\n\n  \t&#x2F;&#x2F;直接访问http:&#x2F;&#x2F;localhost:8080&#x2F;index即可，不用加web应用程序名称了\n    @RequestMapping(&quot;&#x2F;index&quot;)\n    @ResponseBody\n    public String index()&#123;\n        return &quot;你好，欢迎访问主页！&quot;;\n    &#125;\n&#125;\n\n我们几乎没有做任何配置，但是可以直接开始配置Controller，SpringBoot创建一个Web项目的速度就是这么快！\n它还可以自动识别类型，如果我们返回的是一个对象类型的数据，那么它会自动转换为JSON数据格式，无需配置：\n@Data\npublic class Student &#123;\n    int sid;\n    String name;\n    String sex;\n&#125;\n\n@RequestMapping(&quot;&#x2F;student&quot;)\n@ResponseBody\npublic Student student()&#123;\n    Student student &#x3D; new Student();\n    student.setName(&quot;小明&quot;);\n    student.setSex(&quot;男&quot;);\n    student.setSid(10);\n    return student;\n&#125;\n\n最后浏览器能够直接得到application/json的响应数据，就是这么方便。\n修改Web相关配置如果我们需要修改Web服务器的端口或是一些其他的内容，我们可以直接在application.properties中进行修改，它是整个SpringBoot的配置文件：\n# 修改端口为80\nserver.port&#x3D;80\n\n我们还可以编写自定义的配置项，并在我们的项目中通过@Value直接注入：\ntest.data&#x3D;100\n\n@Controller\npublic class MainController &#123;\n\n    @Value(&quot;$&#123;test.data&#125;&quot;)\n    int data;\n\n通过这种方式，我们就可以更好地将一些需要频繁修改的配置项写在配置文件中，并通过注解方式去获取值。\n配置文件除了使用properties格式以外，还有一种叫做yaml格式，它的语法如下：\n一级目录:\n\t二级目录:\n\t  三级目录1: 值\n\t  三级目录2: 值\n\t  三级目录List: \n\t  - 元素1\n\t  - 元素2\n\t  - 元素3\n\n我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。\nSpringBoot也支持这种格式的配置文件，我们可以将application.properties修改为application.yml或是application.yaml来使用YAML语法编写配置：\nserver:\n  port: 80\n\n整合SpringSecurity依赖我们接着来整合一下SpringSecurity依赖，继续感受SpringBoot带来的光速开发体验，只需要导入SpringSecurity的Starter依赖即可：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n导入依赖后，我们直接启动SpringBoot应用程序，可以发现SpringSecurity已经生效了。\n并且SpringSecurity会自动为我们生成一个默认用户user，它的密码会出现在日志中：\n2022-01-06 23:10:51.329  INFO 2901 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2022-01-06 23:10:51.329  INFO 2901 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat&#x2F;9.0.56]\n2022-01-06 23:10:51.350  INFO 2901 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;]       : Initializing Spring embedded WebApplicationContext\n2022-01-06 23:10:51.351  INFO 2901 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 341 ms\n2022-01-06 23:10:51.469  INFO 2901 --- [           main] .s.s.UserDetailsServiceAutoConfiguration : \n\nUsing generated security password: ff24bee3-e1b7-4309-9609-d32618baf5cb\n\n\n其中ff24bee3-e1b7-4309-9609-d32618baf5cb就是随机生成的一个密码，我们可以使用此用户登录。\n我们也可以在配置文件中直接配置：\nspring:\n  security:\n    user:\n      name: test   # 用户名\n      password: 123456  # 密码\n      roles:   # 角色\n      - user\n      - admin\n\n实际上这样的配置方式就是一个inMemoryAuthentication，只是我们可以直接配置而已。\n当然，页面的控制和数据库验证我们还是需要提供WebSecurityConfigurerAdapter的实现类去完成：\n@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                .authorizeRequests()\n                .antMatchers(&quot;&#x2F;login&quot;).permitAll()\n                .anyRequest().hasRole(&quot;user&quot;)\n                .and()\n                .formLogin();\n    &#125;\n&#125;\n\n注意这里不需要再添加@EnableWebSecurity了，因为starter依赖已经帮我们添加了。\n使用了SpringBoot之后，我们发现，需要什么功能，只需要导入对应的starter依赖即可，甚至都不需要你去进行额外的配置，你只需要关注依赖本身的必要设置即可，大大提高了我们的开发效率。\n\n整合Mybatis框架我们接着来看如何整合Mybatis框架，同样的，我们只需要导入对应的starter依赖即可：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n导入依赖后，直接启动会报错，是因为有必要的配置我们没有去编写，我们需要指定数据源的相关信息：\nspring:\n  datasource:\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306\n    username: root\n    password: 123456\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n再次启动，成功。\n我们发现日志中会出现这样一句话：\n2022-01-07 12:32:09.106  WARN 6917 --- [           main] o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in &#39;[com.example]&#39; package. Please check your configuration.\n\n这是Mybatis自动扫描输出的语句，导入依赖后，我们不需要再去设置Mybatis的相关Bean了，也不需要添加任何@MapperSacn注解，因为starter已经帮助我们做了，它会自动扫描项目中添加了@Mapper注解的接口，直接将其注册为Bean，不需要进行任何配置。\n@Mapper\npublic interface MainMapper &#123;\n    @Select(&quot;select * from users where username &#x3D; #&#123;username&#125;&quot;)\n    UserData findUserByName(String username);\n&#125;\n\n当然，如果你觉得每个接口都去加一个@Mapper比较麻烦的话也可以用回之前的方式，直接@MapperScan使用包扫描。\n添加Mapper之后，使用方法和SSM阶段是一样的，我们可以将其与SpringSecurity结合使用：\n@Service\npublic class UserAuthService implements UserDetailsService &#123;\n\n    @Resource\n    MainMapper mapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        UserData data &#x3D; mapper.findUserByName(username);\n        if(data &#x3D;&#x3D; null) throw new UsernameNotFoundException(&quot;用户 &quot;+username+&quot; 登录失败，用户名不存在！&quot;);\n        return User\n                .withUsername(data.getUsername())\n                .password(data.getPassword())\n                .roles(data.getRole())\n                .build();\n    &#125;\n&#125;\n\n最后配置一下自定义验证即可，注意这样之前配置文件里面配置的用户就失效了：\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n    auth\n            .userDetailsService(service)\n            .passwordEncoder(new BCryptPasswordEncoder());\n&#125;\n\n在首次使用时，我们发现日志中输出以以下语句：\n2022-01-07 12:39:40.559  INFO 6930 --- [nio-8080-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2022-01-07 12:39:41.033  INFO 6930 --- [nio-8080-exec-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n实际上，SpringBoot会自动为Mybatis配置数据源，默认使用的就是HikariCP数据源。\n\n整合Thymeleaf框架整合Thymeleaf也只需导入对应的starter即可：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n接着我们只需要直接使用即可：\n@RequestMapping(&quot;&#x2F;index&quot;)\npublic String index()&#123;\n    return &quot;index&quot;;\n&#125;\n\n但是注意，这样只能正常解析HTML页面，但是js、css等静态资源我们需要进行路径指定，不然无法访问，我们在配文件中配置一下静态资源的访问前缀：\nspring:\n\tmvc:\n  \tstatic-path-pattern: &#x2F;static&#x2F;**\n\n接着我们像之前一样，把登陆页面实现一下吧。\n&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;http:&#x2F;&#x2F;www.thymeleaf.org\nxmlns:sec&#x3D;http:&#x2F;&#x2F;www.thymeleaf.org&#x2F;extras&#x2F;spring-security&gt;\n\n\n日志系统SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。\n日志门面和日志实现我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志，而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。\n日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。\n\n但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。\n这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。\n\n所以，SpringBoot为了统一日志框架的使用，做了这些事情：\n\n直接将其他依赖以前的日志框架剔除\n导入对应日志框架的Slf4j中间包\n导入自己官方指定的日志实现，并作为Slf4j的日志实现层\n\n在SpringBoot中打印日志信息SpringBoot使用的是Slf4j作为日志门面，Logback（Logback 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：\n@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login()&#123;\n    Logger logger &#x3D; LoggerFactory.getLogger(MainController.class);\n    logger.info(&quot;用户访问了一次登陆界面&quot;);\n    return &quot;login&quot;;\n&#125;\n\n因为我们使用了Lombok，所以直接一个注解也可以搞定哦：\n@Slf4j\n@Controller\npublic class MainController &#123;\n\n    @RequestMapping(&quot;&#x2F;login&quot;)\n    public String login()&#123;\n        log.info(&quot;用户访问了一次登陆界面&quot;);\n        return &quot;login&quot;;\n    &#125;\n\n日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息。\n配置Logback日志Logback官网：https://logback.qos.ch\n和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为logback-spring.xml表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;!-- 配置 --&gt;\n&lt;&#x2F;configuration&gt;\n\n最外层由configuration包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。\n我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在org/springframework/boot/logging/logback/defaults.xml中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的appender即可：\n&lt;included&gt;\n   &lt;conversionRule conversionWord&#x3D;&quot;clr&quot; converterClass&#x3D;&quot;org.springframework.boot.logging.logback.ColorConverter&quot; &#x2F;&gt;\n   &lt;conversionRule conversionWord&#x3D;&quot;wex&quot; converterClass&#x3D;&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; &#x2F;&gt;\n   &lt;conversionRule conversionWord&#x3D;&quot;wEx&quot; converterClass&#x3D;&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; &#x2F;&gt;\n\n   &lt;property name&#x3D;&quot;CONSOLE_LOG_PATTERN&quot; value&#x3D;&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;&#x2F;&gt;\n   &lt;property name&#x3D;&quot;CONSOLE_LOG_CHARSET&quot; value&#x3D;&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;&#x2F;&gt;\n   &lt;property name&#x3D;&quot;FILE_LOG_PATTERN&quot; value&#x3D;&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;&#x2F;&gt;\n   &lt;property name&#x3D;&quot;FILE_LOG_CHARSET&quot; value&#x3D;&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;&#x2F;&gt;\n\n   &lt;logger name&#x3D;&quot;org.apache.catalina.startup.DigesterFactory&quot; level&#x3D;&quot;ERROR&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.apache.catalina.util.LifecycleBase&quot; level&#x3D;&quot;ERROR&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.apache.coyote.http11.Http11NioProtocol&quot; level&#x3D;&quot;WARN&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.apache.sshd.common.util.SecurityUtils&quot; level&#x3D;&quot;WARN&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.apache.tomcat.util.net.NioSelectorPool&quot; level&#x3D;&quot;WARN&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot; level&#x3D;&quot;ERROR&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.hibernate.validator.internal.util.Version&quot; level&#x3D;&quot;WARN&quot;&#x2F;&gt;\n   &lt;logger name&#x3D;&quot;org.springframework.boot.actuate.endpoint.jmx&quot; level&#x3D;&quot;WARN&quot;&#x2F;&gt;\n&lt;&#x2F;included&gt;\n\n导入后，我们利用预设的日志格式创建一个控制台日志打印：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;!--  导入其他配置文件，作为预设  --&gt;\n    &lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;defaults.xml&quot; &#x2F;&gt;\n\n    &lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;\n    &lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;\n    &lt;appender name&#x3D;&quot;CONSOLE&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;&#x2F;pattern&gt;\n            &lt;charset&gt;$&#123;CONSOLE_LOG_CHARSET&#125;&lt;&#x2F;charset&gt;\n        &lt;&#x2F;encoder&gt;\n    &lt;&#x2F;appender&gt;\n\n    &lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;configuration&gt;\n\n配置完成后，我们发现控制台已经可以正常打印日志信息了。\n接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：\n&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;\n&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n    &lt;encoder&gt;\n        &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;&#x2F;pattern&gt;\n        &lt;charset&gt;$&#123;FILE_LOG_CHARSET&#125;&lt;&#x2F;charset&gt;\n    &lt;&#x2F;encoder&gt;\n    &lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;\n    &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;\n        &lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;\n        &lt;FileNamePattern&gt;log&#x2F;%d&#123;yyyy-MM-dd&#125;-spring-%i.log&lt;&#x2F;FileNamePattern&gt;\n        &lt;!--  到期自动清理日志文件  --&gt;\n        &lt;cleanHistoryOnStart&gt;true&lt;&#x2F;cleanHistoryOnStart&gt;\n        &lt;!--  最大日志保留时间  --&gt;\n        &lt;maxHistory&gt;7&lt;&#x2F;maxHistory&gt;\n        &lt;!--  最大单个日志文件大小  --&gt;\n        &lt;maxFileSize&gt;10MB&lt;&#x2F;maxFileSize&gt;\n    &lt;&#x2F;rollingPolicy&gt;\n&lt;&#x2F;appender&gt;\n\n&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;\n&lt;root level&#x3D;&quot;INFO&quot;&gt;\n    &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;\n    &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;\n&lt;&#x2F;root&gt;\n\n配置完成后，我们可以看到日志文件也能自动生成了。\n我们也可以魔改官方提供的日志格式，官方文档：https://logback.qos.ch/manual/layouts.html\n这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。\n比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：\n@Slf4j\n@Controller\npublic class MainController &#123;\n\n    @RequestMapping(&quot;&#x2F;login&quot;)\n    public String login()&#123;\n      \t&#x2F;&#x2F;这里就用Session代替ID吧\n        MDC.put(&quot;reqId&quot;, request.getSession().getId());\n        log.info(&quot;用户访问了一次登陆界面&quot;);\n        return &quot;login&quot;;\n    &#125;\n\n通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符%X&#123;键值&#125;，名字保持一致：\n%clr([%X&#123;reqId&#125;])&#123;faint&#125; \n\n这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。\n自定义Banner我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。\n我们可以直接来配置文件所在目录下创建一个名为banner.txt的文本文档，内容随便你：\n&#x2F;&#x2F;                          _ooOoo_                               &#x2F;&#x2F;\n&#x2F;&#x2F;                         o8888888o                              &#x2F;&#x2F;\n&#x2F;&#x2F;                         88&quot; . &quot;88                              &#x2F;&#x2F;\n&#x2F;&#x2F;                         (| ^_^ |)                              &#x2F;&#x2F;\n&#x2F;&#x2F;                         O\\  &#x3D;  &#x2F;O                              &#x2F;&#x2F;\n&#x2F;&#x2F;                      ____&#x2F;&#96;---&#39;\\____                           &#x2F;&#x2F;\n&#x2F;&#x2F;                    .&#39;  \\\\|     |&#x2F;&#x2F;  &#96;.                         &#x2F;&#x2F;\n&#x2F;&#x2F;                   &#x2F;  \\\\|||  :  |||&#x2F;&#x2F;  \\                        &#x2F;&#x2F;\n&#x2F;&#x2F;                  &#x2F;  _||||| -:- |||||-  \\                       &#x2F;&#x2F;\n&#x2F;&#x2F;                  |   | \\\\\\  -  &#x2F;&#x2F;&#x2F; |   |                       &#x2F;&#x2F;\n&#x2F;&#x2F;                  | \\_|  &#39;&#39;\\---&#x2F;&#39;&#39;  |   |                       &#x2F;&#x2F;\n&#x2F;&#x2F;                  \\  .-\\__  &#96;-&#96;  ___&#x2F;-. &#x2F;                       &#x2F;&#x2F;\n&#x2F;&#x2F;                ___&#96;. .&#39;  &#x2F;--.--\\  &#96;. . ___                     &#x2F;&#x2F;\n&#x2F;&#x2F;              .&quot;&quot; &#39;&lt;  &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39;  &gt;&#39;&quot;&quot;.                  &#x2F;&#x2F;\n&#x2F;&#x2F;            | | :  &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | |                 &#x2F;&#x2F;\n&#x2F;&#x2F;            \\  \\ &#96;-.   \\_ __\\ &#x2F;__ _&#x2F;   .-&#96; &#x2F;  &#x2F;                 &#x2F;&#x2F;\n&#x2F;&#x2F;      &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;         &#x2F;&#x2F;\n&#x2F;&#x2F;                           &#96;&#x3D;---&#x3D;&#39;                              &#x2F;&#x2F;\n&#x2F;&#x2F;      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        &#x2F;&#x2F;\n&#x2F;&#x2F;             佛祖保佑          永无BUG         永不修改             &#x2F;&#x2F;\n\n可以使用在线生成网站进行生成自己的个性Banner：https://www.bootschool.net/ascii\n我们甚至还可以使用颜色代码来为文本切换颜色：\n$&#123;AnsiColor.BRIGHT_GREEN&#125;  &#x2F;&#x2F;绿色\n\n也可以获取一些常用的变量信息：\n$&#123;AnsiColor.YELLOW&#125; 当前 Spring Boot 版本：$&#123;spring-boot.version&#125;\n\n玩的开心！\n\n多环境配置在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。\n由于SpringBoot只会读取application.properties或是application.yml文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：\nspring:\n  profiles:\n    active: dev\n\n接着我们分别创建两个环境的配置文件，application-dev.yml和application-prod.yml分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：\nserver:\n  port: 8080\n\nserver:\n  port: 80\n\n这样我们就可以灵活切换生产环境和开发环境下的配置文件了。\nSpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：\n&lt;springProfile name&#x3D;&quot;dev&quot;&gt;\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot;&#x2F;&gt;\n        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;springProfile&gt;\n\n&lt;springProfile name&#x3D;&quot;prod&quot;&gt;\n    &lt;root level&#x3D;&quot;INFO&quot;&gt;\n        &lt;appender-ref ref&#x3D;&quot;FILE&quot;&#x2F;&gt;\n    &lt;&#x2F;root&gt;\n&lt;&#x2F;springProfile&gt;\n\n注意springProfile是区分大小写的！\n那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：\n&lt;!--分别设置开发，生产环境--&gt;\n&lt;profiles&gt;\n    &lt;!-- 开发环境 --&gt;\n    &lt;profile&gt;\n        &lt;id&gt;dev&lt;&#x2F;id&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n        &lt;properties&gt;\n            &lt;environment&gt;dev&lt;&#x2F;environment&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n    &lt;!-- 生产环境 --&gt;\n    &lt;profile&gt;\n        &lt;id&gt;prod&lt;&#x2F;id&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;false&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n        &lt;properties&gt;\n            &lt;environment&gt;prod&lt;&#x2F;environment&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n&lt;&#x2F;profiles&gt;\n\n接着，我们需要根据环境的不同，排除其他环境的配置文件：\n&lt;resources&gt;\n&lt;!--排除配置文件--&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n        &lt;!--先排除所有的配置文件--&gt;\n        &lt;excludes&gt;\n            &lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;\n            &lt;exclude&gt;application*.yml&lt;&#x2F;exclude&gt;\n        &lt;&#x2F;excludes&gt;\n    &lt;&#x2F;resource&gt;\n\n    &lt;!--根据激活条件引入打包所需的配置和文件--&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n        &lt;!--引入所需环境的配置文件--&gt;\n        &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;includes&gt;\n            &lt;include&gt;application.yml&lt;&#x2F;include&gt;\n            &lt;!--根据maven选择环境导入配置文件--&gt;\n            &lt;include&gt;application-$&#123;environment&#125;.yml&lt;&#x2F;include&gt;\n        &lt;&#x2F;includes&gt;\n    &lt;&#x2F;resource&gt;\n&lt;&#x2F;resources&gt;\n\n接着，我们可以直接将Maven中的environment属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：\nspring:\n  profiles:\n    active: &#39;@environment@&#39;  #注意YAML配置文件需要加单引号，否则会报错\n\n这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。\n最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！\n\n打包运行现在我们的SpringBoot项目编写完成了，那么如何打包运行呢？非常简单，只需要点击Maven生命周期中的package即可，它会自动将其打包为可直接运行的Jar包，第一次打包可能会花费一些时间下载部分依赖的源码一起打包进Jar文件。\n我们发现在打包的过程中还会完整的将项目跑一遍进行测试，如果我们不想测试直接打包，可以手动使用以下命令：\nmvn package  -DskipTests\n\n打包后，我们会直接得到一个名为springboot-study-0.0.1-SNAPSHOT.jar的文件，这时在CMD窗口中输入命令：\njava -jar springboot-study-0.0.1-SNAPSHOT.jar\n\n输入后，可以看到我们的Java项目成功运行起来了，如果手动关闭窗口会导致整个项目终止运行。\n\n再谈Spring框架注意：开始本部分前，建议先完成SSM阶段的Spring源码讲解部分。\n我们在SpringBoot阶段，需要继续扩充Spring框架的相关知识，来巩固和强化对于Spring框架的认识。\n任务调度为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。\n这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务，但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。\n异步任务需要使用Spring异步任务支持，我们需要在配置类上添加@EnableAsync或是在SpringBoot的启动类上添加也可以。\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootWebTestApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringBootWebTestApplication.class, args);\n    &#125;\n&#125;\n\n接着我们只需要在需要异步执行的方法上，添加@Async注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，不是在当前线程执行。\n@Service\npublic class TestService &#123;\n\n    @Async\n    public void test()&#123;\n        try &#123;\n            Thread.sleep(3000);\n            System.out.println(&quot;我是异步任务！&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login(HttpServletRequest request)&#123;\n    service.test();\n    System.out.println(&quot;我是同步任务！&quot;);\n    return &quot;login&quot;;\n&#125;\n\n实际上这也是得益于AOP机制，通过线程池实现，但是也要注意，正是因为它是AOP机制的产物，所以它只能是在Bean中才会生效！\n使用 @Async 注释的方法可以返回 ‘void’ 或 “Future” 类型，Future是一种用于接收任务执行结果的一种类型，我们会在Java并发编程中进行讲解，这里暂时不做介绍。\n定时任务看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段我们使用过TimerTask来执行定时任务。\nSpring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加@EnableScheduling或是在SpringBoot的启动类上添加也可：\n@EnableAsync\n@EnableScheduling\n@SpringBootApplication\npublic class SpringBootWebTestApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SpringBootWebTestApplication.class, args);\n    &#125;\n&#125;\n\n接着我们可以创建一个定时任务配置类，在配置类里面编写定时任务：\n@Configuration\npublic class ScheduleConfiguration &#123;\n\n    @Scheduled(fixedRate &#x3D; 2000)\n    public void task()&#123;\n        System.out.println(&quot;我是定时任务！&quot;+new Date());\n    &#125;\n&#125;\n\n我们注意到 @Scheduled中有很多参数，我们需要指定’cron’, ‘fixedDelay(String)’, or ‘fixedRate(String)’的其中一个，否则无法创建定时任务，他们的区别如下：\n\nfixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。\nfixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。\ncron：使用cron表达式来指定任务计划。\n\n这里重点讲解一下cron表达式：https://blog.csdn.net/sunnyzyq/article/details/98597252\n监听器监听器对我们来说也是一个比较陌生的概念，那么何谓监听呢？\n监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知。\n@Component\npublic class TestListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) &#123;\n        System.out.println(event.getApplicationContext());\n    &#125;\n&#125;\n\n通过监听事件，我们就可以在对应的时机进行一些额外的处理，我们可以通过断点调试来查看一个事件是如何发生，以及如何通知监听器的。\n通过阅读源码，我们得知，一个事件实际上就是通过publishEvent方法来进行发布的，我们也可以自定义我们自己项目中的事件，并注册对应的监听器进行处理。\npublic class TestEvent extends ApplicationEvent &#123;   &#x2F;&#x2F;需要继承ApplicationEvent\n    public TestEvent(Object source) &#123;\n        super(source);\n    &#125;\n&#125;\n\n@Component\npublic class TestListener implements ApplicationListener&lt;TestEvent&gt; &#123;\n\n    @Override\n    public void onApplicationEvent(TestEvent event) &#123;\n        System.out.println(&quot;自定义事件发生了：&quot;+event.getSource());\n    &#125;\n&#125;\n\n@Resource\nApplicationContext context;\n\n@RequestMapping(&quot;&#x2F;login&quot;)\npublic String login(HttpServletRequest request)&#123;\n    context.publishEvent(new TestEvent(&quot;有人访问了登录界面！&quot;));\n    return &quot;login&quot;;\n&#125;\n\n这样，我们就实现了自定义事件发布和监听。\nAware系列接口我们在之前讲解Spring源码时，经常会发现某些类的定义上，除了我们当时讲解的继承关系以外，还实现了一些接口，他们的名称基本都是xxxxAware，比如我们在讲解SpringSecurity的源码中，AbstractAuthenticationProcessingFilter类就是这样：\npublic abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware &#123;\n    protected ApplicationEventPublisher eventPublisher;\n    protected AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource &#x3D; new WebAuthenticationDetailsSource();\n    private AuthenticationManager authenticationManager;\n    ...\n\n我们发现它除了继承自GenericFilterBean之外，还实现了ApplicationEventPublisherAware和MessageSourceAware接口，那么这些Aware接口到底是干嘛的呢？\nAware的中文意思为感知。简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。\n比如AbstractAuthenticationProcessingFilter就实现了ApplicationEventPublisherAware接口，此接口的感知功能为事件发布器，在Bean加载时，会调用实现类中的setApplicationEventPublisher方法，而AbstractAuthenticationProcessingFilter类则利用此方法，在Bean加载阶段获得了容器的事件发布器，以便之后发布事件使用。\npublic void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) &#123;\n    this.eventPublisher &#x3D; eventPublisher;   &#x2F;&#x2F;直接存到成员变量\n&#125;\n\nprotected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;\n    SecurityContext context &#x3D; SecurityContextHolder.createEmptyContext();\n    context.setAuthentication(authResult);\n    SecurityContextHolder.setContext(context);\n    if (this.logger.isDebugEnabled()) &#123;\n        this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult));\n    &#125;\n\n    this.rememberMeServices.loginSuccess(request, response, authResult);\n  \t&#x2F;&#x2F;在这里使用\n    if (this.eventPublisher !&#x3D; null) &#123;\n        this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));\n    &#125;\n\n    this.successHandler.onAuthenticationSuccess(request, response, authResult);\n&#125;\n\n同样的，除了ApplicationEventPublisherAware接口外，我们再来演示一个接口，比如：\n@Service\npublic class TestService implements BeanNameAware &#123;\n    @Override\n    public void setBeanName(String s) &#123;\n        System.out.println(s);\n    &#125;\n&#125;\n\nBeanNameAware就是感知Bean名称的一个接口，当Bean被加载时，会调用setBeanName方法并将Bean名称作为参数传递。\n有关所有的Aware这里就不一一列举了。\n\n探究SpringBoot实现原理注意：难度较大，本版块作为选学内容，在开始前，必须完成SSM阶段源码解析部分的学习。\n我们在前面的学习中切实感受到了SpringBoot为我们带来的便捷，那么它为何能够实现如此快捷的开发模式，starter又是一个怎样的存在，它是如何进行自动配置的，我们现在就开始研究。\n启动原理首先我们来看看，SpringBoot项目启动之后，做了什么事情，SpringApplication中的静态run方法：\npublic static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;\n    return run(new Class[]&#123;primarySource&#125;, args);\n&#125;\n\n套娃如下：\npublic static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;\n    return (new SpringApplication(primarySources)).run(args);\n&#125;\n\n我们发现，这里直接new了一个新的SpringApplication对象，传入我们的主类作为构造方法参数，并调用了非static的run方法，我们先来看看构造方法里面做了什么事情：\npublic SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;\n    ...\n    this.resourceLoader &#x3D; resourceLoader;\n    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);\n    this.primarySources &#x3D; new LinkedHashSet(Arrays.asList(primarySources));\n  \t&#x2F;&#x2F;这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型\n  \t&#x2F;&#x2F;deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型\n    this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();\n    this.bootstrapRegistryInitializers &#x3D; new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));\n  \t&#x2F;&#x2F;创建所有ApplicationContextInitializer实现类的对象\n    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();\n&#125;\n\n关键就在这里了，它是如何知道哪些类是ApplicationContextInitializer的实现类的呢？\n这里就要提到spring.factories了，它是 Spring 仿造Java SPI实现的一种类加载机制。它在 META-INF&#x2F;spring.factories 文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是 Spring Boot Starter 实现的基础。\nSPI的常见例子：\n\n数据库驱动加载接口实现类的加载：JDBC加载不同类型数据库的驱动\n日志门面接口实现类加载：SLF4J加载不同提供商的日志实现类\n\n说白了就是人家定义接口，但是实现可能有很多种，但是核心只提供接口，需要我们按需选择对应的实现，这种方式是高度解耦的。\n我们来看看getSpringFactoriesInstances方法做了什么：\nprivate &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;\n  \t&#x2F;&#x2F;获取当前的类加载器\n    ClassLoader classLoader &#x3D; this.getClassLoader();\n  \t&#x2F;&#x2F;获取所有依赖中 META-INF&#x2F;spring.factories 中配置的对应接口类的实现类列表\n    Set&lt;String&gt; names &#x3D; new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n  \t&#x2F;&#x2F;根据上方列表，依次创建实例对象  \n  List&lt;T&gt; instances &#x3D; this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n  \t&#x2F;&#x2F;根据对应类上的Order接口或是注解进行排序\n    AnnotationAwareOrderComparator.sort(instances);\n  \t&#x2F;&#x2F;返回实例\n    return instances;\n&#125;\n\n其中SpringFactoriesLoader.loadFactoryNames正是读取配置的核心部分，我们后面还会遇到。\n接着我们来看run方法里面做了什么事情。\npublic ConfigurableApplicationContext run(String... args) &#123;\n    long startTime &#x3D; System.nanoTime();\n    DefaultBootstrapContext bootstrapContext &#x3D; this.createBootstrapContext();\n    ConfigurableApplicationContext context &#x3D; null;\n    this.configureHeadlessProperty();\n  \t&#x2F;&#x2F;获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener\n  \t&#x2F;&#x2F;EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器\n    SpringApplicationRunListeners listeners &#x3D; this.getRunListeners(args);\n    listeners.starting(bootstrapContext, this.mainApplicationClass);\n\n    try &#123;\n      \t&#x2F;&#x2F;环境配置\n        ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);\n        ConfigurableEnvironment environment &#x3D; this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n      \t&#x2F;&#x2F;打印Banner\n        Banner printedBanner &#x3D; this.printBanner(environment);\n      \t&#x2F;&#x2F;创建ApplicationContext，注意这里会根据是否为Web容器使用不同的ApplicationContext实现类\n        context &#x3D; this.createApplicationContext();\n        context.setApplicationStartup(this.applicationStartup);\n      \t&#x2F;&#x2F;初始化ApplicationContext\n        this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n      \t&#x2F;&#x2F;执行ApplicationContext的refresh方法\n        this.refreshContext(context);\n        this.afterRefresh(context, applicationArguments);\n        Duration timeTakenToStartup &#x3D; Duration.ofNanos(System.nanoTime() - startTime);\n        if (this.logStartupInfo) &#123;\n            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);\n        &#125;\n        ....\n&#125;\n\n我们发现，实际上SpringBoot就是Spring的一层壳罢了，离不开最关键的ApplicationContext，也就是说，在启动后会自动配置一个ApplicationContext，只不过是进行了大量的扩展。\n我们来看ApplicationContext是怎么来的，打开createApplicationContext方法：\nprotected ConfigurableApplicationContext createApplicationContext() &#123;\n    return this.applicationContextFactory.create(this.webApplicationType);\n&#125;\n\n我们发现在构造方法中applicationContextFactory直接使用的是DEFAULT：\nthis.applicationContextFactory &#x3D; ApplicationContextFactory.DEFAULT;\n\nApplicationContextFactory DEFAULT &#x3D; (webApplicationType) -&gt; &#123;\n    try &#123;\n        switch(webApplicationType) &#123;\n        case SERVLET:\n            return new AnnotationConfigServletWebServerApplicationContext();\n        case REACTIVE:\n            return new AnnotationConfigReactiveWebServerApplicationContext();\n        default:\n            return new AnnotationConfigApplicationContext();\n        &#125;\n    &#125; catch (Exception var2) &#123;\n        throw new IllegalStateException(&quot;Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory&quot;, var2);\n    &#125;\n&#125;;\n\nConfigurableApplicationContext create(WebApplicationType webApplicationType);\n\nDEFAULT是直接编写的一个匿名内部类，其实已经很明确了，正是根据webApplicationType类型进行判断，如果是SERVLET，那么久返回专用于Web环境的AnnotationConfigServletWebServerApplicationContext对象（SpringBoot中新增的），否则返回普通的AnnotationConfigApplicationContext对象，也就是到这里为止，Spring的容器就基本已经确定了。\n注意AnnotationConfigApplicationContext是Spring框架提供的类，从这里开始相当于我们在讲Spring的底层源码了，我们继续深入，AnnotationConfigApplicationContext对象在创建过程中会创建AnnotatedBeanDefinitionReader，它是用于通过注解解析Bean定义的工具类：\npublic AnnotationConfigApplicationContext() &#123;\n    StartupStep createAnnotatedBeanDefReader &#x3D; this.getApplicationStartup().start(&quot;spring.context.annotated-bean-reader.create&quot;);\n    this.reader &#x3D; new AnnotatedBeanDefinitionReader(this);\n    createAnnotatedBeanDefReader.end();\n    this.scanner &#x3D; new ClassPathBeanDefinitionScanner(this);\n&#125;\n\n其构造方法：\npublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) &#123;\n    ...\n    &#x2F;&#x2F;这里会注册很多的后置处理器\n    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n&#125;\n\npublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source) &#123;\n    DefaultListableBeanFactory beanFactory &#x3D; unwrapDefaultListableBeanFactory(registry);\n    ....\n    Set&lt;BeanDefinitionHolder&gt; beanDefs &#x3D; new LinkedHashSet(8);\n    RootBeanDefinition def;\n    if (!registry.containsBeanDefinition(&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;)) &#123;\n      \t&#x2F;&#x2F;注册了ConfigurationClassPostProcessor用于处理@Configuration、@Import等注解\n      \t&#x2F;&#x2F;注意这里是关键，之后Selector还要讲到它\n      \t&#x2F;&#x2F;它是继承自BeanDefinitionRegistryPostProcessor，所以它的执行时间在Bean定义加载完成后，Bean初始化之前\n        def &#x3D; new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;));\n    &#125;\n\n    if (!registry.containsBeanDefinition(&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;)) &#123;\n      \t&#x2F;&#x2F;AutowiredAnnotationBeanPostProcessor用于处理@Value等注解自动注入\n        def &#x3D; new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, &quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;));\n    &#125;\n  \n  \t...\n\n回到SpringBoot，我们最后来看，prepareContext方法中又做了什么事情：\nprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;\n  \t&#x2F;&#x2F;环境配置\n    context.setEnvironment(environment);\n    this.postProcessApplicationContext(context);\n    this.applyInitializers(context);\n    listeners.contextPrepared(context);\n    bootstrapContext.close(context);\n    if (this.logStartupInfo) &#123;\n        this.logStartupInfo(context.getParent() &#x3D;&#x3D; null);\n        this.logStartupProfileInfo(context);\n    &#125;\n\n  \t&#x2F;&#x2F;将Banner注册为Bean\n    ConfigurableListableBeanFactory beanFactory &#x3D; context.getBeanFactory();\n    beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);\n    if (printedBanner !&#x3D; null) &#123;\n        beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);\n    &#125;\n\n    if (beanFactory instanceof AbstractAutowireCapableBeanFactory) &#123;\n        ((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(this.allowCircularReferences);\n        if (beanFactory instanceof DefaultListableBeanFactory) &#123;\n            ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n        &#125;\n    &#125;\n\n    if (this.lazyInitialization) &#123;\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    &#125;\n\n  \t&#x2F;&#x2F;这里会获取我们一开始传入的项目主类\n    Set&lt;Object&gt; sources &#x3D; this.getAllSources();\n    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);\n  \t&#x2F;&#x2F;这里会将我们的主类直接注册为Bean，这样就可以通过注解加载了\n    this.load(context, sources.toArray(new Object[0]));\n    listeners.contextLoaded(context);\n&#125;\n\n因此，在prepareContext执行完成之后，我们的主类成功完成Bean注册，接下来，就该类上注解大显身手了。\n自动配置原理既然主类已经在初始阶段注册为Bean，那么在加载时，就会根据注解定义，进行更多的额外操作。所以我们来看看主类上的@SpringBootApplication注解做了什么事情。\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters &#x3D; &#123;@Filter(\n    type &#x3D; FilterType.CUSTOM,\n    classes &#x3D; &#123;TypeExcludeFilter.class&#125;\n), @Filter(\n    type &#x3D; FilterType.CUSTOM,\n    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;\n)&#125;\n)\npublic @interface SpringBootApplication &#123;\n\n我们发现，@SpringBootApplication上添加了@ComponentScan注解，此注解我们此前已经认识过了，但是这里并没有配置具体扫描的包，因此它会自动将声明此接口的类所在的包作为basePackage，因此当添加@SpringBootApplication之后也就等于直接开启了自动扫描，但是一定注意不能在主类之外的包进行Bean定义，否则无法扫描到，需要手动配置。\n接着我们来看第二个注解@EnableAutoConfiguration，它就是自动配置的核心了，我们来看看它是如何定义的：\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\npublic @interface EnableAutoConfiguration &#123;\n\n老套路了，直接一手@Import，通过这种方式来将一些外部的Bean加载到容器中。我们来看看AutoConfigurationImportSelector做了什么事情：\npublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;\n\t\t...\n&#125;\n\n我们看到它实现了很多接口，包括大量的Aware接口，实际上就是为了感知某些必要的对象，并将其存到当前类中。\n其中最核心的是DeferredImportSelector接口，它是ImportSelector的子类，它定义了selectImports方法，用于返回需要加载的类名称，在Spring加载ImportSelector类型的Bean时，会调用此方法来获取更多需要加载的类，并将这些类一并注册为Bean：\npublic interface ImportSelector &#123;\n    String[] selectImports(AnnotationMetadata importingClassMetadata);\n\n    @Nullable\n    default Predicate&lt;String&gt; getExclusionFilter() &#123;\n        return null;\n    &#125;\n&#125;\n\n到目前为止，我们了解了两种使用@Import有特殊机制的接口：ImportSelector（这里用到的）和ImportBeanDefinitionRegistrar（之前Mybatis-spring源码有讲）当然还有普通的@Configuration配置类。\n我们可以来阅读一下ConfigurationClassPostProcessor的源码，看看它到底是如何处理@Import的：\npublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;\n    List&lt;BeanDefinitionHolder&gt; configCandidates &#x3D; new ArrayList();\n  \t&#x2F;&#x2F;注意这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何区分\n  \t&#x2F;&#x2F;candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中\n    String[] candidateNames &#x3D; registry.getBeanDefinitionNames();\n    String[] var4 &#x3D; candidateNames;\n    int var5 &#x3D; candidateNames.length;\n\n    for(int var6 &#x3D; 0; var6 &lt; var5; ++var6) &#123;\n        String beanName &#x3D; var4[var6];\n        BeanDefinition beanDef &#x3D; registry.getBeanDefinition(beanName);\n        if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) !&#x3D; null) &#123;\n            if (this.logger.isDebugEnabled()) &#123;\n                this.logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);\n            &#125;\n        &#125; else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;   &#x2F;&#x2F;判断是否添加了@Configuration注解\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        &#125;\n    &#125;\n\n    if (!configCandidates.isEmpty()) &#123;\n        &#x2F;&#x2F;...省略\n\n      \t&#x2F;&#x2F;这里创建了一个ConfigurationClassParser用于解析配置类\n        ConfigurationClassParser parser &#x3D; new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n      \t&#x2F;&#x2F;所有配置类的BeanDefinitionHolder列表\n        Set&lt;BeanDefinitionHolder&gt; candidates &#x3D; new LinkedHashSet(configCandidates);\n      \t&#x2F;&#x2F;已经解析完成的类\n        HashSet alreadyParsed &#x3D; new HashSet(configCandidates.size());\n\n        do &#123;\n            &#x2F;&#x2F;这里省略，直到所有的配置类全部解析完成\n          \t&#x2F;&#x2F;注意在循环过程中可能会由于@Import新增更多的待解析配置类，一律丢进candidates集合中\n        &#125; while(!candidates.isEmpty());\n\n        ...\n\n    &#125;\n&#125;\n\n我们接着来看，ConfigurationClassParser是如何进行解析的：\nprotected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123;\n  \t&#x2F;&#x2F;@Conditional相关注解处理\n  \t&#x2F;&#x2F;后面会讲\n    if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;\n        ...\n        &#125;\n\n        ConfigurationClassParser.SourceClass sourceClass &#x3D; this.asSourceClass(configClass, filter);\n\n        do &#123;\n          \t&#x2F;&#x2F;核心\n            sourceClass &#x3D; this.doProcessConfigurationClass(configClass, sourceClass, filter);\n        &#125; while(sourceClass !&#x3D; null);\n\n        this.configurationClasses.put(configClass, configClass);\n    &#125;\n&#125;\n\n最后我们再来看最核心的doProcessConfigurationClass方法：\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n    ...\n\n    processImports(configClass, sourceClass, getImports(sourceClass), true);    &#x2F;&#x2F; 处理Import注解\n\n\t\t...\n\n    return null;\n&#125;\n\nprivate void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) &#123;\n    if (!importCandidates.isEmpty()) &#123;\n        if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) &#123;\n            this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));\n        &#125; else &#123;\n            this.importStack.push(configClass);\n\n            try &#123;\n                Iterator var6 &#x3D; importCandidates.iterator();\n\n                while(var6.hasNext()) &#123;\n                    ConfigurationClassParser.SourceClass candidate &#x3D; (ConfigurationClassParser.SourceClass)var6.next();\n                    Class candidateClass;\n                  \t&#x2F;&#x2F;如果是ImportSelector类型，继续进行运行\n                    if (candidate.isAssignable(ImportSelector.class)) &#123;\n                        candidateClass &#x3D; candidate.loadClass();\n                        ImportSelector selector &#x3D; (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry);\n                        Predicate&lt;String&gt; selectorFilter &#x3D; selector.getExclusionFilter();\n                        if (selectorFilter !&#x3D; null) &#123;\n                            exclusionFilter &#x3D; exclusionFilter.or(selectorFilter);\n                        &#125;\n\t\t\t\t\t\t\t\t\t&#x2F;&#x2F;如果是DeferredImportSelector的实现类，那么会走deferredImportSelectorHandler的handle方法\n                        if (selector instanceof DeferredImportSelector) &#123;\n                            this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);\n                          &#x2F;&#x2F;否则就按照正常的ImportSelector类型进行加载\n                        &#125; else &#123;\n                          \t&#x2F;&#x2F;调用selectImports方法获取所有需要加载的类\n                            String[] importClassNames &#x3D; selector.selectImports(currentSourceClass.getMetadata());\n                            Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses &#x3D; this.asSourceClasses(importClassNames, exclusionFilter);\n                          \t&#x2F;&#x2F;递归处理，直到没有\n                            this.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);\n                        &#125;\n                      &#x2F;&#x2F;判断是否为ImportBeanDefinitionRegistrar类型\n                    &#125; else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;\n                        candidateClass &#x3D; candidate.loadClass();\n                        ImportBeanDefinitionRegistrar registrar &#x3D; (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry);\n                      \t&#x2F;&#x2F;往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理\n                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());\n                      &#x2F;&#x2F;否则按普通的配置类进行处理\n                    &#125; else &#123;\n                        this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());\n                        this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);\n                    &#125;\n                &#125;\n            &#125; catch (BeanDefinitionStoreException var17) &#123;\n                throw var17;\n            &#125; catch (Throwable var18) &#123;\n                throw new BeanDefinitionStoreException(&quot;Failed to process import candidates for configuration class [&quot; + configClass.getMetadata().getClassName() + &quot;]&quot;, var18);\n            &#125; finally &#123;\n                this.importStack.pop();\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n不难注意到，虽然这里额外处理了ImportSelector对象，但是还针对ImportSelector的子接口DeferredImportSelector进行了额外处理，Deferred是延迟的意思，它是一个延迟执行的ImportSelector，并不会立即进处理，而是丢进DeferredImportSelectorHandler，并且在parse方法的最后进行处理：\npublic void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;\n     ...\n\n    this.deferredImportSelectorHandler.process();\n&#125;\n\n我们接着来看DeferredImportSelector正好就有一个process方法：\npublic interface DeferredImportSelector extends ImportSelector &#123;\n    @Nullable\n    default Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;\n        return null;\n    &#125;\n\n    public interface Group &#123;\n        void process(AnnotationMetadata metadata, DeferredImportSelector selector);\n\n        Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();\n\n        public static class Entry &#123;\n          ...\n\n最后经过ConfigurationClassParser处理完成后，通过parser.getConfigurationClasses()就能得到通过配置类导入了哪些额外的配置类。最后将这些配置类全部注册BeanDefinition，然后就可以交给接下来的Bean初始化过程去处理了。\nthis.reader.loadBeanDefinitions(configClasses);\n\n最后我们再去看loadBeanDefinitions是如何运行的：\npublic void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) &#123;\n    ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator &#x3D; new ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator();\n    Iterator var3 &#x3D; configurationModel.iterator();\n\n    while(var3.hasNext()) &#123;\n        ConfigurationClass configClass &#x3D; (ConfigurationClass)var3.next();\n        this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);\n    &#125;\n\n&#125;\n\nprivate void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator) &#123;\n    if (trackedConditionEvaluator.shouldSkip(configClass)) &#123;\n        String beanName &#x3D; configClass.getBeanName();\n        if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) &#123;\n            this.registry.removeBeanDefinition(beanName);\n        &#125;\n\n        this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());\n    &#125; else &#123;\n        if (configClass.isImported()) &#123;\n            this.registerBeanDefinitionForImportedConfigurationClass(configClass);  &#x2F;&#x2F;注册配置类自己\n        &#125;\n\n        Iterator var3 &#x3D; configClass.getBeanMethods().iterator();\n\n        while(var3.hasNext()) &#123;\n            BeanMethod beanMethod &#x3D; (BeanMethod)var3.next();\n            this.loadBeanDefinitionsForBeanMethod(beanMethod); &#x2F;&#x2F;注册@Bean注解标识的方法\n        &#125;\n\n      \t&#x2F;&#x2F;注册&#96;@ImportResource&#96;引入的XML配置文件中读取的bean定义\n        this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());\n     \t &#x2F;&#x2F;注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition\n        this.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());\n    &#125;\n&#125;\n\n这样，整个@Configuration配置类的底层配置流程我们就大致了解了。接着我们来看AutoConfigurationImportSelector是如何实现自动配置的，可以看到内部类AutoConfigurationGroup的process方法，它是父接口的实现，因为父接口是DeferredImportSelector，那么很容易得知，实际上最后会调用process方法获取所有的自动配置类：\npublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123;\n    Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; &#123;\n        return String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());\n    &#125;);\n  \t&#x2F;&#x2F;获取所有的Entry，其实就是，读取spring.factories来查看有哪些自动配置类\n    AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry &#x3D; ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);\n    this.autoConfigurationEntries.add(autoConfigurationEntry);\n    Iterator var4 &#x3D; autoConfigurationEntry.getConfigurations().iterator();\n\n    while(var4.hasNext()) &#123;\n        String importClassName &#x3D; (String)var4.next();\n        this.entries.putIfAbsent(importClassName, annotationMetadata);\n    &#125;\n\n&#125;\n\n我们接着来看getAutoConfigurationEntry方法：\nprotected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;\n  \t&#x2F;&#x2F;判断是否开启了自动配置，是的，自动配置可以关\n    if (!this.isEnabled(annotationMetadata)) &#123;\n        return EMPTY_ENTRY;\n    &#125; else &#123;\n      \t&#x2F;&#x2F;根据注解定义获取一些属性\n        AnnotationAttributes attributes &#x3D; this.getAttributes(annotationMetadata);\n      \t&#x2F;&#x2F;得到spring.factories文件中所有需要自动配置的类\n        List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(annotationMetadata, attributes);\n        ... 这里先看前半部分\n    &#125;\n&#125;\n\n注意这里并不是spring.factories文件中所有的自动配置类都会被加载，它会根据@Condition注解的条件进行加载。这样就能实现我们需要什么模块添加对应依赖就可以实现自动配置了。\n所有的源码看不懂，都源自于你的心中没有形成一个完整的闭环！一旦一条线推到头，闭环形成，所有疑惑迎刃而解。\n自定义Starter我们仿照Mybatis来编写一个自己的starter，Mybatis的starter包含两个部分：\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n  &lt;parent&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.0&lt;&#x2F;version&gt;\n  &lt;&#x2F;parent&gt;\n  &lt;!--  starter本身只做依赖集中管理，不编写任何代码  --&gt;\n  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;\n  &lt;name&gt;mybatis-spring-boot-starter&lt;&#x2F;name&gt;\n  &lt;properties&gt;\n    &lt;module.name&gt;org.mybatis.spring.boot.starter&lt;&#x2F;module.name&gt;\n  &lt;&#x2F;properties&gt;\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;!--  编写的专用配置模块   --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n因此我们也将我们自己的starter这样设计：\n我们设计三个模块：\n\nspring-boot-hello：基础业务功能模块\nspring-boot-starter-hello：启动器\nspring-boot-autoconifgurer-hello：自动配置依赖\n\n首先是基础业务功能模块，这里我们随便创建一个类就可以了：\npublic class HelloWorldService &#123;\n\t\n&#125;\n\n启动器主要做依赖管理，这里就不写任何代码，只写pom文件：\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-autoconfigurer-hello&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n导入autoconfigurer模块作为依赖即可，接着我们去编写autoconfigurer模块，首先导入依赖：\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.6.2&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.6.2&lt;&#x2F;version&gt;\n        &lt;optional&gt;true&lt;&#x2F;optional&gt;\n    &lt;&#x2F;dependency&gt;\n    \n    &lt;dependency&gt;\n        &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-hello&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n接着创建一个HelloWorldAutoConfiguration作为自动配置类：\n@Configuration(proxyBeanMethods &#x3D; false)\n@ConditionalOnWebApplication\n@ConditionalOnClass(HelloWorldService.class)\n@EnableConfigurationProperties(HelloWorldProperties.class)\npublic class HelloWorldAutoConfiguration &#123;\n\n    Logger logger &#x3D; Logger.getLogger(this.getClass().getName());\n\n    @Resource\n    HelloWorldProperties properties;\n\n    @Bean\n    public HelloWorldService helloWorldService()&#123;\n        logger.info(&quot;自定义starter项目已启动！&quot;);\n        logger.info(&quot;读取到自定义配置：&quot;+properties.getValue());\n        return new HelloWorldService();\n    &#125;\n&#125;\n\n对应的配置读取类：\n@ConfigurationProperties(&quot;hello.world&quot;)\npublic class HelloWorldProperties &#123;\n\n    private String value;\n\n    public void setValue(String value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public String getValue() &#123;\n        return value;\n    &#125;\n&#125;\n\n最后再编写spring.factories文件，并将我们的自动配置类添加即可：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\\n  com.hello.autoconfigurer.HelloWorldAutoConfiguration\n\n最后再Maven根项目执行install安装到本地仓库，完成。接着就可以在其他项目中使用我们编写的自定义starter了。\nRunner接口在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。\n我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：\n@Component\npublic class TestRunner implements ApplicationRunner &#123;\n    @Override\n    public void run(ApplicationArguments args) throws Exception &#123;\n        System.out.println(&quot;我是自定义执行！&quot;);\n    &#125;\n&#125;\n\n当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。\n实际上它就是run方法的最后：\npublic ConfigurableApplicationContext run(String... args) &#123;\n    ....\n\n        listeners.started(context, timeTakenToStartup);\n  \t\t\t&#x2F;&#x2F;这里已经完成整个SpringBoot项目启动，所以执行所有的Runner\n        this.callRunners(context, applicationArguments);\n    &#125; catch (Throwable var12) &#123;\n        this.handleRunFailure(context, var12, listeners);\n        throw new IllegalStateException(var12);\n    &#125;\n\n    try &#123;\n        Duration timeTakenToReady &#x3D; Duration.ofNanos(System.nanoTime() - startTime);\n        listeners.ready(context, timeTakenToReady);\n        return context;\n    &#125; catch (Throwable var11) &#123;\n        this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var11);\n    &#125;\n&#125;\n\n下一章，我们将继续讲解几乎程序员必会的Git版本控制。\n","slug":"SpringBoot笔记（一）","date":"2022-03-05T14:36:00.311Z","categories_index":"SpringBoot笔记","tags_index":"SpringBoot笔记","author_index":"YangChao"},{"id":"9cce5bf1444b7fcba89f1d78107c0341","title":"那些经典话语","content":"\n想看就点开看看吧\n英：I’m tired,Tired of bein’ on the road, lonely as a sparrow in the rain，Tired of not ever having me a buddy to be with, or tell me where we’s coming from or going to, or why. Mostly I’m tired of people being ugly to each other. I’m tired of all the pain I feel and hear in the world everyday. There’s too much of it. It’s like pieces of glass in my head all the time. Can you understand?\n中：我累了，厌倦在路上，像雨中孤独的麻雀。厌倦没有伙伴陪伴，或者告诉我何去何从，或者为什么，我厌倦了人们丑陋的彼此相待，厌倦了每天感到和听到的伤痛。太多了。它一直就像我脑袋里的玻璃碴。你能理解吗？\n—电影《绿里奇迹》\n\n\n想看就点开看看吧\n英：People hurt the ones they love. That’s how it is all around the world.\n中：人们伤害他们爱的人。全世界都是这样。\n—电影《绿里奇迹》\n\n","slug":"那些经典话语","date":"2022-03-04T13:38:15.000Z","categories_index":"","tags_index":"那些经典话语","author_index":"YangChao"},{"id":"1269f6284fcda69dd94df081174c6509","title":"个人简历","content":"欢迎来看我的个人简历，在这里你可以初步认识到我\n个人简历个人信息姓名：杨超性别：男生日：1996-09-04\n个人优势学习快，能吃苦，为人和善善于交流\n工作经历公司：特殊原因暂时不写负责模块：Java开发，项目维护，接口开发\n掌握技术Java基础SpringSpringBootDB2、MySqlKingdee集成云开发Web Service开发RESTfulHexo框架JFinal框架JavaScriptJQWidgetsDevExtremeRabbitmqLinuxTomcatSweetAlert了解集群使用过JenkinsWebSphere稍微学习过C语言，C#\n软件使用SoapUIEclipseIdeaDbeaverVscodeWebstormFineReport8.0、9.0XshellPostmanIBM BPD流程设计器MemoryAnalyzerToad for DB2 Freeware\n项目经历项目：特殊原因暂时不写\n教育经历学历：二本学校：特殊原因暂时不写专业：计算机科学与技术毕业设计是以C#和Unity3D设计了一个局域网双人CS射击对战游戏\n个人爱好写个人博客，研究和学习新技术，听音乐\n人总会进步，我也是，持续更新中…","slug":"我的主页","date":"2022-03-04T13:30:23.000Z","categories_index":"个人简历","tags_index":"个人简历","author_index":"YangChao"},{"id":"b011c8bded7d1f7bd33c91d223680d0d","title":"hexo文档","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-03-04T12:51:28.456Z","categories_index":"hexo文档","tags_index":"hexo文档","author_index":"YangChao"}]